<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::File Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1File.html">File</a>
  </div>
</div>
<div class="contents">
<h1>Gio::File Class Reference</h1><!-- doxytag: class="Gio::File" --><!-- doxytag: inherits="Glib::Interface" -->
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> and directory handling. <a href="#_details">More...</a></p>

<p>Inherits <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a>.</p>
<div class="dynheader">
Collaboration diagram for Gio::File:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1File__coll__graph.png" border="0" usemap="#Gio_1_1File_coll__map" alt="Collaboration graph"/></div>
<map name="Gio_1_1File_coll__map" id="Gio_1_1File_coll__map">
<area shape="rect" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="13,160,117,189"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,125,112"/><area shape="rect" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="12,5,119,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1File-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void, <br class="typebreak"/>
goffset, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. <a href="#ac5ff32ee99845479d138eee49d92e59c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; bool, <br class="typebreak"/>
const char*, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. <a href="#add182d22071784fc345adc757b3d687b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af17e8c7b30baa13aaa5d58ef4d56e383">~File</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a96552cfbaf2e5fa3659a1568db8cca91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5437bc648d8b73451e8bee0bc902cfc0">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a5437bc648d8b73451e8bee0bc902cfc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">dup</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> handle. <a href="#a9ea238062cdc317ae982ffae5c226c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">hash</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a0320bac72ecc9ced1f894f1af696856f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">equal</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality of two given Files. <a href="#a8877115c870ea8f58b03d1d3c01a83e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">get_basename</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#ac731bed45bb7fcfd411eb69c49d3b883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">get_path</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, if one exists. <a href="#a7b3edc7946b681b6db2cdcdad08d2b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">get_uri</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI for the <em>file</em>. <a href="#a2d1313e4a4eb5de034b693ec1cc9fba0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">get_parse_name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parse name of the <em>file</em>. <a href="#aea4a78163e3085a35cbaacde9a3a7628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">get_parent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent directory for the <em>file</em>. <a href="#af39bbd5013b2dd675911df322e12ff94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">get_child</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child of <em>file</em> with basename equal to <em>name</em>. <a href="#a53c533d6bbeaaadd1b5592cf1e5ef93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">get_child_for_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF8 version of the name). <a href="#a479cfd632af30b29e125f904f809ed71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">has_prefix</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; prefix) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. <a href="#a4c40ec88dfc4333f19e939d26a1e0332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">get_relative_path</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; descendant) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path for <em>descendant</em> relative to <em>parent</em>. <a href="#a464248111fa2bc5df89c620354eb99bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">resolve_relative_path</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; relative_path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a relative path for <em>file</em> to an absolute path. <a href="#ac5e286d421c7236df39881f8ce0a4e03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">is_native</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a file is native to the platform. <a href="#aaa3b910bc9f240d4ebd0efc70979f163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">has_uri_scheme</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri_scheme) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> has a given URI scheme. <a href="#a90d71529e5b51b9ff73914eaf90be0f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">get_uri_scheme</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#aeecec6962f955bd72ac5595be37db7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">read</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading. <a href="#a3ef959c7ad7096846f26eb8b282e3c68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1">read</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading. <a href="#a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">read_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading. <a href="#a2826eed0b1e76c3771f6ad5f5b993991"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab451a182a647408e697c9115e66f6194">read_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading. <a href="#ab451a182a647408e697c9115e66f6194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_read_async(). <a href="#a64b10854ad1add1f888ecb19403eb921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528">append_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file. <a href="#a91c93ee71eee738690cb551d11df9528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8db337b93f3b9b9a6e163477391e6c89">append_to</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file. <a href="#a8db337b93f3b9b9a6e163477391e6c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2">create_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it. <a href="#a86258e11b2884422819d051c3cfd07a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cf2b17b953ccfefb1d13c39bd1be72c">create_file</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it. <a href="#a5cf2b17b953ccfefb1d13c39bd1be72c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de">replace</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. <a href="#ad7cf0360096504e40f799fde5cc8e9de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acf55f9291659566f6fd36271801b013b">replace</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. <a href="#acf55f9291659566f6fd36271801b013b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1e3dfb193e8f2ab69e24c4370de5335a">append_to_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending. <a href="#a1e3dfb193e8f2ab69e24c4370de5335a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abff3163e9bf8d8208cd0c0e568b777de">append_to_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending. <a href="#abff3163e9bf8d8208cd0c0e568b777de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6">append_to_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file append operation started with g_file_append_to_async(). <a href="#acb1f2d32055b8da274ea241c69487dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0c42446d37aa466173965b7db1a2053">create_file_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it. <a href="#ae0c42446d37aa466173965b7db1a2053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3fe6ed015f3d2bb72aa7aceed8dc7ca1">create_file_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it. <a href="#a3fe6ed015f3d2bb72aa7aceed8dc7ca1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a">create_file_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_async(). <a href="#a622b9f7aeaebe2ac53df0574c9c4211a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad777cdaa404a6a668ee8d520299687ce">replace_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. <a href="#ad777cdaa404a6a668ee8d520299687ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae51e51a2e3a45da4324230b4d5401a58">replace_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. <a href="#ae51e51a2e3a45da4324230b4d5401a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e">replace_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_async(). <a href="#ab28557d592f2c53df618728cf865e65e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd">query_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file. <a href="#adb25ffdbe571d33e89c9503fe9a20dcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e4b9c07ade255b12e2b43c38c3aba90">query_info</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file. <a href="#a4e4b9c07ade255b12e2b43c38c3aba90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">query_exists</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if a particular file exists. <a href="#ad8b0a75e0afdb5f6874ea5e304d55ea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab4cfdbf4fedacd364e40a72c71ab341a">query_exists</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if a particular file exists. <a href="#ab4cfdbf4fedacd364e40a72c71ab341a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the FileType of a file. <a href="#aa27c5b271c8f7667ce117cfc6118262e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a691a9de5512b870bf358a9b0d292e146">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the GFileType of a file. <a href="#a691a9de5512b870bf358a9b0d292e146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7bd60e7864f8954c35e3b0891058e61c">query_info_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file. <a href="#a7bd60e7864f8954c35e3b0891058e61c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afcad69d782a971802a8aa85125ac2c8c">query_info_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file. <a href="#afcad69d782a971802a8aa85125ac2c8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357">query_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file info query. <a href="#afd4ffc3630b41754c177658f2e745357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">query_filesystem_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. <a href="#a40486bc2f0c8758ef8a705b6b8b57e57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac737012f8df97d90e2447d94d30b817d">query_filesystem_info</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. <a href="#ac737012f8df97d90e2447d94d30b817d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">find_enclosing_mount</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a45b881926b8d58c49d3baa1f51f2ee5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">query_filesystem_info_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on. <a href="#a39184ff9c9437259df4b9a9e2f283a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4557ab16a50337f73d8a4649cf60fe70">query_filesystem_info_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on. <a href="#a4557ab16a50337f73d8a4649cf60fe70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b">query_filesystem_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous filesystem info query. <a href="#afd1159de8f782d918d8d460cddffee5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333">find_enclosing_mount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a6eb675267c7ea1c2a0d40e2e754d8333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">find_enclosing_mount_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file. <a href="#a78c95d4fa47157f7757b686677dec018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a67458be57c5687e7469bc26e2594f4be">find_enclosing_mount_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file. <a href="#a67458be57c5687e7469bc26e2594f4be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433">find_enclosing_mount_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous find mount request. <a href="#aa12e6222d81179937cdc366f4d315433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20">enumerate_children</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory. <a href="#a68c3afcddc0d4860aa2afb4bf715bb20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac0e293d607499b223f4892fb290ab2d6">enumerate_children</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory. <a href="#ac0e293d607499b223f4892fb290ab2d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ead7237b7057d9b15cf5f3065988131">enumerate_children_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory. <a href="#a1ead7237b7057d9b15cf5f3065988131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b5470cf1c97754a12169201665f1202">enumerate_children_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory. <a href="#a5b5470cf1c97754a12169201665f1202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14">enumerate_children_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async enumerate children operation. <a href="#a617a2950448788e68df128c58e068a14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames <em>file</em> to the specified display name. <a href="#a3dd75810d7c9ebafac398288f5afc018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8c2aa80b2d0ecdd22f0222c8ce42d177">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames the file to the specified display name. <a href="#a8c2aa80b2d0ecdd22f0222c8ce42d177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. <a href="#a0ac539d7758b9c0de809f8c83e0bba79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a74d219d321dca3d438f876256dee82d2">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. <a href="#a74d219d321dca3d438f876256dee82d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a">set_display_name_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes setting a display name started with g_file_set_display_name_async(). <a href="#a101b555723233014c0185dd505303f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">remove</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file. <a href="#aded971b0cf84801f6684ad4bd5dc66c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4">remove</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file. <a href="#a14f34508dea523cbf889b7193e513ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">trash</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <em>file</em> to the "Trashcan", if possible. <a href="#acae5ecd962e832cf8d538877f4118da8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e">trash</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the file to the "Trashcan", if possible. <a href="#a1925736f9af338eaf9942468b4d6d65e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination. <a href="#af9e906ed93069e6adb6d87dae158cad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1d8159b5b377db174b376b3c09deb7c1">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7a6b45bed32567031bc7b48273ad4079">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot_progress, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#a1785b7a4780d5d4ba5ae651350e34398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b8ae7393c73a9a1d383a82d61f4ac30">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#a5b8ae7393c73a9a1d383a82d61f4ac30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2b1a85f29bbbe15998c090b3794cbf5">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot_progress, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#ac2b1a85f29bbbe15998c090b3794cbf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad538a383b8761d04bd36ed1aa1071e50">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#ad538a383b8761d04bd36ed1aa1071e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6">copy_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes copying the file started with g_file_copy_async(). <a href="#a68294636a2d649c9de53332faee02cf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to move the file or directory source to the location specified by destination. <a href="#a51c0d55880178c37dee578fdc723b0f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adfb2d8bfed1cb7af50e5e5795ebea732">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aba1fab56c3a8bea0b7e4d7f7324c5320">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">make_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory. <a href="#abfa05e23e95e77cabac289ab4e294a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554">make_directory</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory. <a href="#aa1e9aa5f58a76a8562fd00a13434f554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">make_directory_with_parents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. <a href="#afb0b5b094339057b4b15952eb73e08d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6">make_directory_with_parents</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory and any parent directories that may not exist, similar to 'mkdir -p'. <a href="#a874a487551d49ca62b31a3e5cf32fee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">make_symbolic_link</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic link. <a href="#a2709318e1f24dfd0cd498d28f5e1b8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a9a3d060c2675ff9ac1c758f0b2c024">make_symbolic_link</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic link. <a href="#a8a9a3d060c2675ff9ac1c758f0b2c024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">query_settable_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of settable attributes for the file. <a href="#a4a543339b58cff6a7e5ddd840df0e69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4">query_settable_attributes</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of settable attributes for the file. <a href="#a1ae03d0652bcfbad2f47409b8f815bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">query_writable_namespaces</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user. <a href="#af5c7463b92e2887597486e7b195ca12f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0">query_writable_namespaces</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user. <a href="#aa0278acd7d09ed292359004defb742b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> on the target values, not stopping on the first error. <a href="#a69d9e40a85b96809abc5189b34e8d9b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae9f6975ffef28f0d7145601a99de0903">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> on the target values, not stopping on the first error. <a href="#ae9f6975ffef28f0d7145601a99de0903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14165fba9bf7d91448c3207407ae50c2">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info. <a href="#a14165fba9bf7d91448c3207407ae50c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a61317a1980318537aa8ada7bb8cc2390">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info. <a href="#a61317a1980318537aa8ada7bb8cc2390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6">set_attribute_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. <a href="#a5ce5f43fd5e2836ac1989a54d3233ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a75fa7e1a44e97a910d232f2b4ab4bfdd">set_attribute_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. <a href="#a75fa7e1a44e97a910d232f2b4ab4bfdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">set_attribute_byte_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. <a href="#a4f4373b8694c346a6908195f1f2644f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a09f574259052186e1b516bdcbe696710">set_attribute_byte_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. <a href="#a09f574259052186e1b516bdcbe696710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">set_attribute_uint32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. <a href="#ae53b0f4d2214e050a290c8e35cac0f27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7f769f140143f2e96a7587a10b6792a9">set_attribute_uint32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. <a href="#a7f769f140143f2e96a7587a10b6792a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">set_attribute_int32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. <a href="#ab0290ecba7b06ccf7736e2292708667e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a707084a3c0a963548a21d17d0ec0b5">set_attribute_int32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. <a href="#a4a707084a3c0a963548a21d17d0ec0b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">set_attribute_uint64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. <a href="#a48638081fd7af772a39af59a558b17f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4aa77b3580df88cfd3d7231af78155c7">set_attribute_uint64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. <a href="#a4aa77b3580df88cfd3d7231af78155c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">set_attribute_int64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. <a href="#a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4477b0063110951b26c855696ec34802">set_attribute_int64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01167.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. <a href="#a4477b0063110951b26c855696ec34802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a144aa2de6b696da90a6baffbe959d732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a70fd22116d9c8682433c4bb8cbd764c1">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a70fd22116d9c8682433c4bb8cbd764c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2172cdcdb683630b719c521bf00b1eb4">mount_enclosing_volume</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a2172cdcdb683630b719c521bf00b1eb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a20f8f18876102a5efaa0536bfa71d71c">mount_enclosing_volume</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a20f8f18876102a5efaa0536bfa71d71c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">mount_enclosing_volume_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation started by g_file_mount_enclosing_volume(). <a href="#aefd44b1b3467bcc474b345ff98b4aa6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a40c88a403f5d01d722b5900545b6a4fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac3c29682ef5a50de73dc2c3c3333301c">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ac3c29682ef5a50de73dc2c3c3333301c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a049e06c3d95b49ad4bff1837ef6d8677">mount_mountable</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. <a href="#a049e06c3d95b49ad4bff1837ef6d8677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8501fa88f4aaa8d52c001596960a4572">mount_mountable</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=MOUNT_MOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. <a href="#a8501fa88f4aaa8d52c001596960a4572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">mount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation. <a href="#ae15d36a7969c55122b9f85a1690a46e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">unmount_mountable</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a5b687c8f19411e955bb069c469be92b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab6c8e9ef0e5d83a271c8307b18e779d8">unmount_mountable</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ab6c8e9ef0e5d83a271c8307b18e779d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a95f3e87e198493f4332a08aa79f6ebd3">unmount_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a95f3e87e198493f4332a08aa79f6ebd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">unmount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an unmount operation, see g_file_unmount_mountable() for details. <a href="#a51458cf04ad25e4a784a3ebcb906155d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">eject_mountable</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#a8a8223e3b661f03c7a60ac0f003b916e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8422a939a634d2248ef6d8658f0fdad">eject_mountable</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#ad8422a939a634d2248ef6d8658f0fdad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeb28fd505cab23a82c68ff00445b12e7">eject_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=MOUNT_UNMOUNT_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#aeb28fd505cab23a82c68ff00445b12e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">eject_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous eject operation started by g_file_eject_mountable(). <a href="#a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90726dcf94248d2fddf2e4c8584b7bf0">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>. <a href="#a90726dcf94248d2fddf2e4c8584b7bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a05c1101ede98028c9234486eb0434250">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=FILE_COPY_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>. <a href="#a05c1101ede98028c9234486eb0434250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0fa22ffba0ff50779e49ff9d12344e6">monitor_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file. <a href="#aa0fa22ffba0ff50779e49ff9d12344e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a12d36689c1024ff9fc8819f619910a92">monitor_directory</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file. <a href="#a12d36689c1024ff9fc8819f619910a92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab8e14809f330ddd58e628c96921cd987">monitor_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#ab8e14809f330ddd58e628c96921cd987"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa410183ed3b4a745093383d038d271b9">monitor_file</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#aa410183ed3b4a745093383d038d271b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a88aacee7bb6f6d968b4383311a9dd002">monitor</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#a88aacee7bb6f6d968b4383311a9dd002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a50896969a9de87f810f0bf5e2d3335bd">monitor</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=FILE_MONITOR_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#a50896969a9de87f810f0bf5e2d3335bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">query_default_handler</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns: a <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> if the handle was found, <code>0</code> if there were errors. <a href="#a753546465735b25633b003333b66d05c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283">query_default_handler</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> that is registered as the default application to handle the file specified by the file. <a href="#a0c0fd0ece2570b6704889df5ee43c283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#ac53be228d732b34e062a2a57814cdf15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ada7c826a417f88b405244c8dc39ae1ef">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#ada7c826a417f88b405244c8dc39ae1ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a77f7781b0ba65bc4e7e613b80b353fd7">load_contents</a> (char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#a77f7781b0ba65bc4e7e613b80b353fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40f3ce7cf905144bac7218f9988d2d35">load_contents</a> (char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#a40f3ce7cf905144bac7218f9988d2d35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">load_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents. <a href="#ad0e02ebffbaa13036e4636d2118f71a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6af7ec98d5543bce07b917b65d7276ce">load_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents. <a href="#a6af7ec98d5543bce07b917b65d7276ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents. <a href="#a5fd15277ab90bcc57db088be04cac457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aee93c7e24e8391615f9f263584fb02bd">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents. <a href="#aee93c7e24e8391615f9f263584fb02bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">load_partial_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotReadMore</a>&amp; slot_read_more, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_async_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file. <a href="#a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a362d71932c0ba8797a8c47b77df1b6d7">load_partial_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotReadMore</a>&amp; slot_read_more, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot_async_ready)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file. <a href="#a362d71932c0ba8797a8c47b77df1b6d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. <a href="#a4b323508401d2e6fd2b3ad659f9bb5eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae3a59c3831feeadea9bd0709617d2db9">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. <a href="#ae3a59c3831feeadea9bd0709617d2db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. <a href="#af10deca1d5c5d1f650d3b182624330dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae7febf1f0f3b4b9efca9fae469082846">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. <a href="#ae7febf1f0f3b4b9efca9fae469082846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a23126b43cd262b63c0e458c3a4d0b65c">replace_contents</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>. <a href="#a23126b43cd262b63c0e458c3a4d0b65c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaf33a17461ff4f70fed06818e364f617">replace_contents</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>. <a href="#aaf33a17461ff4f70fed06818e364f617"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">replace_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#ad33b24a7942429157f47379f4353378c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9a1c445e84124e16294974a73f2f1bbb">replace_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#a9a1c445e84124e16294974a73f2f1bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a380d6ce6362fc05e0e18ff1b881ceac7">replace_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#a380d6ce6362fc05e0e18ff1b881ceac7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6fc86aab90620881899a701c2b2775cb">replace_contents_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=FILE_CREATE_NONE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em>. <a href="#a6fc86aab90620881899a701c2b2775cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file . <a href="#af019065c5503c7f47d778c20f8e5de32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af0372ffd3f535f39b7e48c0483e4c1f4">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file . <a href="#af0372ffd3f535f39b7e48c0483e4c1f4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa9352e68c93431dd16b8ac587703772f">add_interface</a> (GType gtype_implementer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">create_for_path</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given path. <a href="#a1b1a4553b226689d50b9525488223e25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">create_for_uri</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given URI. <a href="#a412b6b55f37f69bd4fb8fbd24d4967be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">create_for_commandline_arg</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#gabc043a433d81c9dbe73668c5fd0362fe">arg</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given argument from the command line. <a href="#ab311a1c606b3907865fc8aecd4691de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7532baa6ce71fe27cfd1e9bba91a3536">create_for_parse_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; parse_name)</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">wrap</a> (GFile* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a69670cdc7cf63783d6f9370dcbd7cc3d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> and directory handling. </p>
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> is a high level abstraction for manipulating files on a virtual file system. Gio::Files are lightweight, immutable objects that do no I/O upon creation. It is necessary to understand that a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object does not represent a file, merely a handle to a file. All file I/O is implemented as streaming operations (see <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">Gio::InputStream</a> and <a class="el" href="classGio_1_1OutputStream.html" title="Base class for implementing streaming output.">Gio::OutputStream</a>).</p>
<p>A GioFile can be constructed from a path, URI, or a command line argument.</p>
<p>You can move through the filesystem with <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> handles with <a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94" title="Gets the parent directory for the file.">get_parent()</a> to get a handle to the parent directory, <a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c" title="Gets a child of file with basename equal to name.">get_child()</a> to get a handle to a child within a directory, and <a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03" title="Resolves a relative path for file to an absolute path.">resolve_relative_path()</a> to resolve a relative path between two Gio::Files.</p>
<p>Many <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> operations have both synchronous and asynchronous versions to suit your application. Asynchronous versions of synchronous functions simply have _async() appended to their function names. The asynchronous I/O functions call a SlotAsyncReady callback slot which is then used to finalize the operation, producing a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> which is then passed to the function's matching _finish() operation.</p>
<p>Some <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> operations do not have synchronous analogs, as they may take a very long time to finish, and blocking may leave an application unusable. Notable cases include: <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe" title="Mounts a file of type FILE_TYPE_MOUNTABLE.">mount_mountable()</a> to mount a mountable file, <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4" title="Unmounts a file of type FILE_TYPE_MOUNTABLE.">unmount_mountable()</a> to unmount a mountable file, and <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e" title="Starts an asynchronous eject on a mountable.">eject_mountable()</a> to eject a mountable file.</p>
<p>One notable feature of Gio::Files are entity tags, or "etags" for short. Entity tags are somewhat like a more abstract version of the traditional mtime, and can be used to quickly determine if the file has been modified from the version on the file system. See the HTTP 1.1 specification for HTTP Etag headers, which are a very similar concept.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000023">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ac5ff32ee99845479d138eee49d92e59c"></a><!-- doxytag: member="Gio::File::SlotFileProgress" ref="ac5ff32ee99845479d138eee49d92e59c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;void, goffset, goffset&gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Gio::File::SlotFileProgress</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. </p>

</div>
</div>
<a class="anchor" id="add182d22071784fc345adc757b3d687b"></a><!-- doxytag: member="Gio::File::SlotReadMore" ref="add182d22071784fc345adc757b3d687b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;bool, const char*, goffset&gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Gio::File::SlotReadMore</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af17e8c7b30baa13aaa5d58ef4d56e383"></a><!-- doxytag: member="Gio::File::~File" ref="af17e8c7b30baa13aaa5d58ef4d56e383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::File::~File </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa9352e68c93431dd16b8ac587703772f"></a><!-- doxytag: member="Gio::File::add_interface" ref="aa9352e68c93431dd16b8ac587703772f" args="(GType gtype_implementer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gio::File::add_interface </td>
          <td>(</td>
          <td class="paramtype">GType&#160;</td>
          <td class="paramname"> <em>gtype_implementer</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8db337b93f3b9b9a6e163477391e6c89"></a><!-- doxytag: member="Gio::File::append_to" ref="a8db337b93f3b9b9a6e163477391e6c89" args="(FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a91c93ee71eee738690cb551d11df9528"></a><!-- doxytag: member="Gio::File::append_to" ref="a91c93ee71eee738690cb551d11df9528" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abff3163e9bf8d8208cd0c0e568b777de"></a><!-- doxytag: member="Gio::File::append_to_async" ref="abff3163e9bf8d8208cd0c0e568b777de" args="(const SlotAsyncReady &amp;slot, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file.">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6" title="Finishes an asynchronous file append operation started with g_file_append_to_async()...">append_to_finish()</a> to get the result of the operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e3dfb193e8f2ab69e24c4370de5335a"></a><!-- doxytag: member="Gio::File::append_to_async" ref="a1e3dfb193e8f2ab69e24c4370de5335a" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file.">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6" title="Finishes an asynchronous file append operation started with g_file_append_to_async()...">append_to_finish()</a> to get the result of the operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb1f2d32055b8da274ea241c69487dc6"></a><!-- doxytag: member="Gio::File::append_to_finish" ref="acb1f2d32055b8da274ea241c69487dc6" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file append operation started with g_file_append_to_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td><a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a7a6b45bed32567031bc7b48273ad4079"></a><!-- doxytag: member="Gio::File::copy" ref="a7a6b45bed32567031bc7b48273ad4079" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d8159b5b377db174b376b3c09deb7c1"></a><!-- doxytag: member="Gio::File::copy" ref="a1d8159b5b377db174b376b3c09deb7c1" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af9e906ed93069e6adb6d87dae158cad9"></a><!-- doxytag: member="Gio::File::copy" ref="af9e906ed93069e6adb6d87dae158cad9" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle.">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="ad538a383b8761d04bd36ed1aa1071e50"></a><!-- doxytag: member="Gio::File::copy_async" ref="ad538a383b8761d04bd36ed1aa1071e50" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotAsyncReady &amp;slot_ready, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_ready</em>&#160;</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Set of FileCopyFlags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2b1a85f29bbbe15998c090b3794cbf5"></a><!-- doxytag: member="Gio::File::copy_async" ref="ac2b1a85f29bbbe15998c090b3794cbf5" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot_progress, const SlotAsyncReady &amp;slot_ready, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_progress</em>&#160;</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_ready</em>&#160;</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Set of FileCopyFlags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8ae7393c73a9a1d383a82d61f4ac30"></a><!-- doxytag: member="Gio::File::copy_async" ref="a5b8ae7393c73a9a1d383a82d61f4ac30" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotAsyncReady &amp;slot_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_ready</em>&#160;</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Set of FileCopyFlags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1785b7a4780d5d4ba5ae651350e34398"></a><!-- doxytag: member="Gio::File::copy_async" ref="a1785b7a4780d5d4ba5ae651350e34398" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot_progress, const SlotAsyncReady &amp;slot_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_progress</em>&#160;</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_ready</em>&#160;</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Set of FileCopyFlags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05c1101ede98028c9234486eb0434250"></a><!-- doxytag: member="Gio::File::copy_attributes" ref="a05c1101ede98028c9234486eb0434250" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to copy attributes to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a90726dcf94248d2fddf2e4c8584b7bf0"></a><!-- doxytag: member="Gio::File::copy_attributes" ref="a90726dcf94248d2fddf2e4c8584b7bf0" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&#160;</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to copy attributes to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a68294636a2d649c9de53332faee02cf6"></a><!-- doxytag: member="Gio::File::copy_finish" ref="a68294636a2d649c9de53332faee02cf6" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes copying the file started with g_file_copy_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf2b17b953ccfefb1d13c39bd1be72c"></a><!-- doxytag: member="Gio::File::create_file" ref="a5cf2b17b953ccfefb1d13c39bd1be72c" args="(FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exists.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a86258e11b2884422819d051c3cfd07a2"></a><!-- doxytag: member="Gio::File::create_file" ref="a86258e11b2884422819d051c3cfd07a2" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exists.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe6ed015f3d2bb72aa7aceed8dc7ca1"></a><!-- doxytag: member="Gio::File::create_file_async" ref="a3fe6ed015f3d2bb72aa7aceed8dc7ca1" args="(const SlotAsyncReady &amp;slot, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it.">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a" title="Finishes an asynchronous file create operation started with g_file_create_async()...">create_file_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0c42446d37aa466173965b7db1a2053"></a><!-- doxytag: member="Gio::File::create_file_async" ref="ae0c42446d37aa466173965b7db1a2053" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it.">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a" title="Finishes an asynchronous file create operation started with g_file_create_async()...">create_file_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a622b9f7aeaebe2ac53df0574c9c4211a"></a><!-- doxytag: member="Gio::File::create_file_finish" ref="a622b9f7aeaebe2ac53df0574c9c4211a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab311a1c606b3907865fc8aecd4691de8"></a><!-- doxytag: member="Gio::File::create_for_commandline_arg" ref="ab311a1c606b3907865fc8aecd4691de8" args="(const std::string &amp;arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_commandline_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given argument from the command line. </p>
<p>The value of <em>arg</em> can be either a URI, an absolute path or a relative path resolved relative to the current working directory. This operation never fails, but the returned object might not support any I/O operation if arg points to a malformed path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&#160;</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a7532baa6ce71fe27cfd1e9bba91a3536"></a><!-- doxytag: member="Gio::File::create_for_parse_name" ref="a7532baa6ce71fe27cfd1e9bba91a3536" args="(const Glib::ustring &amp;parse_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_parse_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>parse_name</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b1a4553b226689d50b9525488223e25"></a><!-- doxytag: member="Gio::File::create_for_path" ref="a1b1a4553b226689d50b9525488223e25" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given path. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&#160;</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a412b6b55f37f69bd4fb8fbd24d4967be"></a><!-- doxytag: member="Gio::File::create_for_uri" ref="a412b6b55f37f69bd4fb8fbd24d4967be" args="(const std::string &amp;uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_uri </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given URI. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&#160;</td><td>A string containing a URI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea238062cdc317ae982ffae5c226c9b"></a><!-- doxytag: member="Gio::File::dup" ref="a9ea238062cdc317ae982ffae5c226c9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::dup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> handle. </p>
<p>This operation does not duplicate the actual file or directory represented by the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>; see g_file_copy() if attempting to copy a file.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> that is a duplicate of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb28fd505cab23a82c68ff00445b12e7"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="aeb28fd505cab23a82c68ff00445b12e7" args="(MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8422a939a634d2248ef6d8658f0fdad"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="ad8422a939a634d2248ef6d8658f0fdad" args="(const SlotAsyncReady &amp;slot, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a8223e3b661f03c7a60ac0f003b916e"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="a8a8223e3b661f03c7a60ac0f003b916e" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a><!-- doxytag: member="Gio::File::eject_mountable_finish" ref="a6a5124de7c55e9dc5e85ffcb9d3dd14f" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::eject_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous eject operation started by g_file_eject_mountable(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>file</em> was ejected successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0e293d607499b223f4892fb290ab2d6"></a><!-- doxytag: member="Gio::File::enumerate_children" ref="ac0e293d607499b223f4892fb290ab2d6" args="(const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a68c3afcddc0d4860aa2afb4bf715bb20"></a><!-- doxytag: member="Gio::File::enumerate_children" ref="a68c3afcddc0d4860aa2afb4bf715bb20" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5470cf1c97754a12169201665f1202"></a><!-- doxytag: member="Gio::File::enumerate_children_async" ref="a5b5470cf1c97754a12169201665f1202" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory.">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14" title="Finishes an async enumerate children operation.">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ead7237b7057d9b15cf5f3065988131"></a><!-- doxytag: member="Gio::File::enumerate_children_async" ref="a1ead7237b7057d9b15cf5f3065988131" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory.">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14" title="Finishes an async enumerate children operation.">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a617a2950448788e68df128c58e068a14"></a><!-- doxytag: member="Gio::File::enumerate_children_finish" ref="a617a2950448788e68df128c58e068a14" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async enumerate children operation. </p>
<p>See g_file_enumerate_children_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> or <code>0</code> if an error occurred. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8877115c870ea8f58b03d1d3c01a83e4"></a><!-- doxytag: member="Gio::File::equal" ref="a8877115c870ea8f58b03d1d3c01a83e4" args="(const Glib::RefPtr&lt; const File &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks equality of two given Files. </p>
<p>Note that two Files that differ can still refer to the same file on the filesystem due to various forms of filename aliasing.</p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file2</em>&#160;</td><td>The second <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>file1</em> and <em>file2</em> are equal. <code>false</code> if either is not a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb675267c7ea1c2a0d40e2e754d8333"></a><!-- doxytag: member="Gio::File::find_enclosing_mount" ref="a6eb675267c7ea1c2a0d40e2e754d8333" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If the FileIface for the file does not have a mount (e.g. possibly a remote share), an <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> wtih NOT_FOUND will be thrown and an empty RefPtr will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> where the file is located. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b881926b8d58c49d3baa1f51f2ee5d"></a><!-- doxytag: member="Gio::File::find_enclosing_mount" ref="a45b881926b8d58c49d3baa1f51f2ee5d" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If the FileIface for <em>file</em> does not have a mount (e.g. possibly a remote share), a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with NOT_FOUND and <code>0</code> will be returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> where the <em>file</em> is located or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a67458be57c5687e7469bc26e2594f4be"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_async" ref="a67458be57c5687e7469bc26e2594f4be" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="Gets a Mount for the File.">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433" title="Finishes an asynchronous find mount request.">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78c95d4fa47157f7757b686677dec018"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_async" ref="a78c95d4fa47157f7757b686677dec018" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="Gets a Mount for the File.">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433" title="Finishes an asynchronous find mount request.">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa12e6222d81179937cdc366f4d315433"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_finish" ref="aa12e6222d81179937cdc366f4d315433" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous find mount request. </p>
<p>See g_file_find_enclosing_mount_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac731bed45bb7fcfd411eb69c49d3b883"></a><!-- doxytag: member="Gio::File::get_basename" ref="ac731bed45bb7fcfd411eb69c49d3b883" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_basename </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If called for the top level of a system (such as the filesystem root or a uri like sftp://host/) it will return a single directory separator (and on Windows, possibly a drive letter).</p>
<p>The base name is a byte string (*not* UTF-8). It has no defined encoding or rules other than it may not contain zero bytes. If you want to use filenames in a user interface you should use the display name that you can get by requesting the FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>String containing the File's base name, or <code>0</code> if given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> is invalid. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a53c533d6bbeaaadd1b5592cf1e5ef93c"></a><!-- doxytag: member="Gio::File::get_child" ref="a53c533d6bbeaaadd1b5592cf1e5ef93c" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a child of <em>file</em> with basename equal to <em>name</em>. </p>
<p>Note that the file with that specific name might not exist, but you can still have a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> that points to it. You can use this for instance to create that file.</p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&#160;</td><td>String containing the child's basename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to a child specified by <em>name</em>. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a479cfd632af30b29e125f904f809ed71"></a><!-- doxytag: member="Gio::File::get_child_for_display_name" ref="a479cfd632af30b29e125f904f809ed71" args="(const Glib::ustring &amp;display_name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child_for_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>display_name</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF8 version of the name). </p>
<p>If this function fails, it returns <code>0</code> and <em>error</em> will be set. This is very useful when constructing a GFile for a new file and the user entered the filename in the user interface, for instance when you select a directory and type a filename in the file selector.</p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>display_name</em>&#160;</td><td>String to a possible child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to the specified child, or <code>0</code> if the display name couldn't be converted. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af39bbd5013b2dd675911df322e12ff94"></a><!-- doxytag: member="Gio::File::get_parent" ref="af39bbd5013b2dd675911df322e12ff94" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_parent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parent directory for the <em>file</em>. </p>
<p>If the <em>file</em> represents the root directory of the file system, then <code>0</code> will be returned.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> structure to the parent of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> if there is no parent. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aea4a78163e3085a35cbaacde9a3a7628"></a><!-- doxytag: member="Gio::File::get_parse_name" ref="aea4a78163e3085a35cbaacde9a3a7628" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::File::get_parse_name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parse name of the <em>file</em>. </p>
<p>A parse name is a UTF-8 string that describes the file such that one can get the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> back using g_file_parse_name().</p>
<p>This is generally used to show the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> as a nice full-pathname kind of string in a user interface, like in a location entry.</p>
<p>For local files with names that can safely be converted to UTF8 the pathname is used, otherwise the IRI is used (a form of URI that allows UTF8 characters unescaped).</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the File's parse name. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3edc7946b681b6db2cdcdad08d2b00"></a><!-- doxytag: member="Gio::File::get_path" ref="a7b3edc7946b681b6db2cdcdad08d2b00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_path </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, if one exists. </p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>String containing the File's path, or <code>0</code> if no such path exists. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a464248111fa2bc5df89c620354eb99bb"></a><!-- doxytag: member="Gio::File::get_relative_path" ref="a464248111fa2bc5df89c620354eb99bb" args="(const Glib::RefPtr&lt; const File &gt; &amp;descendant) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>descendant</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the path for <em>descendant</em> relative to <em>parent</em>. </p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>descendant</em>&#160;</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>String with the relative path from <em>descendant</em> to <em>parent</em>, or <code>0</code> if <em>descendant</em> doesn't have <em>parent</em> as prefix. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d1313e4a4eb5de034b693ec1cc9fba0"></a><!-- doxytag: member="Gio::File::get_uri" ref="a2d1313e4a4eb5de034b693ec1cc9fba0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the URI for the <em>file</em>. </p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the File's URI. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecec6962f955bd72ac5595be37db7a4"></a><!-- doxytag: member="Gio::File::get_uri_scheme" ref="aeecec6962f955bd72ac5595be37db7a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri_scheme </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>RFC 3986 decodes the scheme as: &lt;programlisting&gt; URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ] &lt;/programlisting&gt; Common schemes include "file", "http", "ftp", etc.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the URI scheme for the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5437bc648d8b73451e8bee0bc902cfc0"></a><!-- doxytag: member="Gio::File::gobj" ref="a5437bc648d8b73451e8bee0bc902cfc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">Glib::Interface</a>.</p>

</div>
</div>
<a class="anchor" id="a96552cfbaf2e5fa3659a1568db8cca91"></a><!-- doxytag: member="Gio::File::gobj" ref="a96552cfbaf2e5fa3659a1568db8cca91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">Glib::Interface</a>.</p>

</div>
</div>
<a class="anchor" id="a4c40ec88dfc4333f19e939d26a1e0332"></a><!-- doxytag: member="Gio::File::has_prefix" ref="a4c40ec88dfc4333f19e939d26a1e0332" args="(const Glib::RefPtr&lt; const File &gt; &amp;prefix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>prefix</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. </p>
<p>In other word, if the names of inital elements of <em>files</em> pathname match <em>prefix</em>. Only full pathname elements are matched, so a path like /foo is not considered a prefix of /foobar, only of /foo/bar.</p>
<p>This call does no i/o, as it works purely on names. As such it can sometimes return <code>false</code> even if <em>file</em> is inside a <em>prefix</em> (from a filesystem point of view), because the prefix of <em>file</em> is an alias of <em>prefix</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&#160;</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>files's</em> parent, grandparent, etc is <em>prefix</em>. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d71529e5b51b9ff73914eaf90be0f1"></a><!-- doxytag: member="Gio::File::has_uri_scheme" ref="a90d71529e5b51b9ff73914eaf90be0f1" args="(const std::string &amp;uri_scheme) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_uri_scheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>uri_scheme</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> has a given URI scheme. </p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri_scheme</em>&#160;</td><td>A string containing a URI scheme. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if File's backend supports the given URI scheme, <code>false</code> if URI scheme is <code>0</code>, not supported, or <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a0320bac72ecc9ced1f894f1af696856f"></a><!-- doxytag: member="Gio::File::hash" ref="a0320bac72ecc9ced1f894f1af696856f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Gio::File::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&#160;</td><td>gconstpointer to a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if <em>file</em> is not a valid <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, otherwise an integer that can be used as hash value for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. This function is intended for easily hashing a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to add to a HashTable or similar data structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3b910bc9f240d4ebd0efc70979f163"></a><!-- doxytag: member="Gio::File::is_native" ref="aaa3b910bc9f240d4ebd0efc70979f163" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::is_native </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if a file is native to the platform. </p>
<p>A native file s one expressed in the platform-native filename format, e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local, as it might be on a locally mounted remote filesystem.</p>
<p>On some systems non-native files may be available using the native filesystem via a userspace filesystem (FUSE), in these cases this call will return <code>false</code>, but g_file_get_path() will still return a native path.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if file is native. </dd></dl>

</div>
</div>
<a class="anchor" id="a40f3ce7cf905144bac7218f9988d2d35"></a><!-- doxytag: member="Gio::File::load_contents" ref="a40f3ce7cf905144bac7218f9988d2d35" args="(char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000018">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a77f7781b0ba65bc4e7e613b80b353fd7"></a><!-- doxytag: member="Gio::File::load_contents" ref="a77f7781b0ba65bc4e7e613b80b353fd7" args="(char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag_out</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag_out</em>&#160;</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7c826a417f88b405244c8dc39ae1ef"></a><!-- doxytag: member="Gio::File::load_contents" ref="ada7c826a417f88b405244c8dc39ae1ef" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A cancellable object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000017">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac53be228d732b34e062a2a57814cdf15"></a><!-- doxytag: member="Gio::File::load_contents" ref="ac53be228d732b34e062a2a57814cdf15" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag_out</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A cancellable object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag_out</em>&#160;</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6af7ec98d5543bce07b917b65d7276ce"></a><!-- doxytag: member="Gio::File::load_contents_async" ref="a6af7ec98d5543bce07b917b65d7276ce" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data.">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents.">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> provided to the <em>slot</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0e02ebffbaa13036e4636d2118f71a0"></a><!-- doxytag: member="Gio::File::load_contents_async" ref="ad0e02ebffbaa13036e4636d2118f71a0" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data.">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents.">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> provided to the <em>slot</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee93c7e24e8391615f9f263584fb02bd"></a><!-- doxytag: member="Gio::File::load_contents_finish" ref="aee93c7e24e8391615f9f263584fb02bd" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000019">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5fd15277ab90bcc57db088be04cac457"></a><!-- doxytag: member="Gio::File::load_contents_finish" ref="a5fd15277ab90bcc57db088be04cac457" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag_out</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag_out</em>&#160;</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="a362d71932c0ba8797a8c47b77df1b6d7"></a><!-- doxytag: member="Gio::File::load_partial_contents_async" ref="a362d71932c0ba8797a8c47b77df1b6d7" args="(const SlotReadMore &amp;slot_read_more, const SlotAsyncReady &amp;slot_async_ready)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotReadMore</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_async_ready</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async()...">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async()...">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot_read_more</em>&#160;</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_async_ready</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a><!-- doxytag: member="Gio::File::load_partial_contents_async" ref="a0e8d95fcdf7c2aa38f54e90a22d3ab6f" args="(const SlotReadMore &amp;slot_read_more, const SlotAsyncReady &amp;slot_async_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotReadMore</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot_async_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async()...">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async()...">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot_read_more</em>&#160;</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot_async_ready</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3a59c3831feeadea9bd0709617d2db9"></a><!-- doxytag: member="Gio::File::load_partial_contents_finish" ref="ae3a59c3831feeadea9bd0709617d2db9" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000020">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4b323508401d2e6fd2b3ad659f9bb5eb"></a><!-- doxytag: member="Gio::File::load_partial_contents_finish" ref="a4b323508401d2e6fd2b3ad659f9bb5eb" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag_out</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A location to place the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag_out</em>&#160;</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e9aa5f58a76a8562fd00a13434f554"></a><!-- doxytag: member="Gio::File::make_directory" ref="aa1e9aa5f58a76a8562fd00a13434f554" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory. </p>
<p>Note that this will only create a child directory of the immediate parent directory of the path or URI given by the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. To recursively create directories, see <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="Creates a directory and any parent directories that may not exist, similar to &#39;mkdir...">make_directory_with_parents()</a>. This function will fail if the parent directory does not exist, throwing an exception with IO_ERROR_NOT_FOUND. If the file system doesn't support creating directories, this function will fail, throwing an exception with IO_ERROR_NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abfa05e23e95e77cabac289ab4e294a58"></a><!-- doxytag: member="Gio::File::make_directory" ref="abfa05e23e95e77cabac289ab4e294a58" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a874a487551d49ca62b31a3e5cf32fee6"></a><!-- doxytag: member="Gio::File::make_directory_with_parents" ref="a874a487551d49ca62b31a3e5cf32fee6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory and any parent directories that may not exist, similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, throwing an exception with IO_ERROR_NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000016">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afb0b5b094339057b4b15952eb73e08d6"></a><!-- doxytag: member="Gio::File::make_directory_with_parents" ref="afb0b5b094339057b4b15952eb73e08d6" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, setting <em>error</em> to IO_ERROR_NOT_SUPPORTED.</p>
<p>For a local <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> the newly created directories will have the default (current) ownership and permissions of the current process.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if all directories have been successfully created, <code>false</code> otherwise.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000015">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8a9a3d060c2675ff9ac1c758f0b2c024"></a><!-- doxytag: member="Gio::File::make_symbolic_link" ref="a8a9a3d060c2675ff9ac1c758f0b2c024" args="(const std::string &amp;symlink_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>symlink_value</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a symbolic link. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>symlink_value</em>&#160;</td><td>A string with the value of the new symlink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2709318e1f24dfd0cd498d28f5e1b8fe"></a><!-- doxytag: member="Gio::File::make_symbolic_link" ref="a2709318e1f24dfd0cd498d28f5e1b8fe" args="(const std::string &amp;symlink_value, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>symlink_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a symbolic link. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>symlink_value</em>&#160;</td><td>A string with the value of the new symlink. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a50896969a9de87f810f0bf5e2d3335bd"></a><!-- doxytag: member="Gio::File::monitor" ref="a50896969a9de87f810f0bf5e2d3335bd" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000018">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a88aacee7bb6f6d968b4383311a9dd002"></a><!-- doxytag: member="Gio::File::monitor" ref="a88aacee7bb6f6d968b4383311a9dd002" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000017">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a12d36689c1024ff9fc8819f619910a92"></a><!-- doxytag: member="Gio::File::monitor_directory" ref="a12d36689c1024ff9fc8819f619910a92" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0fa22ffba0ff50779e49ff9d12344e6"></a><!-- doxytag: member="Gio::File::monitor_directory" ref="aa0fa22ffba0ff50779e49ff9d12344e6" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="aa410183ed3b4a745093383d038d271b9"></a><!-- doxytag: member="Gio::File::monitor_file" ref="aa410183ed3b4a745093383d038d271b9" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e14809f330ddd58e628c96921cd987"></a><!-- doxytag: member="Gio::File::monitor_file" ref="ab8e14809f330ddd58e628c96921cd987" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_MONITOR_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a20f8f18876102a5efaa0536bfa71d71c"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a20f8f18876102a5efaa0536bfa71d71c" args="(MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>

</div>
</div>
<a class="anchor" id="a2172cdcdb683630b719c521bf00b1eb4"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a2172cdcdb683630b719c521bf00b1eb4" args="(const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70fd22116d9c8682433c4bb8cbd764c1"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a70fd22116d9c8682433c4bb8cbd764c1" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mount_operation</em>&#160;</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a144aa2de6b696da90a6baffbe959d732"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a144aa2de6b696da90a6baffbe959d732" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mount_operation</em>&#160;</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd44b1b3467bcc474b345ff98b4aa6d"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume_finish" ref="aefd44b1b3467bcc474b345ff98b4aa6d" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::mount_enclosing_volume_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a mount operation started by g_file_mount_enclosing_volume(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if successful. If an error has occurred, this function will return <code>false</code> and set <em>error</em> appropriately if present. </dd></dl>

</div>
</div>
<a class="anchor" id="a8501fa88f4aaa8d52c001596960a4572"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a8501fa88f4aaa8d52c001596960a4572" args="(MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>

</div>
</div>
<a class="anchor" id="a049e06c3d95b49ad4bff1837ef6d8677"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a049e06c3d95b49ad4bff1837ef6d8677" args="(const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3c29682ef5a50de73dc2c3c3333301c"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="ac3c29682ef5a50de73dc2c3c3333301c" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mount_operation</em>&#160;</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40c88a403f5d01d722b5900545b6a4fe"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a40c88a403f5d01d722b5900545b6a4fe" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_MOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mount_operation</em>&#160;</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15d36a7969c55122b9f85a1690a46e8"></a><!-- doxytag: member="Gio::File::mount_mountable_finish" ref="ae15d36a7969c55122b9f85a1690a46e8" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::mount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a mount operation. </p>
<p>See g_file_mount_mountable() for details.</p>
<p>Finish an asynchronous mount operation that was started with g_file_mount_mountable(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aba1fab56c3a8bea0b7e4d7f7324c5320"></a><!-- doxytag: member="Gio::File::move" ref="aba1fab56c3a8bea0b7e4d7f7324c5320" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adfb2d8bfed1cb7af50e5e5795ebea732"></a><!-- doxytag: member="Gio::File::move" ref="adfb2d8bfed1cb7af50e5e5795ebea732" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a51c0d55880178c37dee578fdc723b0f2"></a><!-- doxytag: member="Gio::File::move" ref="a51c0d55880178c37dee578fdc723b0f2" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotFileProgress</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_COPY_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to move the file or directory source to the location specified by destination. </p>
<p>If native move operations are supported then this is used, otherwise a copy and delete fallback is used. The native implementation may support moving directories (for instance on moves inside the same filesystem), but the fallback code does not.</p>
<p>If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten.</p>
<p>If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback. If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If G_FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE may be thrown (if the native move operation isn't available). </p>

</div>
</div>
<a class="anchor" id="a0c0fd0ece2570b6704889df5ee43c283"></a><!-- doxytag: member="Gio::File::query_default_handler" ref="a0c0fd0ece2570b6704889df5ee43c283" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> that is registered as the default application to handle the file specified by the file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> if the handle was found, or an empty RefPtr if there were errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a753546465735b25633b003333b66d05c"></a><!-- doxytag: member="Gio::File::query_default_handler" ref="a753546465735b25633b003333b66d05c" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns: a <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> if the handle was found, <code>0</code> if there were errors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch...">AppInfo</a> if the handle was found, <code>0</code> if there were errors. When you are done with it, release it with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab4cfdbf4fedacd364e40a72c71ab341a"></a><!-- doxytag: member="Gio::File::query_exists" ref="ab4cfdbf4fedacd364e40a72c71ab341a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existance and then execute something based on the outcome of that, because the file might have been created or removed inbetween the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with g_file_create() which will either atomically create the file or throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS.</p>
<p>However, in many cases an existance check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file exists (and can be detected without error), false otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="ad8b0a75e0afdb5f6874ea5e304d55ea8"></a><!-- doxytag: member="Gio::File::query_exists" ref="ad8b0a75e0afdb5f6874ea5e304d55ea8" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existence and then execute something based on the outcome of that, because the file might have been created or removed in between the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with File::create() which will either atomically create the file or fail with a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with EXISTS.</p>
<p>However, in many cases an existence check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file exists (and can be detected without error), <code>false</code> otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="a691a9de5512b870bf358a9b0d292e146"></a><!-- doxytag: member="Gio::File::query_file_type" ref="a691a9de5512b870bf358a9b0d292e146" args="(FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to inspect the GFileType of a file. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags,:</em>&#160;</td><td>a set of FileQueryInfoFlags passed to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>. The FileType of the file, or FILE_TYPE_UNKNOWN if the file does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000014">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa27c5b271c8f7667ce117cfc6118262e"></a><!-- doxytag: member="Gio::File::query_file_type" ref="aa27c5b271c8f7667ce117cfc6118262e" args="(FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using g_file_query_info() and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags passed to g_file_query_info(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The FileType of the file and FILE_TYPE_UNKNOWN if the file does not exist</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000013">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac737012f8df97d90e2447d94d30b817d"></a><!-- doxytag: member="Gio::File::query_filesystem_info" ref="ac737012f8df97d90e2447d94d30b817d" args="(const std::string &amp;attributes=&quot;*&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a40486bc2f0c8758ef8a705b6b8b57e57"></a><!-- doxytag: member="Gio::File::query_filesystem_info" ref="a40486bc2f0c8758ef8a705b6b8b57e57" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4557ab16a50337f73d8a4649cf60fe70"></a><!-- doxytag: member="Gio::File::query_filesystem_info_async" ref="a4557ab16a50337f73d8a4649cf60fe70" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b" title="Finishes an asynchronous filesystem info query.">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39184ff9c9437259df4b9a9e2f283a0b"></a><!-- doxytag: member="Gio::File::query_filesystem_info_async" ref="a39184ff9c9437259df4b9a9e2f283a0b" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b" title="Finishes an asynchronous filesystem info query.">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd1159de8f782d918d8d460cddffee5b"></a><!-- doxytag: member="Gio::File::query_filesystem_info_finish" ref="afd1159de8f782d918d8d460cddffee5b" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous filesystem info query. </p>
<p>See g_file_query_filesystem_info_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4b9c07ade255b12e2b43c38c3aba90"></a><!-- doxytag: member="Gio::File::query_info" ref="a4e4b9c07ade255b12e2b43c38c3aba90" args="(const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attributes,:</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags,:</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adb25ffdbe571d33e89c9503fe9a20dcd"></a><!-- doxytag: member="Gio::File::query_info" ref="adb25ffdbe571d33e89c9503fe9a20dcd" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes,:</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags,:</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="afcad69d782a971802a8aa85125ac2c8c"></a><!-- doxytag: member="Gio::File::query_info_async" ref="afcad69d782a971802a8aa85125ac2c8c" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357" title="Finishes an asynchronous file info query.">query_info_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bd60e7864f8954c35e3b0891058e61c"></a><!-- doxytag: member="Gio::File::query_info_async" ref="a7bd60e7864f8954c35e3b0891058e61c" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357" title="Finishes an asynchronous file info query.">query_info_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&#160;</td><td>An attribute query string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd4ffc3630b41754c177658f2e745357"></a><!-- doxytag: member="Gio::File::query_info_finish" ref="afd4ffc3630b41754c177658f2e745357" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file info query. </p>
<p>See g_file_query_info_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae03d0652bcfbad2f47409b8f815bc4"></a><!-- doxytag: member="Gio::File::query_settable_attributes" ref="a1ae03d0652bcfbad2f47409b8f815bc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<p>Returns: a <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a543339b58cff6a7e5ddd840df0e69e"></a><!-- doxytag: member="Gio::File::query_settable_attributes" ref="a4a543339b58cff6a7e5ddd840df0e69e" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<p>Returns: a <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa0278acd7d09ed292359004defb742b0"></a><!-- doxytag: member="Gio::File::query_writable_namespaces" ref="aa0278acd7d09ed292359004defb742b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the writable namespaces. </dd></dl>

</div>
</div>
<a class="anchor" id="af5c7463b92e2887597486e7b195ca12f"></a><!-- doxytag: member="Gio::File::query_writable_namespaces" ref="af5c7463b92e2887597486e7b195ca12f" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the writable namespaces. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a><!-- doxytag: member="Gio::File::read" ref="a0395b3b0b8cec5dc1fd9953e52e5fbc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ef959c7ad7096846f26eb8b282e3c68"></a><!-- doxytag: member="Gio::File::read" ref="a3ef959c7ad7096846f26eb8b282e3c68" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab451a182a647408e697c9115e66f6194"></a><!-- doxytag: member="Gio::File::read_async" ref="ab451a182a647408e697c9115e66f6194" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="Opens a file for reading.">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921" title="Finishes an asynchronous file read operation started with g_file_read_async().">read_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2826eed0b1e76c3771f6ad5f5b993991"></a><!-- doxytag: member="Gio::File::read_async" ref="a2826eed0b1e76c3771f6ad5f5b993991" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="Opens a file for reading.">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921" title="Finishes an asynchronous file read operation started with g_file_read_async().">read_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64b10854ad1add1f888ecb19403eb921"></a><!-- doxytag: member="Gio::File::read_finish" ref="a64b10854ad1add1f888ecb19403eb921" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_read_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a14f34508dea523cbf889b7193e513ca4"></a><!-- doxytag: member="Gio::File::remove" ref="a14f34508dea523cbf889b7193e513ca4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aded971b0cf84801f6684ad4bd5dc66c5"></a><!-- doxytag: member="Gio::File::remove" ref="aded971b0cf84801f6684ad4bd5dc66c5" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a file. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acf55f9291659566f6fd36271801b013b"></a><!-- doxytag: member="Gio::File::replace" ref="acf55f9291659566f6fd36271801b013b" args="(const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em> = <code><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written.">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes.">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cf0360096504e40f799fde5cc8e9de"></a><!-- doxytag: member="Gio::File::replace" ref="ad7cf0360096504e40f799fde5cc8e9de" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em> = <code><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written.">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes.">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae51e51a2e3a45da4324230b4d5401a58"></a><!-- doxytag: member="Gio::File::replace_async" ref="ae51e51a2e3a45da4324230b4d5401a58" args="(const SlotAsyncReady &amp;slot, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em> = <code><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e" title="Finishes an asynchronous file replace operation started with g_file_replace_async()...">replace_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad777cdaa404a6a668ee8d520299687ce"></a><!-- doxytag: member="Gio::File::replace_async" ref="ad777cdaa404a6a668ee8d520299687ce" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em> = <code><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e" title="Finishes an asynchronous file replace operation started with g_file_replace_async()...">replace_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf33a17461ff4f70fed06818e364f617"></a><!-- doxytag: member="Gio::File::replace_contents" ref="aaf33a17461ff4f70fed06818e364f617" args="(const std::string &amp;contents, const std::string &amp;etag, std::string &amp;new_etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>The old entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_etag</em>&#160;</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23126b43cd262b63c0e458c3a4d0b65c"></a><!-- doxytag: member="Gio::File::replace_contents" ref="a23126b43cd262b63c0e458c3a4d0b65c" args="(const std::string &amp;contents, const std::string &amp;etag, std::string &amp;new_etag, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>The old entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_etag</em>&#160;</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7febf1f0f3b4b9efca9fae469082846"></a><!-- doxytag: member="Gio::File::replace_contents" ref="ae7febf1f0f3b4b9efca9fae469082846" args="(const char *contents, gsize length, const std::string &amp;etag, std::string &amp;new_etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>The old entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_etag</em>&#160;</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af10deca1d5c5d1f650d3b182624330dc"></a><!-- doxytag: member="Gio::File::replace_contents" ref="af10deca1d5c5d1f650d3b182624330dc" args="(const char *contents, gsize length, const std::string &amp;etag, std::string &amp;new_etag, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>The old entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_etag</em>&#160;</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fc86aab90620881899a701c2b2775cb"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a6fc86aab90620881899a701c2b2775cb" args="(const SlotAsyncReady &amp;slot, const std::string &amp;contents, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em>. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot,:</em>&#160;</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>String of contents to replace the file with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>a new entity tag for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a380d6ce6362fc05e0e18ff1b881ceac7"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a380d6ce6362fc05e0e18ff1b881ceac7" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;contents, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot,:</em>&#160;</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>String of contents to replace the file with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>a new entity tag for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a1c445e84124e16294974a73f2f1bbb"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a9a1c445e84124e16294974a73f2f1bbb" args="(const SlotAsyncReady &amp;slot, const char *contents, gsize length, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot,:</em>&#160;</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>String of contents to replace the file with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>a new entity tag for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad33b24a7942429157f47379f4353378c"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="ad33b24a7942429157f47379f4353378c" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const char *contents, gsize length, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_CREATE_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot,:</em>&#160;</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contents</em>&#160;</td><td>String of contents to replace the file with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>etag</em>&#160;</td><td>a new entity tag for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make_backup</em>&#160;</td><td>true if a backup should be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0372ffd3f535f39b7e48c0483e4c1f4"></a><!-- doxytag: member="Gio::File::replace_contents_finish" ref="af0372ffd3f535f39b7e48c0483e4c1f4" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length...">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af019065c5503c7f47d778c20f8e5de32"></a><!-- doxytag: member="Gio::File::replace_contents_finish" ref="af019065c5503c7f47d778c20f8e5de32" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;etag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>etag</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length...">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_etag</em>&#160;</td><td>A location of a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28557d592f2c53df618728cf865e65e"></a><!-- doxytag: member="Gio::File::replace_finish" ref="ab28557d592f2c53df618728cf865e65e" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e286d421c7236df39881f8ce0a4e03"></a><!-- doxytag: member="Gio::File::resolve_relative_path" ref="ac5e286d421c7236df39881f8ce0a4e03" args="(const std::string &amp;relative_path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::resolve_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>relative_path</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resolves a relative path for <em>file</em> to an absolute path. </p>
<p>This call does no blocking i/o. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relative_path</em>&#160;</td><td>A given relative path string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to the resolved path. <code>0</code> if <em>relative_path</em> is <code>0</code> or if <em>file</em> is invalid. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a09f574259052186e1b516bdcbe696710"></a><!-- doxytag: member="Gio::File::set_attribute_byte_string" ref="a09f574259052186e1b516bdcbe696710" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4373b8694c346a6908195f1f2644f3"></a><!-- doxytag: member="Gio::File::set_attribute_byte_string" ref="a4f4373b8694c346a6908195f1f2644f3" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a707084a3c0a963548a21d17d0ec0b5"></a><!-- doxytag: member="Gio::File::set_attribute_int32" ref="a4a707084a3c0a963548a21d17d0ec0b5" args="(const std::string &amp;attribute, gint32 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A gint32 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0290ecba7b06ccf7736e2292708667e"></a><!-- doxytag: member="Gio::File::set_attribute_int32" ref="ab0290ecba7b06ccf7736e2292708667e" args="(const std::string &amp;attribute, gint32 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A gint32 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4477b0063110951b26c855696ec34802"></a><!-- doxytag: member="Gio::File::set_attribute_int64" ref="a4477b0063110951b26c855696ec34802" args="(const std::string &amp;attribute, gint64 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint64 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a><!-- doxytag: member="Gio::File::set_attribute_int64" ref="a111d73a2d003e5a5a4c5f86c7c3d2fb7" args="(const std::string &amp;attribute, gint64 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint64 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a75fa7e1a44e97a910d232f2b4ab4bfdd"></a><!-- doxytag: member="Gio::File::set_attribute_string" ref="a75fa7e1a44e97a910d232f2b4ab4bfdd" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A string containing the attribute's value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ce5f43fd5e2836ac1989a54d3233ff6"></a><!-- doxytag: member="Gio::File::set_attribute_string" ref="a5ce5f43fd5e2836ac1989a54d3233ff6" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A string containing the attribute's value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f769f140143f2e96a7587a10b6792a9"></a><!-- doxytag: member="Gio::File::set_attribute_uint32" ref="a7f769f140143f2e96a7587a10b6792a9" args="(const std::string &amp;attribute, guint32 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint32 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae53b0f4d2214e050a290c8e35cac0f27"></a><!-- doxytag: member="Gio::File::set_attribute_uint32" ref="ae53b0f4d2214e050a290c8e35cac0f27" args="(const std::string &amp;attribute, guint32 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint32 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aa77b3580df88cfd3d7231af78155c7"></a><!-- doxytag: member="Gio::File::set_attribute_uint64" ref="a4aa77b3580df88cfd3d7231af78155c7" args="(const std::string &amp;attribute, guint64 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint64 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a48638081fd7af772a39af59a558b17f7"></a><!-- doxytag: member="Gio::File::set_attribute_uint64" ref="a48638081fd7af772a39af59a558b17f7" args="(const std::string &amp;attribute, guint64 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&#160;</td><td>A string containing the attribute's name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&#160;</td><td>A guint64 containing the attribute's new value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a61317a1980318537aa8ada7bb8cc2390"></a><!-- doxytag: member="Gio::File::set_attributes_async" ref="a61317a1980318537aa8ada7bb8cc2390" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const SlotAsyncReady &amp;slot, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&#160;</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14165fba9bf7d91448c3207407ae50c2"></a><!-- doxytag: member="Gio::File::set_attributes_async" ref="a14165fba9bf7d91448c3207407ae50c2" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&#160;</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd45aed7b975b6e204e67927de2817a"></a><!-- doxytag: member="Gio::File::set_attributes_finish" ref="aefd45aed7b975b6e204e67927de2817a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, const Glib::RefPtr&lt; FileInfo &gt; &amp;info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>info</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9f6975ffef28f0d7145601a99de0903"></a><!-- doxytag: member="Gio::File::set_attributes_from_info" ref="ae9f6975ffef28f0d7145601a99de0903" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&#160;</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a69d9e40a85b96809abc5189b34e8d9b7"></a><!-- doxytag: member="Gio::File::set_attributes_from_info" ref="a69d9e40a85b96809abc5189b34e8d9b7" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>FILE_QUERY_INFO_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&#160;</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain...">FileInfo</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2aa80b2d0ecdd22f0222c8ce42d177"></a><!-- doxytag: member="Gio::File::set_display_name" ref="a8c2aa80b2d0ecdd22f0222c8ce42d177" args="(const Glib::ustring &amp;display_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>display_name</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renames the file to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the file is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>.</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>display_name</em>&#160;</td><td>A string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Glib::File specifying what the file was renamed to, or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd75810d7c9ebafac398288f5afc018"></a><!-- doxytag: member="Gio::File::set_display_name" ref="a3dd75810d7c9ebafac398288f5afc018" args="(const Glib::ustring &amp;display_name, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renames <em>file</em> to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the <em>file</em> is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to g_file_set_display_name().</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>display_name</em>&#160;</td><td>A string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> specifying what <em>file</em> was renamed to, or <code>0</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a74d219d321dca3d438f876256dee82d2"></a><!-- doxytag: member="Gio::File::set_display_name_async" ref="a74d219d321dca3d438f876256dee82d2" args="(const Glib::ustring &amp;display_name, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a" title="Finishes setting a display name started with g_file_set_display_name_async().">set_display_name_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>display_name</em>&#160;</td><td>A string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ac539d7758b9c0de809f8c83e0bba79"></a><!-- doxytag: member="Gio::File::set_display_name_async" ref="a0ac539d7758b9c0de809f8c83e0bba79" args="(const Glib::ustring &amp;display_name, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a" title="Finishes setting a display name started with g_file_set_display_name_async().">set_display_name_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>display_name</em>&#160;</td><td>A string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a101b555723233014c0185dd505303f0a"></a><!-- doxytag: member="Gio::File::set_display_name_finish" ref="a101b555723233014c0185dd505303f0a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes setting a display name started with g_file_set_display_name_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1925736f9af338eaf9942468b4d6d65e"></a><!-- doxytag: member="Gio::File::trash" ref="a1925736f9af338eaf9942468b4d6d65e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends the file to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all filesystems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acae5ecd962e832cf8d538877f4118da8"></a><!-- doxytag: member="Gio::File::trash" ref="acae5ecd962e832cf8d538877f4118da8" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends <em>file</em> to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all file systems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_SUPPORTED.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a95f3e87e198493f4332a08aa79f6ebd3"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="a95f3e87e198493f4332a08aa79f6ebd3" args="(MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c8e9ef0e5d83a271c8307b18e779d8"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="ab6c8e9ef0e5d83a271c8307b18e779d8" args="(const SlotAsyncReady &amp;slot, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b687c8f19411e955bb069c469be92b4"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="a5b687c8f19411e955bb069c469be92b4" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"> <em>flags</em> = <code>MOUNT_UNMOUNT_NONE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&#160;</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51458cf04ad25e4a784a3ebcb906155d"></a><!-- doxytag: member="Gio::File::unmount_mountable_finish" ref="a51458cf04ad25e4a784a3ebcb906155d" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::unmount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an unmount operation, see g_file_unmount_mountable() for details. </p>
<p>Finish an asynchronous unmount operation that was started with g_file_unmount_mountable(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a69670cdc7cf63783d6f9370dcbd7cc3d"></a><!-- doxytag: member="Gio::File::wrap" ref="a69670cdc7cf63783d6f9370dcbd7cc3d" args="(GFile *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GFile *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>giomm/file.h</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Mar 26 11:48:23 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
