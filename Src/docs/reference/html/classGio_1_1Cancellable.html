<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::Cancellable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>
  </div>
</div>
<div class="contents">
<h1>Gio::Cancellable Class Reference</h1><!-- doxytag: class="Gio::Cancellable" --><!-- doxytag: inherits="Glib::Object" -->
<p>Allows actions to be cancelled. <a href="#_details">More...</a></p>

<p>Inherits <a class="el" href="classGlib_1_1Object.html">Glib::Object</a>.</p>
<div class="dynheader">
Collaboration diagram for Gio::Cancellable:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1Cancellable__coll__graph.png" border="0" usemap="#Gio_1_1Cancellable_coll__map" alt="Collaboration graph"/></div>
<map name="Gio_1_1Cancellable_coll__map" id="Gio_1_1Cancellable_coll__map">
<area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="20,160,111,189"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,125,112"/><area shape="rect" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="12,5,119,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Cancellable-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">SlotCancelledCallback</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a97c7c4d728865129bc6f0cd3f4ecfce7">~Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ae19ec1e85fd9cd7893914d4d7c20120d">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ae19ec1e85fd9cd7893914d4d7c20120d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a668176a01f7ad3cc13c7448378f37b41">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a668176a01f7ad3cc13c7448378f37b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a379e6394bad0fff1eb11e1a160f30235">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a379e6394bad0fff1eb11e1a160f30235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a47ce5f2f16541b7ae18bc5114b366d8c">is_cancelled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cancellable job has been cancelled. <a href="#a47ce5f2f16541b7ae18bc5114b366d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a80df23049daf594fda884f2932ce3b95">get_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file descriptor for a cancellable job. <a href="#a80df23049daf594fda884f2932ce3b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a86adae0645cec20d09d1a2903fe46cc0">cancel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set <em>cancellable</em> to cancelled, and will emit the Cancellable::cancelled signal. <a href="#a86adae0645cec20d09d1a2903fe46cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad893da5aebfb4baf34ecdbdad7a3608b">push_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes <em>cancellable</em> onto the cancellable stack. <a href="#ad893da5aebfb4baf34ecdbdad7a3608b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a93b5a39447d2b4eb9fb56748cb687fc8">pop_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). <a href="#a93b5a39447d2b4eb9fb56748cb687fc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a2285370aea5d98141e742e73743b9c3e">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <em>cancellable</em> to its uncancelled state. <a href="#a2285370aea5d98141e742e73743b9c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad43ddee749e87373a2dd035f8eb989e6">connect</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotCancelledCallback</a>&amp; callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to connect to the Cancellable::cancelled signal. <a href="#ad43ddee749e87373a2dd035f8eb989e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aa9277479b4bf0b80090e780e26215713">disconnect</a> (gulong handler_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a handler from an cancellable instance similar to Glib::signal_handler_disconnect() but ensures that once this function returns the handler will not run anymore in any thread. <a href="#aa9277479b4bf0b80090e780e26215713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">signal_cancelled</a> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a8d59324b4c253f8c890901cd934203a7">create</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aaf923ce91ddf21fc03bf2902e12cd4e1">get_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the top cancellable from the stack. <a href="#aaf923ce91ddf21fc03bf2902e12cd4e1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aab7733b6e915e4ebe280fbb669b6af2a">Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aff017e200824997b9c26d82f147e078f">on_cancelled</a> ()</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ac45875da91c9c870a0f154a8249047c0">wrap</a> (GCancellable* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#ac45875da91c9c870a0f154a8249047c0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Allows actions to be cancelled. </p>
<p><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> is a thread-safe operation cancellation stack used throughout GIO to allow for cancellation of synchronous and asynchronous operations.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000019">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a18d005aeefd0da4daab594f4c44ce9cd"></a><!-- doxytag: member="Gio::Cancellable::SlotCancelledCallback" ref="a18d005aeefd0da4daab594f4c44ce9cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;void&gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Gio::Cancellable::SlotCancelledCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97c7c4d728865129bc6f0cd3f4ecfce7"></a><!-- doxytag: member="Gio::Cancellable::~Cancellable" ref="a97c7c4d728865129bc6f0cd3f4ecfce7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::Cancellable::~Cancellable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab7733b6e915e4ebe280fbb669b6af2a"></a><!-- doxytag: member="Gio::Cancellable::Cancellable" ref="aab7733b6e915e4ebe280fbb669b6af2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Cancellable::Cancellable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a86adae0645cec20d09d1a2903fe46cc0"></a><!-- doxytag: member="Gio::Cancellable::cancel" ref="a86adae0645cec20d09d1a2903fe46cc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::cancel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will set <em>cancellable</em> to cancelled, and will emit the Cancellable::cancelled signal. </p>
<p>(However, see the warning about race conditions in the documentation for that signal if you are planning to connect to it.)</p>
<p>This function is thread-safe. In other words, you can safely call it from a thread other than the one running the operation that was passed the <em>cancellable</em>.</p>
<p>The convention within gio is that cancelling an asynchronous operation causes it to complete asynchronously. That is, if you cancel the operation from the same thread in which it is running, then the operation's AsyncReadyCallback will not be invoked until the application returns to the main loop. </p>

</div>
</div>
<a class="anchor" id="ad43ddee749e87373a2dd035f8eb989e6"></a><!-- doxytag: member="Gio::Cancellable::connect" ref="ad43ddee749e87373a2dd035f8eb989e6" args="(const SlotCancelledCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gulong Gio::Cancellable::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotCancelledCallback</a> &amp;&#160;</td>
          <td class="paramname"> <em>callback</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience function to connect to the Cancellable::cancelled signal. </p>
<p>Also handles the race condition that may happen if the cancellable is cancelled right before connecting.</p>
<p><em>callback</em> is called at most once, either directly at the time of the connect if <em>cancellable</em> is already cancelled, or when <em>cancellable</em> is cancelled in some thread.</p>
<p><em>data_destroy_func</em> will be called when the handler is disconnected, or immediately if the cancellable is already cancelled.</p>
<p>See Cancellable::cancelled for details on how to use this. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&#160;</td><td>The Callback to connect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&#160;</td><td>Data to pass to <em>callback</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_destroy_func</em>&#160;</td><td>Free function for <em>data</em> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the signal handler or 0 if <em>cancellable</em> has already been cancelled.</dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000007">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8d59324b4c253f8c890901cd934203a7"></a><!-- doxytag: member="Gio::Cancellable::create" ref="a8d59324b4c253f8c890901cd934203a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; Gio::Cancellable::create </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9277479b4bf0b80090e780e26215713"></a><!-- doxytag: member="Gio::Cancellable::disconnect" ref="aa9277479b4bf0b80090e780e26215713" args="(gulong handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::disconnect </td>
          <td>(</td>
          <td class="paramtype">gulong&#160;</td>
          <td class="paramname"> <em>handler_id</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a handler from an cancellable instance similar to Glib::signal_handler_disconnect() but ensures that once this function returns the handler will not run anymore in any thread. </p>
<p>This avoids a race condition where a thread cancels at the same time as the cancellable operation is finished and the signal handler is removed. See Cancellable::cancelled for details on how to use this.</p>
<p>If <em>cancellable</em> is <code>0</code> or <em>handler_id</em> is 0 this function does nothing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000008">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler_id</em>&#160;</td><td>Handler id of the handler to be disconnected, or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf923ce91ddf21fc03bf2902e12cd4e1"></a><!-- doxytag: member="Gio::Cancellable::get_current" ref="aaf923ce91ddf21fc03bf2902e12cd4e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; Gio::Cancellable::get_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the top cancellable from the stack. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> from the top of the stack, or <code>0</code> if the stack is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a80df23049daf594fda884f2932ce3b95"></a><!-- doxytag: member="Gio::Cancellable::get_fd" ref="a80df23049daf594fda884f2932ce3b95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Cancellable::get_fd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the file descriptor for a cancellable job. </p>
<p>This can be used to implement cancellable operations on Unix systems. The returned fd will turn readable when <em>cancellable</em> is cancelled.</p>
<p>You are not supposed to read from the fd yourself, just check for readable status. Reading to unset the readable status is done with g_cancellable_reset().</p>
<p>See also g_cancellable_make_pollfd(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid file descriptor. -1 if the file descriptor is not supported, or on errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a668176a01f7ad3cc13c7448378f37b41"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="a668176a01f7ad3cc13c7448378f37b41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GCancellable* Gio::Cancellable::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae19ec1e85fd9cd7893914d4d7c20120d"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="ae19ec1e85fd9cd7893914d4d7c20120d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* Gio::Cancellable::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a379e6394bad0fff1eb11e1a160f30235"></a><!-- doxytag: member="Gio::Cancellable::gobj_copy" ref="a379e6394bad0fff1eb11e1a160f30235" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* Gio::Cancellable::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a47ce5f2f16541b7ae18bc5114b366d8c"></a><!-- doxytag: member="Gio::Cancellable::is_cancelled" ref="a47ce5f2f16541b7ae18bc5114b366d8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Cancellable::is_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a cancellable job has been cancelled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>cancellable</em> is cancelled, <code>false</code> if called with <code>0</code> or if item is not cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="aff017e200824997b9c26d82f147e078f"></a><!-- doxytag: member="Gio::Cancellable::on_cancelled" ref="aff017e200824997b9c26d82f147e078f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gio::Cancellable::on_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a93b5a39447d2b4eb9fb56748cb687fc8"></a><!-- doxytag: member="Gio::Cancellable::pop_current" ref="a93b5a39447d2b4eb9fb56748cb687fc8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::pop_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). </p>

</div>
</div>
<a class="anchor" id="ad893da5aebfb4baf34ecdbdad7a3608b"></a><!-- doxytag: member="Gio::Cancellable::push_current" ref="ad893da5aebfb4baf34ecdbdad7a3608b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::push_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pushes <em>cancellable</em> onto the cancellable stack. </p>
<p>The current cancllable can then be recieved using g_cancellable_get_current().</p>
<p>This is useful when implementing cancellable operations in code that does not allow you to pass down the cancellable object.</p>
<p>This is typically called automatically by e.g. <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> operations, so you rarely have to call this yourself. </p>

</div>
</div>
<a class="anchor" id="a2285370aea5d98141e742e73743b9c3e"></a><!-- doxytag: member="Gio::Cancellable::reset" ref="a2285370aea5d98141e742e73743b9c3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets <em>cancellable</em> to its uncancelled state. </p>

</div>
</div>
<a class="anchor" id="a5a34d4782ccec014684c4eb6c20cf0a6"></a><!-- doxytag: member="Gio::Cancellable::signal_cancelled" ref="a5a34d4782ccec014684c4eb6c20cf0a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt; Gio::Cancellable::signal_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Prototype:</b></dt><dd><code>void on_my_cancelled()</code> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac45875da91c9c870a0f154a8249047c0"></a><!-- doxytag: member="Gio::Cancellable::wrap" ref="ac45875da91c9c870a0f154a8249047c0" args="(GCancellable *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GCancellable *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>giomm/cancellable.h</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Mar 26 11:48:23 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
