<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::InputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1InputStream.html">InputStream</a>
  </div>
</div>
<div class="contents">
<h1>Gio::InputStream Class Reference<br/>
<small>
[<a class="el" href="group__Streams.html">Stream Classes</a>]</small>
</h1><!-- doxytag: class="Gio::InputStream" --><!-- doxytag: inherits="Glib::Object" -->
<p>Base class for implementing streaming input. <a href="#_details">More...</a></p>

<p>Inherits <a class="el" href="classGlib_1_1Object.html">Glib::Object</a>.</p>

<p>Inherited by <a class="el" href="classGio_1_1FileInputStream.html">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html">Gio::UnixInputStream</a>.</p>
<div class="dynheader">
Collaboration diagram for Gio::InputStream:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1InputStream__coll__graph.png" border="0" usemap="#Gio_1_1InputStream_coll__map" alt="Collaboration graph"/></div>
<map name="Gio_1_1InputStream_coll__map" id="Gio_1_1InputStream_coll__map">
<area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="20,160,111,189"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,125,112"/><area shape="rect" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="12,5,119,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1InputStream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#afff624e3125add13c88e8a99907ba903">~InputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a2ed1120b3d03a12086e7f0ed3946aba1">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a2ed1120b3d03a12086e7f0ed3946aba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1b0ef82ab81b3ded607584c7029fe1e9">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a1b0ef82ab81b3ded607584c7029fe1e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a28a9394b07e9183c0c79798ea344c65c">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a28a9394b07e9183c0c79798ea344c65c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2">read</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a49a1f4219f96c7fafdcf1ed12eb443e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a42ab2486116d40f6ef828277befb508a">read</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a42ab2486116d40f6ef828277befb508a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1dc8a2babf32f93a0a5dccc0c39e0959">read_all</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, gsize&amp; bytes_read, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a1dc8a2babf32f93a0a5dccc0c39e0959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a6da0fc57d1a5df7107370c67e84aa496">read_all</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, gsize&amp; bytes_read)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a6da0fc57d1a5df7107370c67e84aa496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a17ea65f35c15043156db90af831a44a3">skip</a> (gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream. <a href="#a17ea65f35c15043156db90af831a44a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1ea9146d612c666168886734b79a5d65">skip</a> (gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream. <a href="#a1ea9146d612c666168886734b79a5d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1b76b2503e607475f63731a886456e09">close</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream, releasing resources related to it. <a href="#a1b76b2503e607475f63731a886456e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream, releasing resources related to it. <a href="#a7a3202cf7014bcfb2c0a7f301448ae50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a5b7762ee3f3c571fbc59a0c9af6e879e">read_async</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a5b7762ee3f3c571fbc59a0c9af6e879e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a05bea76fa9ac3c098a167d2b377e36a6">read_async</a> (void* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a05bea76fa9ac3c098a167d2b377e36a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous stream read operation. <a href="#ac089ab220e671ba0af2dd97f2405c0c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1bf7a4a30005813b0a46e069215907a2">skip_async</a> (gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a1bf7a4a30005813b0a46e069215907a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a111e86dad4548394edcff16d7735d2d5">skip_async</a> (gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01173.html#ga81511cd7112567fa262b05bb22e69874">count</a>, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a111e86dad4548394edcff16d7735d2d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03">skip_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a stream skip operation. <a href="#a1522468bd203ab3082ab54e9eba68b03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#af66159778ee2d577e9df52063ced53bf">close_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it. <a href="#af66159778ee2d577e9df52063ced53bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ab5160982124f34ed6e475776acd126d2">close_async</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it. <a href="#ab5160982124f34ed6e475776acd126d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7">close_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes closing a stream asynchronously, started from g_input_stream_close_async(). <a href="#ae5a0d2c3ccf27661e374f151117a8fb7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#aec580b0fc1e0807d7ccba6cbb7e302db">wrap</a> (GInputStream* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#aec580b0fc1e0807d7ccba6cbb7e302db"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for implementing streaming input. </p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000036">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afff624e3125add13c88e8a99907ba903"></a><!-- doxytag: member="Gio::InputStream::~InputStream" ref="afff624e3125add13c88e8a99907ba903" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::InputStream::~InputStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7a3202cf7014bcfb2c0a7f301448ae50"></a><!-- doxytag: member="Gio::InputStream::close" ref="a7a3202cf7014bcfb2c0a7f301448ae50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the stream, releasing resources related to it. </p>
<p>Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.</p>
<p>Streams will be automatically closed when the last reference is dropped, but you might want to call this make sure resources are released as early as possible.</p>
<p>Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.</p>
<p>On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b76b2503e607475f63731a886456e09"></a><!-- doxytag: member="Gio::InputStream::close" ref="a1b76b2503e607475f63731a886456e09" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::close </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the stream, releasing resources related to it. </p>
<p>Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.</p>
<p>Streams will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.</p>
<p>On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. Cancelling a close will still leave the stream closed, but some streams can use a faster close that doesn't block to e.g. check errors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5160982124f34ed6e475776acd126d2"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="ab5160982124f34ed6e475776acd126d2" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::close_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests an asynchronous closes of the stream, releasing resources related to it. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async()...">close_finish()</a> to get the result of the operation.</p>
<p>For behaviour details see <a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af66159778ee2d577e9df52063ced53bf"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="af66159778ee2d577e9df52063ced53bf" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::close_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests an asynchronous closes of the stream, releasing resources related to it. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async()...">close_finish()</a> to get the result of the operation.</p>
<p>For behaviour details see <a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5a0d2c3ccf27661e374f151117a8fb7"></a><!-- doxytag: member="Gio::InputStream::close_finish" ref="ae5a0d2c3ccf27661e374f151117a8fb7" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean Gio::InputStream::close_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes closing a stream asynchronously, started from g_input_stream_close_async(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the stream was closed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b0ef82ab81b3ded607584c7029fe1e9"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="a1b0ef82ab81b3ded607584c7029fe1e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GInputStream* Gio::InputStream::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#ad6b09565f69b4c1cf1f0ca05ee53709e">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#a5d8f01998854eac791a3089acef051c0">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#ab1afea7b758100ca02a6aa5b89d57662">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#ac8fbd2cc879bfab4854d952b27ce271c">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#af9ea44af840fc0d29d460498c8ce7d0e">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#adc7b87c43606f90378a521df99220971">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed1120b3d03a12086e7f0ed3946aba1"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="a2ed1120b3d03a12086e7f0ed3946aba1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* Gio::InputStream::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#a5411e06810e06ad339d7a21257772219">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#a6db43589745dcd172f4ca4082bc5d914">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#a076380153e01599446bd991e0985db69">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#aa0b863b654d38a9e10f7d7d49b82c5ea">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a28a9394b07e9183c0c79798ea344c65c"></a><!-- doxytag: member="Gio::InputStream::gobj_copy" ref="a28a9394b07e9183c0c79798ea344c65c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* Gio::InputStream::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#a47dc5f78b1faed25cdaaafe42b526d6d">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#a8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#aa35ad981b6f18b1e5ece395970c5991b">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#a55ef3320e423245cc69066c90785328e">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#af63cbdce2036e383cb7e77a7df83651c">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#a5f05de3f98b2dd8e7f0f2c5038fbc69f">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a42ab2486116d40f6ef828277befb508a"></a><!-- doxytag: member="Gio::InputStream::read" ref="a42ab2486116d40f6ef828277befb508a" args="(void *buffer, gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>On error -1 is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a49a1f4219f96c7fafdcf1ed12eb443e2"></a><!-- doxytag: member="Gio::InputStream::read" ref="a49a1f4219f96c7fafdcf1ed12eb443e2" args="(void *buffer, gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6da0fc57d1a5df7107370c67e84aa496"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="a6da0fc57d1a5df7107370c67e84aa496" args="(void *buffer, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::read_all </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>This function is similar to <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, except it tries to read as many bytes as requested, only stopping on an error or end of stream.</p>
<p>On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em> .</p>
<p>If there is an error during the operation <code>false</code> is returned and a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> is thrown to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&#160;</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc8a2babf32f93a0a5dccc0c39e0959"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="a1dc8a2babf32f93a0a5dccc0c39e0959" args="(void *buffer, gsize count, gsize &amp;bytes_read, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::read_all </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>This function is similar to g_input_stream_read(), except it tries to read as many bytes as requested, only stopping on an error or end of stream.</p>
<p>On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em>.</p>
<p>If there is an error during the operation <code>false</code> is returned and <em>error</em> is set to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occurred. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&#160;</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a05bea76fa9ac3c098a167d2b377e36a6"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="a05bea76fa9ac3c098a167d2b377e36a6" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::read_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b7762ee3f3c571fbc59a0c9af6e879e"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="a5b7762ee3f3c571fbc59a0c9af6e879e" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::read_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac089ab220e671ba0af2dd97f2405c0c5"></a><!-- doxytag: member="Gio::InputStream::read_finish" ref="ac089ab220e671ba0af2dd97f2405c0c5" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous stream read operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read in, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ea9146d612c666168886734b79a5d65"></a><!-- doxytag: member="Gio::InputStream::skip" ref="a1ea9146d612c666168886734b79a5d65" args="(gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to skip <em>count</em> bytes from the stream. </p>
<p>Will block during the operation.</p>
<p>This is identical to <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.</p>
<p>This function is optional for inherited classes, as the default implementation emulates it using read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a17ea65f35c15043156db90af831a44a3"></a><!-- doxytag: member="Gio::InputStream::skip" ref="a17ea65f35c15043156db90af831a44a3" args="(gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to skip <em>count</em> bytes from the stream. </p>
<p>Will block during the operation.</p>
<p>This is identical to g_input_stream_read(), from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.</p>
<p>This function is optional for inherited classes, as the default implementation emulates it using read.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a111e86dad4548394edcff16d7735d2d5"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="a111e86dad4548394edcff16d7735d2d5" args="(gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::skip_async </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bf7a4a30005813b0a46e069215907a2"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="a1bf7a4a30005813b0a46e069215907a2" args="(gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::skip_async </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&#160;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&#160;</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1522468bd203ab3082ab54e9eba68b03"></a><!-- doxytag: member="Gio::InputStream::skip_finish" ref="a1522468bd203ab3082ab54e9eba68b03" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a stream skip operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the bytes skipped, or -1 on error. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aec580b0fc1e0807d7ccba6cbb7e302db"></a><!-- doxytag: member="Gio::InputStream::wrap" ref="aec580b0fc1e0807d7ccba6cbb7e302db" args="(GInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GInputStream *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>giomm/inputstream.h</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Mar 26 11:48:24 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
