<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::AsyncResult Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>
  </div>
</div>
<div class="contents">
<h1>Gio::AsyncResult Class Reference</h1><!-- doxytag: class="Gio::AsyncResult" --><!-- doxytag: inherits="Glib::Interface" -->
<p>Provides a base class for implementing asynchronous function results. <a href="#_details">More...</a></p>

<p>Inherits <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a>.</p>
<div class="dynheader">
Collaboration diagram for Gio::AsyncResult:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1AsyncResult__coll__graph.png" border="0" usemap="#Gio_1_1AsyncResult_coll__map" alt="Collaboration graph"/></div>
<map name="Gio_1_1AsyncResult_coll__map" id="Gio_1_1AsyncResult_coll__map">
<area shape="rect" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="15,160,119,189"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="7,83,127,112"/><area shape="rect" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="13,5,120,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1AsyncResult-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a9dae859748e44341d2c14a2777ca4fee">~AsyncResult</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GAsyncResult*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#ad7ebc2ac808bd8eff4f4cd4f94c1c70a">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ad7ebc2ac808bd8eff4f4cd4f94c1c70a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GAsyncResult*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a134862761e05a548d2817505480140be">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a134862761e05a548d2817505480140be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a3b89bee3ed3ff402ff58f836e1d2398e">get_source_object</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. <a href="#a3b89bee3ed3ff402ff58f836e1d2398e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#adcb9d80c42cf04098629a8153d51b32c">get_source_object</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. <a href="#adcb9d80c42cf04098629a8153d51b32c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a97f3fe7208156d2c981f42e97ec4ce20">get_source_object_vfunc</a> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a27a2e7a0488f8a3db08fa9547c791c6a">add_interface</a> (GType gtype_implementer)</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">Gio::AsyncResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#a08e7667c305f6c361345c9a8e261d73a">wrap</a> (GAsyncResult* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a08e7667c305f6c361345c9a8e261d73a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides a base class for implementing asynchronous function results. </p>
<p>Asynchronous operations are broken up into two separate operations which are chained together by a SlotAsyncReady. To begin an asynchronous operation, provide a SlotAsyncReady to the asynchronous function. This callback will be triggered when the operation has completed, and will be passed an <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> instance filled with the details of the operation's success or failure, the object the asynchronous function was started for and any error codes returned. The asynchronous callback function is then expected to call the corresponding "_finish()" function with the object the function was called for, and the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> instance.</p>
<p>The purpose of the "_finish()" function is to take the generic result of type <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> and return the specific result that the operation in question yields (e.g. a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> for an "enumerate children" operation). If the result or error status of the operation is not needed, there is no need to call the "_finish()" function and GIO will take care of cleaning up the result and error information after the SlotAsyncReady returns. You may also store the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> and call "_finish()" later.</p>
<p>Example of a typical asynchronous operation flow: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> _theoretical_frobnitz_async(<span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Theoretical&gt;</a>&amp; t,                                   <span class="keyword">const</span> <a class="code" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe" title="A function that will be called when an asynchronous operation within GIO has been...">SlotAsyncReady</a>&amp; slot);
 
 gboolean _theoretical_frobnitz_finish(<span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Theoretical&gt;</a>&amp; t,
                                       <span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;AsyncResult&gt;</a>&amp; result);
 
 <span class="keyword">static</span> <span class="keywordtype">void</span>  on_frobnitz_result(<a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;AsyncResult&gt;</a>&amp; result)
 {
 
   <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Glib::Object&gt;</a> source_object = result-&gt;get_source_object();
   <span class="keywordtype">bool</span> success = _theoretical_frobnitz_finish(source_object, res);
 
   <span class="keywordflow">if</span> (success)
     <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Hurray&quot;</span> &lt;&lt; <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a4a01795921d3387d04f02890447638d4">std::endl</a>;
   <span class="keywordflow">else</span>      <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Uh oh!&quot;</span> &lt;&lt; std::endl;
 
   ...
 }
 
 <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
 {
    ...
 
    _theoretical_frobnitz_async (theoretical_data,                                  <a class="codeRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__ptr__fun.html#gada8b678665c14dc85eb32d25b7299465">sigc::ptr_fun</a>(&amp;on_frobnitz_result) );
 
    ...
 }
</pre></div><p>The async function could also take an optional Glib::Cancellable object, allowing the calling function to cancel the asynchronous operation.</p>
<p>The callback for an asynchronous operation is called only once, and is always called, even in the case of a cancelled operation. On cancellation the result is a ERROR_CANCELLED error.</p>
<p>Some ascynchronous operations are implemented using synchronous calls. These are run in a separate GThread, but otherwise they are sent to the Main Event Loop and processed in an idle function. So, if you truly need asynchronous operations, make sure to initialize GThread.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000016">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9dae859748e44341d2c14a2777ca4fee"></a><!-- doxytag: member="Gio::AsyncResult::~AsyncResult" ref="a9dae859748e44341d2c14a2777ca4fee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::AsyncResult::~AsyncResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a27a2e7a0488f8a3db08fa9547c791c6a"></a><!-- doxytag: member="Gio::AsyncResult::add_interface" ref="a27a2e7a0488f8a3db08fa9547c791c6a" args="(GType gtype_implementer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gio::AsyncResult::add_interface </td>
          <td>(</td>
          <td class="paramtype">GType&#160;</td>
          <td class="paramname"> <em>gtype_implementer</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adcb9d80c42cf04098629a8153d51b32c"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object" ref="adcb9d80c42cf04098629a8153d51b32c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The source object for the <em>res</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b89bee3ed3ff402ff58f836e1d2398e"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object" ref="a3b89bee3ed3ff402ff58f836e1d2398e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The source object for the <em>res</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a97f3fe7208156d2c981f42e97ec4ce20"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object_vfunc" ref="a97f3fe7208156d2c981f42e97ec4ce20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object_vfunc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a134862761e05a548d2817505480140be"></a><!-- doxytag: member="Gio::AsyncResult::gobj" ref="a134862761e05a548d2817505480140be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GAsyncResult* Gio::AsyncResult::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">Glib::Interface</a>.</p>

</div>
</div>
<a class="anchor" id="ad7ebc2ac808bd8eff4f4cd4f94c1c70a"></a><!-- doxytag: member="Gio::AsyncResult::gobj" ref="ad7ebc2ac808bd8eff4f4cd4f94c1c70a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GAsyncResult* Gio::AsyncResult::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">Glib::Interface</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a08e7667c305f6c361345c9a8e261d73a"></a><!-- doxytag: member="Gio::AsyncResult::wrap" ref="a08e7667c305f6c361345c9a8e261d73a" args="(GAsyncResult *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">Gio::AsyncResult</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GAsyncResult *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>giomm/asyncresult.h</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Mar 26 11:48:22 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
