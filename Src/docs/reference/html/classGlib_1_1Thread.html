<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Glib::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGlib.html">Glib</a>::<a class="el" href="classGlib_1_1Thread.html">Thread</a>
  </div>
</div>
<div class="contents">
<h1>Glib::Thread Class Reference<br/>
<small>
[<a class="el" href="group__Threads.html">Threads</a>]</small>
</h1><!-- doxytag: class="Glib::Thread" -->
<p>Represents a running thread. <a href="#_details">More...</a></p>

<p><a href="classGlib_1_1Thread-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread_1_1Exit.html">Exit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class used to exit from a thread. <a href="classGlib_1_1Thread_1_1Exit.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a9feee4b860d9928f86b9d255e2f2b133">joinable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is joinable. <a href="#a9feee4b860d9928f86b9d255e2f2b133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e">join</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the thread finishes. <a href="#ab95e51699279fd84c9577c45d76b0d8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a3b323f981147d7eb4b4bd03f3fbdccf5">set_priority</a> (<a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of the thread to <em>priority</em>. <a href="#a3b323f981147d7eb4b4bd03f3fbdccf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a28d1bcf53d846b8b0d75b93178a614ab">get_priority</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority of the thread. <a href="#a28d1bcf53d846b8b0d75b93178a614ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GThread*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a28fbc6c46928a90d82114fa9b6b63196">gobj</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GThread*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a351fa5fb621a394e28037c4f50ab69ad">gobj</a> () const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#ab165854ff2fc9b454ee4d97050485782">create</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot, bool joinable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread with the priority <code>THREAD_PRIORITY_NORMAL</code>. <a href="#ab165854ff2fc9b454ee4d97050485782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#af30a7a8b037c7c7a3802aa2a22cf612d">create</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot, unsigned long stack_size, bool joinable, bool bound, <a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread with the priority <em>priority</em>. <a href="#af30a7a8b037c7c7a3802aa2a22cf612d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a9db6864c35701b1c179f48217ab76cca">self</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Thread* corresponding to the calling thread. <a href="#a9db6864c35701b1c179f48217ab76cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#acad8be7a8093ef3aca32344264461011">yield</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives way to other threads waiting to be scheduled. <a href="#acad8be7a8093ef3aca32344264461011"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Threads.html#ga6bfbb3119eaac9fa8cb725aa1e82f61e">wrap</a> (GThread* gobject)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Represents a running thread. </p>
<p>An instance of this class can only be obtained with <a class="el" href="classGlib_1_1Thread.html#ab165854ff2fc9b454ee4d97050485782" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL.">create()</a>, <a class="el" href="classGlib_1_1Thread.html#a9db6864c35701b1c179f48217ab76cca" title="Returns the Thread* corresponding to the calling thread.">self()</a>, or <a class="el" href="group__Threads.html#ga6bfbb3119eaac9fa8cb725aa1e82f61e">wrap(GThread*)</a>. It's not possible to delete a <a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread.">Thread</a> object. If the thread is <em>not</em> joinable, its resources will be freed automatically when it exits. Otherwise, if the thread <em>is</em> joinable, you must call <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes.">join()</a> to avoid a memory leak.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>g_thread_exit() is not wrapped, because that function exits a thread without any cleanup. That's especially dangerous in C++ code, since the destructors of automatic objects won't be invoked. Instead, you can throw a <a class="el" href="classGlib_1_1Thread_1_1Exit.html" title="Exception class used to exit from a thread.">Thread::Exit</a> exception, which will be caught by the internal thread entry function.</dd>
<dd>
You might have noticed that the thread entry slot doesn't have the usual void* return value. If you want to return any data from your thread you can pass an additional output argument to the thread's entry slot. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="thread_2dispatcher_8cc-example.html#_a1">thread/dispatcher.cc</a>, and <a class="el" href="thread_2thread_8cc-example.html#_a11">thread/thread.cc</a>.</p>
</dd>
</dl><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af30a7a8b037c7c7a3802aa2a22cf612d"></a><!-- doxytag: member="Glib::Thread::create" ref="af30a7a8b037c7c7a3802aa2a22cf612d" args="(const sigc::slot&lt; void &gt; &amp;slot, unsigned long stack_size, bool joinable, bool bound, ThreadPriority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>joinable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td>
          <td class="paramname"> <em>priority</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new thread with the priority <em>priority</em>. </p>
<p>The stack gets the size <em>stack_size</em> or the default value for the current platform, if <em>stack_size</em> is <code>0</code>.</p>
<p>If <em>joinable</em> is <code>true</code>, you can wait for this thread's termination by calling <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes.">join()</a>. Otherwise the thread will just disappear, when ready. If <em>bound</em> is <code>true</code>, this thread will be scheduled in the system scope, otherwise the implementation is free to do scheduling in the process scope. The first variant is more expensive resource-wise, but generally faster. On some systems (e.g. Linux) all threads are bound.</p>
<p>The new thread executes the function or method <em>slot</em> points to. You can pass additional arguments using <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__bind.html#ga2148290d2cf9c1961ec157a085badd5a">sigc::bind()</a>. If the thread was created successfully, it is returned.</p>
<p>Because <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a> is not thread safe, if the slot represents a non-static class method (that is, it is created by <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun()</a>), the class concerned should not derive from <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is not guaranteed, that threads with different priorities really behave accordingly. On some systems (e.g. Linux) only root can increase priorities. On other systems (e.g. Solaris) there doesn't seem to be different scheduling for different priorities. All in all try to avoid being dependent on priorities. Use <code><a class="el" href="group__glibmmEnums.html#gga9b87dca6496b6ad53baec9ca01318448a6216bb25baaaca32642841ade911a92e">Glib::THREAD_PRIORITY_NORMAL</a></code> here as a default.</dd>
<dd>
Only use the extended <a class="el" href="classGlib_1_1Thread.html#af30a7a8b037c7c7a3802aa2a22cf612d" title="Creates a new thread with the priority priority.">create(const sigc::slot&lt;void&gt;&amp;, unsigned long, bool, bool, ThreadPriority)</a> function, when you really can't use the simple <a class="el" href="classGlib_1_1Thread.html#ab165854ff2fc9b454ee4d97050485782" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL.">create(const sigc::slot&lt;void&gt;&amp;, bool)</a> instead. The latter overload does not take <em>stack_size</em>, <em>bound</em> and <em>priority</em> as arguments, as they should only be used for cases, where it is inevitable.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A slot to execute in the new thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stack_size</em>&#160;</td><td>A stack size for the new thread, or <code>0</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>joinable</em>&#160;</td><td>Should this thread be joinable? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&#160;</td><td>Should this thread be bound to a system thread? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&#160;</td><td>A priority for the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new Thread* on success. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors.">Glib::ThreadError</a></em>&#160;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab165854ff2fc9b454ee4d97050485782"></a><!-- doxytag: member="Glib::Thread::create" ref="ab165854ff2fc9b454ee4d97050485782" args="(const sigc::slot&lt; void &gt; &amp;slot, bool joinable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>joinable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new thread with the priority <code>THREAD_PRIORITY_NORMAL</code>. </p>
<p>If <em>joinable</em> is <code>true</code>, you can wait for this thread's termination by calling <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes.">join()</a>. Otherwise the thread will just disappear, when ready.</p>
<p>The new thread executes the function or method <em>slot</em> points to. You can pass additional arguments using <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__bind.html#ga2148290d2cf9c1961ec157a085badd5a">sigc::bind()</a>. If the thread was created successfully, it is returned, otherwise a <a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors.">ThreadError</a> exception is thrown.</p>
<p>Because <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a> is not thread safe, if the slot represents a non-static class method (that is, it is created by <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun()</a>), the class concerned should not derive from <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&#160;</td><td>A slot to execute in the new thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>joinable</em>&#160;</td><td>Should this thread be joinable? </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new Thread* on success. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors.">Glib::ThreadError</a></em>&#160;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="thread_2dispatcher_8cc-example.html#a6">thread/dispatcher.cc</a>, and <a class="el" href="thread_2thread_8cc-example.html#a12">thread/thread.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a28d1bcf53d846b8b0d75b93178a614ab"></a><!-- doxytag: member="Glib::Thread::get_priority" ref="a28d1bcf53d846b8b0d75b93178a614ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> Glib::Thread::get_priority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the priority of the thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The thread's priority. </dd></dl>

</div>
</div>
<a class="anchor" id="a351fa5fb621a394e28037c4f50ab69ad"></a><!-- doxytag: member="Glib::Thread::gobj" ref="a351fa5fb621a394e28037c4f50ab69ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GThread* Glib::Thread::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a28fbc6c46928a90d82114fa9b6b63196"></a><!-- doxytag: member="Glib::Thread::gobj" ref="a28fbc6c46928a90d82114fa9b6b63196" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GThread* Glib::Thread::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab95e51699279fd84c9577c45d76b0d8e"></a><!-- doxytag: member="Glib::Thread::join" ref="ab95e51699279fd84c9577c45d76b0d8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Thread::join </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits until the thread finishes. </p>
<p>Waits until the thread finishes, i.e. the slot, as given to <a class="el" href="classGlib_1_1Thread.html#ab165854ff2fc9b454ee4d97050485782" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL.">create()</a>, returns or g_thread_exit() is called by the thread. (Calling g_thread_exit() in a C++ program should be avoided.) All resources of the thread including the <a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread.">Glib::Thread</a> object are released. The thread must have been created with <code>joinable&#160;=&#160;true</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="thread_2thread_8cc-example.html#a14">thread/thread.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9feee4b860d9928f86b9d255e2f2b133"></a><!-- doxytag: member="Glib::Thread::joinable" ref="a9feee4b860d9928f86b9d255e2f2b133" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Thread::joinable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the thread is joinable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the thread is joinable. </dd></dl>

</div>
</div>
<a class="anchor" id="a9db6864c35701b1c179f48217ab76cca"></a><!-- doxytag: member="Glib::Thread::self" ref="a9db6864c35701b1c179f48217ab76cca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::self </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Thread* corresponding to the calling thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b323f981147d7eb4b4bd03f3fbdccf5"></a><!-- doxytag: member="Glib::Thread::set_priority" ref="a3b323f981147d7eb4b4bd03f3fbdccf5" args="(ThreadPriority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Thread::set_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td>
          <td class="paramname"> <em>priority</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the priority of the thread to <em>priority</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is not guaranteed, that threads with different priorities really behave accordingly. On some systems (e.g. Linux) only <code>root</code> can increase priorities. On other systems (e.g. Solaris) there doesn't seem to be different scheduling for different priorities. All in all try to avoid being dependent on priorities. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&#160;</td><td>A new priority for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acad8be7a8093ef3aca32344264461011"></a><!-- doxytag: member="Glib::Thread::yield" ref="acad8be7a8093ef3aca32344264461011" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Glib::Thread::yield </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives way to other threads waiting to be scheduled. </p>
<p>This function is often used as a method to make busy wait less evil. But in most cases, you will encounter, there are better methods to do that. So in general you shouldn't use this function. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>glibmm/thread.h</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Mar 26 11:48:25 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
