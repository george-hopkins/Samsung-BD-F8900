<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library Namespace Reference</h1>
<p>The entire library is confined to this namespace.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library_1_1IO__Operators.html">IO_Operators</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>All input/output operators are confined to this namespace. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Throwable.html">Throwable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User objects the PPL can throw.  <a href="classParma__Polyhedra__Library_1_1Throwable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class.  <a href="structParma__Polyhedra__Library_1_1Recycle__Input.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParma__Polyhedra__Library_1_1Is__Checked.html">Is_Checked</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParma__Polyhedra__Library_1_1Is__Checked_3_01Checked__Number_3_01T_00_01P_01_4_01_4.html">Is_Checked&lt; Checked_Number&lt; T, P &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for numeric types implementing a given policy.  <a href="classParma__Polyhedra__Library_1_1Checked__Number.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dimension of the vector space.  <a href="classParma__Polyhedra__Library_1_1Variable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linear expression.  <a href="classParma__Polyhedra__Library_1_1Linear__Expression.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A system of constraints.  <a href="classParma__Polyhedra__Library_1_1Constraint__System.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linear equality or inequality.  <a href="classParma__Polyhedra__Library_1_1Constraint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The relation between a polyhedron and a constraint.  <a href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A system of generators.  <a href="classParma__Polyhedra__Library_1_1Generator__System.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A line, ray, point or closure point.  <a href="classParma__Polyhedra__Library_1_1Generator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A system of congruences.  <a href="classParma__Polyhedra__Library_1_1Congruence__System.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linear congruence.  <a href="classParma__Polyhedra__Library_1_1Congruence.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A system of grid generators.  <a href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A grid line, parameter or grid point.  <a href="classParma__Polyhedra__Library_1_1Grid__Generator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An std::set of variables' indexes.  <a href="classParma__Polyhedra__Library_1_1Variables__Set.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Parametric Integer (linear) Programming problem.  <a href="classParma__Polyhedra__Library_1_1PIP__Problem.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html">PIP_Tree_Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A node of the PIP solution tree.  <a href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Solution__Node.html">PIP_Solution_Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tree node representing part of the space of solutions.  <a href="classParma__Polyhedra__Library_1_1PIP__Solution__Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Decision__Node.html">PIP_Decision_Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tree node representing a decision in the space of solutions.  <a href="classParma__Polyhedra__Library_1_1PIP__Decision__Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BHRZ03__Certificate.html">BHRZ03_Certificate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The convergence certificate for the BHRZ03 widening operator.  <a href="classParma__Polyhedra__Library_1_1BHRZ03__Certificate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1H79__Certificate.html">H79_Certificate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convergence certificate for the H79 widening operator.  <a href="classParma__Polyhedra__Library_1_1H79__Certificate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The relation between a polyhedron and a generator.  <a href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for convex polyhedra.  <a href="classParma__Polyhedra__Library_1_1Polyhedron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1MIP__Problem.html">MIP_Problem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Mixed Integer (linear) Programming problem.  <a href="classParma__Polyhedra__Library_1_1MIP__Problem.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic, not necessarily closed, possibly restricted interval.  <a href="classParma__Polyhedra__Library_1_1Interval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Certificate.html">Grid_Certificate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The convergence certificate for the <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> widening operator.  <a href="classParma__Polyhedra__Library_1_1Grid__Certificate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A closed convex polyhedron.  <a href="classParma__Polyhedra__Library_1_1C__Polyhedron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A not necessarily closed convex polyhedron.  <a href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A grid.  <a href="classParma__Polyhedra__Library_1_1Grid.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A not necessarily closed, iso-oriented hyperrectangle.  <a href="classParma__Polyhedra__Library_1_1Box.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bounded difference shape.  <a href="classParma__Polyhedra__Library_1_1BD__Shape.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An octagonal shape.  <a href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Smash__Reduction.html">Smash_Reduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides the reduction method for the Smash_Product domain.  <a href="classParma__Polyhedra__Library_1_1Smash__Reduction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraints__Reduction.html">Constraints_Reduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides the reduction method for the Constraints_Product domain.  <a href="classParma__Polyhedra__Library_1_1Constraints__Reduction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruences__Reduction.html">Congruences_Reduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides the reduction method for the Congruences_Product domain.  <a href="classParma__Polyhedra__Library_1_1Congruences__Reduction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Shape__Preserving__Reduction.html">Shape_Preserving_Reduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides the reduction method for the Shape_Preserving_Product domain.  <a href="classParma__Polyhedra__Library_1_1Shape__Preserving__Reduction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1No__Reduction.html">No_Reduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides the reduction method for the Direct_Product domain.  <a href="classParma__Polyhedra__Library_1_1No__Reduction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partially reduced product of two abstractions.  <a href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Domain__Product.html">Domain_Product</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is temporary and will be removed when template typedefs will be supported in C++.  <a href="classParma__Polyhedra__Library_1_1Domain__Product.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Determinate.html">Determinate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for PPL pointsets, providing them with a <em>determinate constraint system</em> interface, as defined in <a class="el" href="main.html#Bag98">[Bag98]</a>.  <a href="classParma__Polyhedra__Library_1_1Determinate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The powerset construction on a base-level domain.  <a href="classParma__Polyhedra__Library_1_1Powerset.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The powerset construction instantiated on PPL pointset domains.  <a href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1GMP__Integer.html">GMP_Integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbounded integers as provided by the GMP library.  <a href="classParma__Polyhedra__Library_1_1GMP__Integer.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unsigned integral type for representing space dimensions.  <a href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unsigned integral type for representing memory size in bytes.  <a href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef PPL_COEFFICIENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias for easily naming the type of PPL coefficients.  <a href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8">Result_Class</a> { <a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8a96b8890edb38e9960c455aa178e508ba">VC_NORMAL</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8abd640c30f757e4ecccd08ac527536ca6">VC_MINUS_INFINITY</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8a979f37a289d4cb316643f1dcc07ec7cd">VC_PLUS_INFINITY</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8a9606fc251d767040929d3e2645dbb446">VC_NAN</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98">Result_Relation</a> { <br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98af4fca65e2503d4afea11aa9b9da7d51e">VR_EMPTY</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98a9afce68d66f8c8eedec345f8df2e822f">VR_EQ</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98ae9e9040024adaad2b7a0d9ceea0c8b62">VR_LT</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98accf532c4e56a06e520b6b3f638371667">VR_GT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98a9223ac459b80b2eb397dd7810be7aa07">VR_NE</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98a44ed03f4b908d58ac405493b10be3012">VR_LE</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98a4e456df02ee601b05831536311de132c">VR_GE</a>, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98a468389fd24e4a478d296cbcf6b104eb0">VR_LGE</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#gaa88e9b9cb2588cbf5914695fc14e69a8">Result</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a3d884f787b884a260970cdef004fcc10">V_EMPTY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a9f5dce9506b72773425c0504845d8e4e">V_EQ</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8ab30277f972f730fe26f6cfc39098cc77">V_LT</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8ae704947d33ff1b60a2475950d5f18ec3">V_GT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8ad5e386c6a05c9656eac42fe9e2cdd8b5">V_NE</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8ac77955fc77a169347da8820b46c3247b">V_LE</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a6c817c11198882f3864d8ace4ec326dd">V_GE</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a0d808c2d0d6514c33e06445d7aa34270">V_LGE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8adeb9e65ceecfb8271acec22e00a226ca">V_OVERFLOW</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a4194f750c76fb24d6e5930e1696076c4">V_LT_INF</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a4e2e7513e80017645e24e2fc7bb6846d">V_GT_SUP</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a44e009680d1b9995b04ac762c6ef8057">V_LT_PLUS_INFINITY</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8aca1ef0806f3a27d811b8f7352d53a21b">V_GT_MINUS_INFINITY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8abb38c3a22ea0af9a40c568e55afa897b">V_EQ_MINUS_INFINITY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a02347568b111860e1ac15154a1832252">V_EQ_PLUS_INFINITY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8aaee8efad6ea4263d7aa15cb0db2497ea">V_NAN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8ae0c660bfcbcd3d10c3e764e22f41d0a1">V_CVT_STR_UNK</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a057025d0ff550a2226a0a1273c84b4f6">V_DIV_ZERO</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8aa1bf7bec2cb0d949e45c3cd0e25874a6">V_INF_ADD_INF</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a5912e00d1de38a643d48af1f0e5dd35f">V_INF_DIV_INF</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8afda2f32e2fc3f61357ce0d9d7813f5fc">V_INF_MOD</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a930a62d56d7231cdb1ed57e1d3eff0f7">V_INF_MUL_ZERO</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8abd1bad185f4622d07b171767dafc78b6">V_INF_SUB_INF</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8aa0f28596ac7d4a43766fab174c28ccab">V_MOD_ZERO</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a261922c7bb53bf71459671df868e55da">V_SQRT_NEG</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a0905d51325862cb4db00635875efcff8">V_UNKNOWN_NEG_OVERFLOW</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8a202263943c451b9fdfe003b2bc8d0b1f">V_UNKNOWN_POS_OVERFLOW</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa88e9b9cb2588cbf5914695fc14e69a8aceefc8c6d25b8e2ae5e538a9f793516e">V_UNREPRESENTABLE</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible outcomes of a checked arithmetic computation. </p>
 <a href="group__PPL__CXX__interface.html#gaa88e9b9cb2588cbf5914695fc14e69a8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> { <a class="el" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899a0edf84fcb94023ff4a7183bf3f8dace5">UNIVERSE</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370">EMPTY</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Kinds of degenerate abstract elements. </p>
 <a href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aea3e4424ce8e7ebe86e125541b561fc300">EQUAL</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aea556cc08f48e769b9c15bea83d5d883a1">LESS_THAN</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aead8db7109fb4bb50360b05800dd245416">LESS_OR_EQUAL</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aea94cf20719046117aece5acba61dcae4d">GREATER_THAN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aea079e4b80f17b0095497103a52cffa3ab">GREATER_OR_EQUAL</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga1c2a279a3ffa1d1e9947f2667be312aea8191bdbdcd041a9859ed465d16062ab1">NOT_EQUAL</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Relation symbols. </p>
 <a href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> { <a class="el" href="group__PPL__CXX__interface.html#gga113f1e845cba6b1c3c5705d0e14f1cc1a71c9b0459dc8ba8cc0c8178b6cf4f017">POLYNOMIAL_COMPLEXITY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga113f1e845cba6b1c3c5705d0e14f1cc1ab39e3c667ce455313f8ff578722af2e9">SIMPLEX_COMPLEXITY</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga113f1e845cba6b1c3c5705d0e14f1cc1a40409716eac06f7ee5c44a200d3702f0">ANY_COMPLEXITY</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Complexity pseudo-classes. </p>
 <a href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#gaac82e7e0179442ef589f2fc61302d654">Optimization_Mode</a> { <a class="el" href="group__PPL__CXX__interface.html#ggaac82e7e0179442ef589f2fc61302d654a324bf568397fdfc332a4c06e7a4facf5">MINIMIZATION</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaac82e7e0179442ef589f2fc61302d654a0e1a601a53491f60c89282fde55b5352">MAXIMIZATION</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible optimization modes. </p>
 <a href="group__PPL__CXX__interface.html#gaac82e7e0179442ef589f2fc61302d654">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga73813939ed838a85ae565152ba3cb6fda591549aad4d57135c2dcc6fd73daf554">BITS_8</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga73813939ed838a85ae565152ba3cb6fdac58a6ff6765224e937fefbadf45a4860">BITS_16</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga73813939ed838a85ae565152ba3cb6fdad09cef587030649e808d0e255b83d1ef">BITS_32</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga73813939ed838a85ae565152ba3cb6fda405c8934c8b3f4d8c5ba0b21b674e559">BITS_64</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga73813939ed838a85ae565152ba3cb6fda9a59b7fa00c2cf8df942badc9c414aef">BITS_128</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Widths of bounded integer types. </p>
 <a href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> { <a class="el" href="group__PPL__CXX__interface.html#gga61102bed0c7780ab782fcc8cd57a384aaafd3e20e35e86cff976d68ffc4283c32">UNSIGNED</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga61102bed0c7780ab782fcc8cd57a384aaf4462ec77078de4bbabb446cf61e5123">SIGNED_2_COMPLEMENT</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Representation of bounded integer types. </p>
 <a href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> { <a class="el" href="group__PPL__CXX__interface.html#gga84cc2bd35e1437f8df3be984dd1f4638a832f214eaa5bc2ce48e1e2d67473cf10">OVERFLOW_WRAPS</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga84cc2bd35e1437f8df3be984dd1f4638a7869fdfe9b1ace668a0a7b1d2faba812">OVERFLOW_UNDEFINED</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga84cc2bd35e1437f8df3be984dd1f4638a7b85b6b4c644857c3809eeef6aa35dbb">OVERFLOW_IMPOSSIBLE</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Overflow behavior of bounded integer types. </p>
 <a href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga25ea3a289eadef732f4c7fd823387fb2abeee33de6f8542b0228161d044640eaa">ROUND_DOWN</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga25ea3a289eadef732f4c7fd823387fb2aa57b0c1a34eced57ca8437eea92a4328">ROUND_UP</a>, 
<a class="el" href="group__PPL__CXX__interface.html#gga25ea3a289eadef732f4c7fd823387fb2a0f182c5824807f7bc66d2d2033810feb">ROUND_IGNORE</a>
, <a class="el" href="group__PPL__CXX__interface.html#gga25ea3a289eadef732f4c7fd823387fb2aeafcc7ca16bda73dc6b0f7deaf9470dd">ROUND_NOT_NEEDED</a>
, <br/>
&nbsp;&nbsp;<a class="el" href="group__PPL__CXX__interface.html#gga25ea3a289eadef732f4c7fd823387fb2ae0c0414fd69996a2edb8ea476ab236e1">ROUND_STRICT_RELATION</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Rounding directions for arithmetic computations. </p>
 <a href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#gaa7159523299c8f193184a1bda20d6044">PIP_Problem_Status</a> { <a class="el" href="group__PPL__CXX__interface.html#ggaa7159523299c8f193184a1bda20d6044a7fee51bad737377323f3d7ddb036a74e">UNFEASIBLE_PIP_PROBLEM</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggaa7159523299c8f193184a1bda20d6044a3b60d6dfe175b3a5d48361ac121f23ae">OPTIMIZED_PIP_PROBLEM</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible outcomes of the PIP_Problem solver. </p>
 <a href="group__PPL__CXX__interface.html#gaa7159523299c8f193184a1bda20d6044">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#gadf9d6f17d8974c81e3499f170e7762a2">MIP_Problem_Status</a> { <a class="el" href="group__PPL__CXX__interface.html#ggadf9d6f17d8974c81e3499f170e7762a2a53f4353b82f1a10a08b1e756bb7c84ad">UNFEASIBLE_MIP_PROBLEM</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggadf9d6f17d8974c81e3499f170e7762a2ab2bc77b49f9450faf5b5f8ca5374421d">UNBOUNDED_MIP_PROBLEM</a>, 
<a class="el" href="group__PPL__CXX__interface.html#ggadf9d6f17d8974c81e3499f170e7762a2a78fc3e83d58f3eb97a8041b600870a05">OPTIMIZED_MIP_PROBLEM</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible outcomes of the MIP_Problem solver. </p>
 <a href="group__PPL__CXX__interface.html#gadf9d6f17d8974c81e3499f170e7762a2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> { <br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a3388ff37939783f337c4aeca28873c8a">I_EMPTY</a> =  1, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766ad57704b5d1b446fc9840009f06a5cb49">I_SINGLETON</a> =  2, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766ad2496277dd6e1de91ca84a903ed28b64">I_SOME</a> =  4, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a16951436466647aef85cdd1f567200af">I_UNIVERSE</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766ada806236c55c963a0f138b67310de3b8">I_NOT_EMPTY</a> =  I_SINGLETON | I_SOME | I_UNIVERSE, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a3bdee6d73627cc8338fb846f4a1fa935">I_ANY</a> =  I_EMPTY | I_NOT_EMPTY, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a00b00eff42cb35b0009a39ceb4202ac6">I_NOT_UNIVERSE</a> =  I_EMPTY | I_SINGLETON | I_SOME, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a517be2ee42ead94cbef7d4ec632500ea">I_NOT_DEGENERATE</a> =  I_SINGLETON | I_SOME, 
<br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766adb4b733a5edc79c83812093b2d020952">I_EXACT</a> =  16, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a5e739a5468d529a02f4248c77a4776a7">I_INEXACT</a> =  32, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a4fbc5cd99bd48b3a521a9f2c5e7b0c00">I_CHANGED</a> =  64, 
<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a3181ff1b549af004ba60f7c664037192">I_UNCHANGED</a> =  128, 
<br/>
&nbsp;&nbsp;<a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766a78a1e232394b81ca2319e8f3f066e377">I_SINGULARITIES</a> =  256
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0adf6106892886dc859985042b8a7433"></a><!-- doxytag: member="Parma_Polyhedra_Library::version_major" ref="a0adf6106892886dc859985042b8a7433" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a0adf6106892886dc859985042b8a7433">version_major</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the major number of the PPL version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9dd9190c5f29dbbfa3d6e442dea7e7d"></a><!-- doxytag: member="Parma_Polyhedra_Library::version_minor" ref="af9dd9190c5f29dbbfa3d6e442dea7e7d" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#af9dd9190c5f29dbbfa3d6e442dea7e7d">version_minor</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minor number of the PPL version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5604f97d216583cdf012a50d2f8cdbde"></a><!-- doxytag: member="Parma_Polyhedra_Library::version_revision" ref="a5604f97d216583cdf012a50d2f8cdbde" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a5604f97d216583cdf012a50d2f8cdbde">version_revision</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the revision number of the PPL version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af127b16b1a8e300aa97caca515284b6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::version_beta" ref="af127b16b1a8e300aa97caca515284b6f" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#af127b16b1a8e300aa97caca515284b6f">version_beta</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the beta number of the PPL version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e9dc5df3cf7c0ab581e602d1176e41"></a><!-- doxytag: member="Parma_Polyhedra_Library::version" ref="a99e9dc5df3cf7c0ab581e602d1176e41" args="()" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a99e9dc5df3cf7c0ab581e602d1176e41">version</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a character string containing the PPL version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#aee4e9b54e65780ac3010fda40ea235a6">banner</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a character string containing the PPL banner.  <a href="#aee4e9b54e65780ac3010fda40ea235a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a63bd7c7767faf3c219f9c2762095e2dd">set_rounding_for_PPL</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FPU rounding mode so that the PPL abstractions based on floating point numbers work correctly.  <a href="#a63bd7c7767faf3c219f9c2762095e2dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a6c841f33162c2419bd53a078e6c788ee">restore_pre_PPL_rounding</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FPU rounding mode as it was before initialization of the PPL.  <a href="#a6c841f33162c2419bd53a078e6c788ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace0cdceaa0c7eea84cc1c38cf5bea680"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_initialize_control_functions" ref="ace0cdceaa0c7eea84cc1c38cf5bea680" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ace0cdceaa0c7eea84cc1c38cf5bea680">fpu_initialize_control_functions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the FPU control functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c118832fed4c0b9b40547578459dad4"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_get_rounding_direction" ref="a9c118832fed4c0b9b40547578459dad4" args="()" -->
fpu_rounding_direction_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a9c118832fed4c0b9b40547578459dad4">fpu_get_rounding_direction</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current FPU rounding direction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad31eeb0067d6cad2eb2ea5ab5bd0a2b2"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_set_rounding_direction" ref="ad31eeb0067d6cad2eb2ea5ab5bd0a2b2" args="(fpu_rounding_direction_type dir)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ad31eeb0067d6cad2eb2ea5ab5bd0a2b2">fpu_set_rounding_direction</a> (fpu_rounding_direction_type dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FPU rounding direction to <code>dir</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74074a5ed3718745a4d82bacd5b381ed"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_save_rounding_direction" ref="a74074a5ed3718745a4d82bacd5b381ed" args="(fpu_rounding_direction_type dir)" -->
fpu_rounding_control_word_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a74074a5ed3718745a4d82bacd5b381ed">fpu_save_rounding_direction</a> (fpu_rounding_direction_type dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FPU rounding direction to <code>dir</code> and returns the rounding control word previously in use. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e6dcd6f5d8e3ea263c9205b21a83e48"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_save_rounding_direction_reset_inexact" ref="a3e6dcd6f5d8e3ea263c9205b21a83e48" args="(fpu_rounding_direction_type dir)" -->
fpu_rounding_control_word_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a3e6dcd6f5d8e3ea263c9205b21a83e48">fpu_save_rounding_direction_reset_inexact</a> (fpu_rounding_direction_type dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FPU rounding direction to <code>dir</code>, clears the <em>inexact computation</em> status, and returns the rounding control word previously in use. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a54c55d8b52ef353df7cefdfa632d8d"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_restore_rounding_direction" ref="a6a54c55d8b52ef353df7cefdfa632d8d" args="(fpu_rounding_control_word_type w)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a6a54c55d8b52ef353df7cefdfa632d8d">fpu_restore_rounding_direction</a> (fpu_rounding_control_word_type w)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restores the FPU rounding rounding control word to <code>cw</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e801a56c2c3dcec13d2d87adf07ac47"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_reset_inexact" ref="a5e801a56c2c3dcec13d2d87adf07ac47" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a5e801a56c2c3dcec13d2d87adf07ac47">fpu_reset_inexact</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the <em>inexact computation</em> status. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a19b0ebdb3476fe1feb0f51d9328fd384">fpu_check_inexact</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the <em>inexact computation</em> status.  <a href="#a19b0ebdb3476fe1feb0f51d9328fd384"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f3cc785d7b89f59b3ca216461c34b0"></a><!-- doxytag: member="Parma_Polyhedra_Library::result_class" ref="a95f3cc785d7b89f59b3ca216461c34b0" args="(Result r)" -->
<a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8">Result_Class</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a95f3cc785d7b89f59b3ca216461c34b0">result_class</a> (<a class="el" href="group__PPL__CXX__interface.html#gaa88e9b9cb2588cbf5914695fc14e69a8">Result</a> r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the value class part of <code>r</code> (representable number, unrepresentable minus/plus infinity or nan). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac40e401b77b5ec6e9625c317ce6d760d"></a><!-- doxytag: member="Parma_Polyhedra_Library::result_relation" ref="ac40e401b77b5ec6e9625c317ce6d760d" args="(Result r)" -->
<a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98">Result_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ac40e401b77b5ec6e9625c317ce6d760d">result_relation</a> (<a class="el" href="group__PPL__CXX__interface.html#gaa88e9b9cb2588cbf5914695fc14e69a8">Result</a> r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the relation part of <code>r</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20874a85120477d5cf11da451870d497"></a><!-- doxytag: member="Parma_Polyhedra_Library::not_a_dimension" ref="a20874a85120477d5cf11da451870d497" args="()" -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a20874a85120477d5cf11da451870d497">not_a_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a value that does not designate a valid dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56eb4e32ec57658bc9e7823cd42ecbae"></a><!-- doxytag: member="Parma_Polyhedra_Library::inverse" ref="a56eb4e32ec57658bc9e7823cd42ecbae" args="(Rounding_Dir dir)" -->
<a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a56eb4e32ec57658bc9e7823cd42ecbae">inverse</a> (<a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the inverse rounding mode of <code>dir</code>, <code>ROUND_IGNORE</code> being the inverse of itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ed91fbbeb6d32952c5d2a30bfd3830"></a><!-- doxytag: member="Parma_Polyhedra_Library::initialize" ref="a03ed91fbbeb6d32952c5d2a30bfd3830" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a03ed91fbbeb6d32952c5d2a30bfd3830">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the library. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05dd6b345e96427a50b45f9756e302ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::finalize" ref="a05dd6b345e96427a50b45f9756e302ab" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a05dd6b345e96427a50b45f9756e302ab">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the library. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30a5addfb775d0e3586f1575ece47bf6"></a><!-- doxytag: member="Parma_Polyhedra_Library::irrational_precision" ref="a30a5addfb775d0e3586f1575ece47bf6" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a30a5addfb775d0e3586f1575ece47bf6">irrational_precision</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the precision parameter used for irrational calculations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#abdd9791a8d91b11a5bd3a6ef0770bc86">set_irrational_precision</a> (const unsigned p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the precision parameter used for irrational calculations.  <a href="#abdd9791a8d91b11a5bd3a6ef0770bc86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93c37cc32a1f50c36ec15d67fdbec3aa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Coefficient_zero" ref="a93c37cc32a1f50c36ec15d67fdbec3aa" args="()" -->
Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a93c37cc32a1f50c36ec15d67fdbec3aa">Coefficient_zero</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to a Coefficient with value 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66438955854cf73ddaf27a40a69fec7b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Coefficient_one" ref="a66438955854cf73ddaf27a40a69fec7b" args="()" -->
Coefficient_traits::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a66438955854cf73ddaf27a40a69fec7b">Coefficient_one</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to a Coefficient with value 1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f5a518ab35f859aafd220bc3e38dfd"></a><!-- doxytag: member="Parma_Polyhedra_Library::isqrt" ref="a31f5a518ab35f859aafd220bc3e38dfd" args="(unsigned long x)" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a31f5a518ab35f859aafd220bc3e38dfd">isqrt</a> (unsigned long x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the integer square root of <code>x</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca6003248d614d68c07f5330b468a242"></a><!-- doxytag: member="Parma_Polyhedra_Library::max_space_dimension" ref="aca6003248d614d68c07f5330b468a242" args="()" -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#aca6003248d614d68c07f5330b468a242">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension this library can handle. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#ad6c6b997fe2c49a8098bba1b6a45a008">termination_test_MS</a> (const PSET &amp;pset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#ad6c6b997fe2c49a8098bba1b6a45a008"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a0d0db024e7accefca878d7e09d815788">termination_test_MS_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#a0d0db024e7accefca878d7e09d815788"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a0f5fece719859502d9761d128734baea">one_affine_ranking_function_MS</a> (const PSET &amp;pset, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;mu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test with witness ranking function using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#a0f5fece719859502d9761d128734baea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a02bcf74a81fe5f35657f5f006c56bb29">one_affine_ranking_function_MS_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;mu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test with witness ranking function using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#a02bcf74a81fe5f35657f5f006c56bb29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a8f608e24421a818d8e065a74425d8573">all_affine_ranking_functions_MS</a> (const PSET &amp;pset, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test with ranking function space using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#a8f608e24421a818d8e065a74425d8573"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a64ce78ed8253fa6b08455b187380805c">all_affine_ranking_functions_MS_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Termination test with ranking function space using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#a64ce78ed8253fa6b08455b187380805c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#aa6a2ae8d135b40f8bee030f76d52659c">all_affine_quasi_ranking_functions_MS</a> (const PSET &amp;pset, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;decreasing_mu_space, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;bounded_mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the spaces of affine <em>quasi</em> ranking functions using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#aa6a2ae8d135b40f8bee030f76d52659c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#aaeffe6c0f315667496085d5673d2a14c">all_affine_quasi_ranking_functions_MS_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;decreasing_mu_space, <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;bounded_mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the spaces of affine <em>quasi</em> ranking functions using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>.  <a href="#aaeffe6c0f315667496085d5673d2a14c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a83e1eb0462a99f105974ae38c55e5382"></a><!-- doxytag: member="Parma_Polyhedra_Library::termination_test_PR" ref="a83e1eb0462a99f105974ae38c55e5382" args="(const PSET &amp;pset)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a83e1eb0462a99f105974ae38c55e5382">termination_test_PR</a> (const PSET &amp;pset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#ad6c6b997fe2c49a8098bba1b6a45a008" title="Termination test using an improvement of the method by Mesnard and Serebrenik [BMPZ10]...">termination_test_MS()</a> but using the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abe0911e6125f86a771adc88932d96fc4"></a><!-- doxytag: member="Parma_Polyhedra_Library::termination_test_PR_2" ref="abe0911e6125f86a771adc88932d96fc4" args="(const PSET &amp;pset_before, const PSET &amp;pset_after)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#abe0911e6125f86a771adc88932d96fc4">termination_test_PR_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#a0d0db024e7accefca878d7e09d815788" title="Termination test using an improvement of the method by Mesnard and Serebrenik [BMPZ10]...">termination_test_MS_2()</a> but using an alternative formalization of the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afd604dc4c87ae10e8c41bceaf9eed8c3"></a><!-- doxytag: member="Parma_Polyhedra_Library::one_affine_ranking_function_PR" ref="afd604dc4c87ae10e8c41bceaf9eed8c3" args="(const PSET &amp;pset, Generator &amp;mu)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#afd604dc4c87ae10e8c41bceaf9eed8c3">one_affine_ranking_function_PR</a> (const PSET &amp;pset, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;mu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#a0f5fece719859502d9761d128734baea" title="Termination test with witness ranking function using an improvement of the method...">one_affine_ranking_function_MS()</a> but using the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a273d8b57c5c3158b59a66a98351abd09"></a><!-- doxytag: member="Parma_Polyhedra_Library::one_affine_ranking_function_PR_2" ref="a273d8b57c5c3158b59a66a98351abd09" args="(const PSET &amp;pset_before, const PSET &amp;pset_after, Generator &amp;mu)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a273d8b57c5c3158b59a66a98351abd09">one_affine_ranking_function_PR_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;mu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#a02bcf74a81fe5f35657f5f006c56bb29" title="Termination test with witness ranking function using an improvement of the method...">one_affine_ranking_function_MS_2()</a> but using an alternative formalization of the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a079a46ea302194faf75833bf0f1beb6b"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_ranking_functions_PR" ref="a079a46ea302194faf75833bf0f1beb6b" args="(const PSET &amp;pset, NNC_Polyhedron &amp;mu_space)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a079a46ea302194faf75833bf0f1beb6b">all_affine_ranking_functions_PR</a> (const PSET &amp;pset, <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#a8f608e24421a818d8e065a74425d8573" title="Termination test with ranking function space using an improvement of the method by...">all_affine_ranking_functions_MS()</a> but using the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a68ba0ee40d5b2fe4d512a046e19025d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_ranking_functions_PR_2" ref="a68ba0ee40d5b2fe4d512a046e19025d3" args="(const PSET &amp;pset_before, const PSET &amp;pset_after, NNC_Polyhedron &amp;mu_space)" -->
template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a68ba0ee40d5b2fe4d512a046e19025d3">all_affine_ranking_functions_PR_2</a> (const PSET &amp;pset_before, const PSET &amp;pset_after, <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;mu_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="namespaceParma__Polyhedra__Library.html#a64ce78ed8253fa6b08455b187380805c" title="Termination test with ranking function space using an improvement of the method by...">all_affine_ranking_functions_MS_2()</a> but using an alternative formalization of the method by Podelski and Rybalchenko <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Size Inspection Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp4947b4b1cc6c22d3f7ebe09a67d3fcda"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad4f28a7482372281b01b4221b8543bdc"></a><!-- doxytag: member="Parma_Polyhedra_Library::total_memory_in_bytes" ref="ad4f28a7482372281b01b4221b8543bdc" args="(const T &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Native&lt; T &gt;<br class="typebreak"/>
::value, <a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a> &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>total_memory_in_bytes</b> (const T &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a729bdafa0ec2ae7a6664cbdf38c09755"></a><!-- doxytag: member="Parma_Polyhedra_Library::external_memory_in_bytes" ref="a729bdafa0ec2ae7a6664cbdf38c09755" args="(const T &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Native&lt; T &gt;<br class="typebreak"/>
::value, <a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a> &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>external_memory_in_bytes</b> (const T &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563b92eac806093d3e743ea4dfcc0594"></a><!-- doxytag: member="Parma_Polyhedra_Library::total_memory_in_bytes" ref="a563b92eac806093d3e743ea4dfcc0594" args="(const mpz_class &amp;x)" -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>total_memory_in_bytes</b> (const mpz_class &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75dfd397f7fab1fe9da3eb150911853c"></a><!-- doxytag: member="Parma_Polyhedra_Library::external_memory_in_bytes" ref="a75dfd397f7fab1fe9da3eb150911853c" args="(const mpz_class &amp;x)" -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>external_memory_in_bytes</b> (const mpz_class &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a8e238a8400e68173c88d38dd8a8da"></a><!-- doxytag: member="Parma_Polyhedra_Library::total_memory_in_bytes" ref="ae6a8e238a8400e68173c88d38dd8a8da" args="(const mpq_class &amp;x)" -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>total_memory_in_bytes</b> (const mpq_class &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0719a31106af8ca454d1d1d77dbde4e"></a><!-- doxytag: member="Parma_Polyhedra_Library::external_memory_in_bytes" ref="ad0719a31106af8ca454d1d1d77dbde4e" args="(const mpq_class &amp;x)" -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>external_memory_in_bytes</b> (const mpq_class &amp;x)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Relational Operators and Comparison Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe96df5d057e76a387b165f4277ef3fe3"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afb314bce856c60de821bc388a02571f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::equal" ref="afb314bce856c60de821bc388a02571f5" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad11992da5c89caef7922c215278d03a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::not_equal" ref="ad11992da5c89caef7922c215278d03a8" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>not_equal</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a077909c2e2a30e356b03d74e287d2545"></a><!-- doxytag: member="Parma_Polyhedra_Library::greater_or_equal" ref="a077909c2e2a30e356b03d74e287d2545" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>greater_or_equal</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aec4c213c066101e1cd926125ccc4c81c"></a><!-- doxytag: member="Parma_Polyhedra_Library::greater_than" ref="aec4c213c066101e1cd926125ccc4c81c" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>greater_than</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3aa0f8a865cbe18e6202b99d388af956"></a><!-- doxytag: member="Parma_Polyhedra_Library::less_or_equal" ref="a3aa0f8a865cbe18e6202b99d388af956" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>less_or_equal</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2684e5d6c84a8e156f58121be0dbd03"></a><!-- doxytag: member="Parma_Polyhedra_Library::less_than" ref="ae2684e5d6c84a8e156f58121be0dbd03" args="(const T1 &amp;x, const T2 &amp;y)" -->
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a><br class="typebreak"/>
&lt; T2 &gt;::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>less_than</b> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input-Output Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp216b77a7647983695275cb78b12cc7d2"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bfba21dd2d808e2eabd2348e92cb96a"></a><!-- doxytag: member="Parma_Polyhedra_Library::ascii_dump" ref="a9bfba21dd2d808e2eabd2348e92cb96a" args="(std::ostream &amp;s, const T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a9bfba21dd2d808e2eabd2348e92cb96a">ascii_dump</a> (std::ostream &amp;s, const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ascii dump for native or checked. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3504c6384a7e40501e2cfc49ba870ad5"></a><!-- doxytag: member="Parma_Polyhedra_Library::ascii_load" ref="a3504c6384a7e40501e2cfc49ba870ad5" args="(std::ostream &amp;s, T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If<br class="typebreak"/>
&lt; <a class="el" href="structParma__Polyhedra__Library_1_1Is__Native__Or__Checked.html">Is_Native_Or_Checked</a>&lt; T &gt;<br class="typebreak"/>
::value, bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParma__Polyhedra__Library.html#a3504c6384a7e40501e2cfc49ba870ad5">ascii_load</a> (std::ostream &amp;s, T &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ascii load for native or checked. <br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classParma__Polyhedra__Library_1_1Throwable.html">Throwable</a> *volatile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PPL__CXX__interface.html#ga00a906832c41c42a70a5c9d194e07a7d">abandon_expensive_computations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to an exception object.  <a href="group__PPL__CXX__interface.html#ga00a906832c41c42a70a5c9d194e07a7d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The entire library is confined to this namespace. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ada2f48b1fec9c98a2ddb26953ed1cfb8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Result_Class" ref="ada2f48b1fec9c98a2ddb26953ed1cfb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceParma__Polyhedra__Library.html#ada2f48b1fec9c98a2ddb26953ed1cfb8">Parma_Polyhedra_Library::Result_Class</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ada2f48b1fec9c98a2ddb26953ed1cfb8a96b8890edb38e9960c455aa178e508ba"></a><!-- doxytag: member="VC_NORMAL" ref="ada2f48b1fec9c98a2ddb26953ed1cfb8a96b8890edb38e9960c455aa178e508ba" args="" -->VC_NORMAL</em>&nbsp;</td><td>
<p>Representable number result class. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada2f48b1fec9c98a2ddb26953ed1cfb8abd640c30f757e4ecccd08ac527536ca6"></a><!-- doxytag: member="VC_MINUS_INFINITY" ref="ada2f48b1fec9c98a2ddb26953ed1cfb8abd640c30f757e4ecccd08ac527536ca6" args="" -->VC_MINUS_INFINITY</em>&nbsp;</td><td>
<p>Negative infinity result class. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada2f48b1fec9c98a2ddb26953ed1cfb8a979f37a289d4cb316643f1dcc07ec7cd"></a><!-- doxytag: member="VC_PLUS_INFINITY" ref="ada2f48b1fec9c98a2ddb26953ed1cfb8a979f37a289d4cb316643f1dcc07ec7cd" args="" -->VC_PLUS_INFINITY</em>&nbsp;</td><td>
<p>Positive infinity result class. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada2f48b1fec9c98a2ddb26953ed1cfb8a9606fc251d767040929d3e2645dbb446"></a><!-- doxytag: member="VC_NAN" ref="ada2f48b1fec9c98a2ddb26953ed1cfb8a9606fc251d767040929d3e2645dbb446" args="" -->VC_NAN</em>&nbsp;</td><td>
<p>Not a number result class. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Result_Relation" ref="ae511c510b0e7687e7866c274f3a06a98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceParma__Polyhedra__Library.html#ae511c510b0e7687e7866c274f3a06a98">Parma_Polyhedra_Library::Result_Relation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98af4fca65e2503d4afea11aa9b9da7d51e"></a><!-- doxytag: member="VR_EMPTY" ref="ae511c510b0e7687e7866c274f3a06a98af4fca65e2503d4afea11aa9b9da7d51e" args="" -->VR_EMPTY</em>&nbsp;</td><td>
<p>No values satisfies the relation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98a9afce68d66f8c8eedec345f8df2e822f"></a><!-- doxytag: member="VR_EQ" ref="ae511c510b0e7687e7866c274f3a06a98a9afce68d66f8c8eedec345f8df2e822f" args="" -->VR_EQ</em>&nbsp;</td><td>
<p>Equal. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98ae9e9040024adaad2b7a0d9ceea0c8b62"></a><!-- doxytag: member="VR_LT" ref="ae511c510b0e7687e7866c274f3a06a98ae9e9040024adaad2b7a0d9ceea0c8b62" args="" -->VR_LT</em>&nbsp;</td><td>
<p>Less than. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98accf532c4e56a06e520b6b3f638371667"></a><!-- doxytag: member="VR_GT" ref="ae511c510b0e7687e7866c274f3a06a98accf532c4e56a06e520b6b3f638371667" args="" -->VR_GT</em>&nbsp;</td><td>
<p>Greater than. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98a9223ac459b80b2eb397dd7810be7aa07"></a><!-- doxytag: member="VR_NE" ref="ae511c510b0e7687e7866c274f3a06a98a9223ac459b80b2eb397dd7810be7aa07" args="" -->VR_NE</em>&nbsp;</td><td>
<p>Not equal. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98a44ed03f4b908d58ac405493b10be3012"></a><!-- doxytag: member="VR_LE" ref="ae511c510b0e7687e7866c274f3a06a98a44ed03f4b908d58ac405493b10be3012" args="" -->VR_LE</em>&nbsp;</td><td>
<p>Less or equal. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98a4e456df02ee601b05831536311de132c"></a><!-- doxytag: member="VR_GE" ref="ae511c510b0e7687e7866c274f3a06a98a4e456df02ee601b05831536311de132c" args="" -->VR_GE</em>&nbsp;</td><td>
<p>Greater or equal. This need to be accompanied by a value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae511c510b0e7687e7866c274f3a06a98a468389fd24e4a478d296cbcf6b104eb0"></a><!-- doxytag: member="VR_LGE" ref="ae511c510b0e7687e7866c274f3a06a98a468389fd24e4a478d296cbcf6b104eb0" args="" -->VR_LGE</em>&nbsp;</td><td>
<p>All values satisfy the relation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766"></a><!-- doxytag: member="Parma_Polyhedra_Library::I_Result" ref="a1c146f8a7a8bb517f38dad49696f2766" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">Parma_Polyhedra_Library::I_Result</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a3388ff37939783f337c4aeca28873c8a"></a><!-- doxytag: member="I_EMPTY" ref="a1c146f8a7a8bb517f38dad49696f2766a3388ff37939783f337c4aeca28873c8a" args="" -->I_EMPTY</em>&nbsp;</td><td>
<p>The resulting set may be empty. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766ad57704b5d1b446fc9840009f06a5cb49"></a><!-- doxytag: member="I_SINGLETON" ref="a1c146f8a7a8bb517f38dad49696f2766ad57704b5d1b446fc9840009f06a5cb49" args="" -->I_SINGLETON</em>&nbsp;</td><td>
<p>The resulting set may have only one value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766ad2496277dd6e1de91ca84a903ed28b64"></a><!-- doxytag: member="I_SOME" ref="a1c146f8a7a8bb517f38dad49696f2766ad2496277dd6e1de91ca84a903ed28b64" args="" -->I_SOME</em>&nbsp;</td><td>
<p>The resulting set may have more than one value and to be not the domain universe. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a16951436466647aef85cdd1f567200af"></a><!-- doxytag: member="I_UNIVERSE" ref="a1c146f8a7a8bb517f38dad49696f2766a16951436466647aef85cdd1f567200af" args="" -->I_UNIVERSE</em>&nbsp;</td><td>
<p>The resulting set may be the domain universe. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766ada806236c55c963a0f138b67310de3b8"></a><!-- doxytag: member="I_NOT_EMPTY" ref="a1c146f8a7a8bb517f38dad49696f2766ada806236c55c963a0f138b67310de3b8" args="" -->I_NOT_EMPTY</em>&nbsp;</td><td>
<p>The resulting set is not empty. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a3bdee6d73627cc8338fb846f4a1fa935"></a><!-- doxytag: member="I_ANY" ref="a1c146f8a7a8bb517f38dad49696f2766a3bdee6d73627cc8338fb846f4a1fa935" args="" -->I_ANY</em>&nbsp;</td><td>
<p>The resulting set may be empty or not empty. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a00b00eff42cb35b0009a39ceb4202ac6"></a><!-- doxytag: member="I_NOT_UNIVERSE" ref="a1c146f8a7a8bb517f38dad49696f2766a00b00eff42cb35b0009a39ceb4202ac6" args="" -->I_NOT_UNIVERSE</em>&nbsp;</td><td>
<p>The resulting set may be empty or not empty. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a517be2ee42ead94cbef7d4ec632500ea"></a><!-- doxytag: member="I_NOT_DEGENERATE" ref="a1c146f8a7a8bb517f38dad49696f2766a517be2ee42ead94cbef7d4ec632500ea" args="" -->I_NOT_DEGENERATE</em>&nbsp;</td><td>
<p>The resulting set can'be empty or the domain universe. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766adb4b733a5edc79c83812093b2d020952"></a><!-- doxytag: member="I_EXACT" ref="a1c146f8a7a8bb517f38dad49696f2766adb4b733a5edc79c83812093b2d020952" args="" -->I_EXACT</em>&nbsp;</td><td>
<p>The resulting set is definitely exact. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a5e739a5468d529a02f4248c77a4776a7"></a><!-- doxytag: member="I_INEXACT" ref="a1c146f8a7a8bb517f38dad49696f2766a5e739a5468d529a02f4248c77a4776a7" args="" -->I_INEXACT</em>&nbsp;</td><td>
<p>The resulting set is definitely inexact. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a4fbc5cd99bd48b3a521a9f2c5e7b0c00"></a><!-- doxytag: member="I_CHANGED" ref="a1c146f8a7a8bb517f38dad49696f2766a4fbc5cd99bd48b3a521a9f2c5e7b0c00" args="" -->I_CHANGED</em>&nbsp;</td><td>
<p>The operation has definitely changed the set. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a3181ff1b549af004ba60f7c664037192"></a><!-- doxytag: member="I_UNCHANGED" ref="a1c146f8a7a8bb517f38dad49696f2766a3181ff1b549af004ba60f7c664037192" args="" -->I_UNCHANGED</em>&nbsp;</td><td>
<p>The operation has left the set definitely unchanged. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1c146f8a7a8bb517f38dad49696f2766a78a1e232394b81ca2319e8f3f066e377"></a><!-- doxytag: member="I_SINGULARITIES" ref="a1c146f8a7a8bb517f38dad49696f2766a78a1e232394b81ca2319e8f3f066e377" args="" -->I_SINGULARITIES</em>&nbsp;</td><td>
<p>The operation is undefined for some combination of values. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aee4e9b54e65780ac3010fda40ea235a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::banner" ref="aee4e9b54e65780ac3010fda40ea235a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Parma_Polyhedra_Library::banner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a character string containing the PPL banner. </p>
<p>The banner provides information about the PPL version, the licensing, the lack of any warranty whatsoever, the C++ compiler used to build the library, where to report bugs and where to look for further information. </p>

</div>
</div>
<a class="anchor" id="a63bd7c7767faf3c219f9c2762095e2dd"></a><!-- doxytag: member="Parma_Polyhedra_Library::set_rounding_for_PPL" ref="a63bd7c7767faf3c219f9c2762095e2dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::set_rounding_for_PPL </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the FPU rounding mode so that the PPL abstractions based on floating point numbers work correctly. </p>
<p>This is performed automatically at initialization-time. Calling this function is needed only if <a class="el" href="namespaceParma__Polyhedra__Library.html#a6c841f33162c2419bd53a078e6c788ee" title="Sets the FPU rounding mode as it was before initialization of the PPL.">restore_pre_PPL_rounding()</a> has been previously called. </p>

</div>
</div>
<a class="anchor" id="a6c841f33162c2419bd53a078e6c788ee"></a><!-- doxytag: member="Parma_Polyhedra_Library::restore_pre_PPL_rounding" ref="a6c841f33162c2419bd53a078e6c788ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::restore_pre_PPL_rounding </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the FPU rounding mode as it was before initialization of the PPL. </p>
<p>After calling this function it is absolutely necessary to call <a class="el" href="namespaceParma__Polyhedra__Library.html#a63bd7c7767faf3c219f9c2762095e2dd" title="Sets the FPU rounding mode so that the PPL abstractions based on floating point numbers...">set_rounding_for_PPL()</a> before using any PPL abstractions based on floating point numbers. This is performed automatically at finalization-time. </p>

</div>
</div>
<a class="anchor" id="a19b0ebdb3476fe1feb0f51d9328fd384"></a><!-- doxytag: member="Parma_Polyhedra_Library::fpu_check_inexact" ref="a19b0ebdb3476fe1feb0f51d9328fd384" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Parma_Polyhedra_Library::fpu_check_inexact </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the <em>inexact computation</em> status. </p>
<p>Returns 0 if the computation was definitely exact, 1 if it was definitely inexact, -1 if definite exactness information is unavailable. </p>

</div>
</div>
<a class="anchor" id="abdd9791a8d91b11a5bd3a6ef0770bc86"></a><!-- doxytag: member="Parma_Polyhedra_Library::set_irrational_precision" ref="abdd9791a8d91b11a5bd3a6ef0770bc86" args="(const unsigned p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::set_irrational_precision </td>
          <td>(</td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the precision parameter used for irrational calculations. </p>
<p>The lesser between numerator and denominator is limited to 2**<code>p</code>.</p>
<p>If <code>p</code> is less than or equal to <code>INT_MAX</code>, sets the precision parameter used for irrational calculations to <code>p</code>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>p</code> is greater than <code>INT_MAX</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6c6b997fe2c49a8098bba1b6a45a008"></a><!-- doxytag: member="Parma_Polyhedra_Library::termination_test_MS" ref="ad6c6b997fe2c49a8098bba1b6a45a008" args="(const PSET &amp;pset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::termination_test_MS </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset</em>&nbsp;</td><td>A pointset approximating the behavior of a loop whose termination is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
<p>where unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if any loop approximated by <code>pset</code> definitely terminates; <code>false</code> if the test is inconclusive. However, if <code>pset</code> <em>precisely</em> characterizes the effect of the loop body onto the loop-relevant program variables, then <code>true</code> is returned <em>if and only if</em> the loop terminates. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0db024e7accefca878d7e09d815788"></a><!-- doxytag: member="Parma_Polyhedra_Library::termination_test_MS_2" ref="a0d0db024e7accefca878d7e09d815788" args="(const PSET &amp;pset_before, const PSET &amp;pset_after)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::termination_test_MS_2 </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_after</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset_before</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>before</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pset_after</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>after</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update. Note also that unprimed variables are assigned to different space dimensions in <code>pset_before</code> and <code>pset_after</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if any loop approximated by <code>pset</code> definitely terminates; <code>false</code> if the test is inconclusive. However, if <code>pset_before</code> and <code>pset_after</code> <em>precisely</em> characterize the effect of the loop body onto the loop-relevant program variables, then <code>true</code> is returned <em>if and only if</em> the loop terminates. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f5fece719859502d9761d128734baea"></a><!-- doxytag: member="Parma_Polyhedra_Library::one_affine_ranking_function_MS" ref="a0f5fece719859502d9761d128734baea" args="(const PSET &amp;pset, Generator &amp;mu)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::one_affine_ranking_function_MS </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test with witness ranking function using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset</em>&nbsp;</td><td>A pointset approximating the behavior of a loop whose termination is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
<p>where unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mu</em>&nbsp;</td><td>When <code>true</code> is returned, this is assigned a point of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> encoding one (not further specified) affine ranking function for the loop being analyzed. The ranking function is of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> are the coefficients of <code>mu</code> corresponding to the space dimensions <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if any loop approximated by <code>pset</code> definitely terminates; <code>false</code> if the test is inconclusive. However, if <code>pset</code> <em>precisely</em> characterizes the effect of the loop body onto the loop-relevant program variables, then <code>true</code> is returned <em>if and only if</em> the loop terminates. </dd></dl>

</div>
</div>
<a class="anchor" id="a02bcf74a81fe5f35657f5f006c56bb29"></a><!-- doxytag: member="Parma_Polyhedra_Library::one_affine_ranking_function_MS_2" ref="a02bcf74a81fe5f35657f5f006c56bb29" args="(const PSET &amp;pset_before, const PSET &amp;pset_after, Generator &amp;mu)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::one_affine_ranking_function_MS_2 </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator &amp;&nbsp;</td>
          <td class="paramname"> <em>mu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test with witness ranking function using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset_before</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>before</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pset_after</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>after</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update. Note also that unprimed variables are assigned to different space dimensions in <code>pset_before</code> and <code>pset_after</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mu</em>&nbsp;</td><td>When <code>true</code> is returned, this is assigned a point of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> encoding one (not further specified) affine ranking function for the loop being analyzed. The ranking function is of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> are the coefficients of <code>mu</code> corresponding to the space dimensions <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if any loop approximated by <code>pset</code> definitely terminates; <code>false</code> if the test is inconclusive. However, if <code>pset_before</code> and <code>pset_after</code> <em>precisely</em> characterize the effect of the loop body onto the loop-relevant program variables, then <code>true</code> is returned <em>if and only if</em> the loop terminates. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f608e24421a818d8e065a74425d8573"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_ranking_functions_MS" ref="a8f608e24421a818d8e065a74425d8573" args="(const PSET &amp;pset, C_Polyhedron &amp;mu_space)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::all_affine_ranking_functions_MS </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>mu_space</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test with ranking function space using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset</em>&nbsp;</td><td>A pointset approximating the behavior of a loop whose termination is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
<p>where unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the affine ranking functions for the loops that are precisely characterized by <code>pset</code>. These ranking functions are of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> identify any point of the <code>mu_space</code> polyhedron. The variables <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> correspond to the space dimensions of <code>mu_space</code> <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively. When <code>mu_space</code> is empty, it means that the test is inconclusive. However, if <code>pset</code> <em>precisely</em> characterizes the effect of the loop body onto the loop-relevant program variables, then <code>mu_space</code> is empty <em>if and only if</em> the loop does <em>not</em> terminate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64ce78ed8253fa6b08455b187380805c"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_ranking_functions_MS_2" ref="a64ce78ed8253fa6b08455b187380805c" args="(const PSET &amp;pset_before, const PSET &amp;pset_after, C_Polyhedron &amp;mu_space)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::all_affine_ranking_functions_MS_2 </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>mu_space</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Termination test with ranking function space using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset_before</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>before</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pset_after</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>after</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update. Note also that unprimed variables are assigned to different space dimensions in <code>pset_before</code> and <code>pset_after</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the affine ranking functions for the loops that are precisely characterized by <code>pset</code>. These ranking functions are of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> identify any point of the <code>mu_space</code> polyhedron. The variables <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> correspond to the space dimensions of <code>mu_space</code> <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively. When <code>mu_space</code> is empty, it means that the test is inconclusive. However, if <code>pset_before</code> and <code>pset_after</code> <em>precisely</em> characterize the effect of the loop body onto the loop-relevant program variables, then <code>mu_space</code> is empty <em>if and only if</em> the loop does <em>not</em> terminate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6a2ae8d135b40f8bee030f76d52659c"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_quasi_ranking_functions_MS" ref="aa6a2ae8d135b40f8bee030f76d52659c" args="(const PSET &amp;pset, C_Polyhedron &amp;decreasing_mu_space, C_Polyhedron &amp;bounded_mu_space)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::all_affine_quasi_ranking_functions_MS </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>decreasing_mu_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>bounded_mu_space</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the spaces of affine <em>quasi</em> ranking functions using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset</em>&nbsp;</td><td>A pointset approximating the behavior of a loop whose termination is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
<p>where unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decreasing_mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the decreasing affine functions for the loops that are precisely characterized by <code>pset</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounded_mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the lower bounded affine functions for the loops that are precisely characterized by <code>pset</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>These quasi-ranking functions are of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> identify any point of the <code>decreasing_mu_space</code> and <code>bounded_mu_space</code> polyhedrons. The variables <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> correspond to the space dimensions <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively. When <code>decreasing_mu_space</code> (resp., <code>bounded_mu_space</code>) is empty, it means that the test is inconclusive. However, if <code>pset</code> <em>precisely</em> characterizes the effect of the loop body onto the loop-relevant program variables, then <code>decreasing_mu_space</code> (resp., <code>bounded_mu_space</code>) will be empty <em>if and only if</em> there is no decreasing (resp., lower bounded) affine function, so that the loop does not terminate. </p>

</div>
</div>
<a class="anchor" id="aaeffe6c0f315667496085d5673d2a14c"></a><!-- doxytag: member="Parma_Polyhedra_Library::all_affine_quasi_ranking_functions_MS_2" ref="aaeffe6c0f315667496085d5673d2a14c" args="(const PSET &amp;pset_before, const PSET &amp;pset_after, C_Polyhedron &amp;decreasing_mu_space, C_Polyhedron &amp;bounded_mu_space)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::all_affine_quasi_ranking_functions_MS_2 </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PSET &amp;&nbsp;</td>
          <td class="paramname"> <em>pset_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>decreasing_mu_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Polyhedron &amp;&nbsp;</td>
          <td class="paramname"> <em>bounded_mu_space</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the spaces of affine <em>quasi</em> ranking functions using an improvement of the method by Mesnard and Serebrenik <a class="el" href="main.html#BMPZ10">[BMPZ10]</a>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PSET</em>&nbsp;</td><td>Any pointset supported by the PPL that provides the <code>minimized_constraints()</code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pset_before</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>before</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pset_after</em>&nbsp;</td><td>A pointset approximating the values of loop-relevant variables <em>after</em> the update performed in the loop body that is being analyzed. The variables indices are allocated as follows:</p>
<ul>
<li><img class="formulaInl" alt="$ x'_1, \ldots, x'_n $" src="form_746.png"/> go onto space dimensions <img class="formulaInl" alt="$ 0, \ldots, n-1 $" src="form_747.png"/>,</li>
<li><img class="formulaInl" alt="$ x_1, \ldots, x_n $" src="form_748.png"/> go onto space dimensions <img class="formulaInl" alt="$ n, \ldots, 2n-1 $" src="form_749.png"/>,</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unprimed variables represent the values of the loop-relevant program variables before the update performed in the loop body, and primed variables represent the values of those program variables after the update. Note also that unprimed variables are assigned to different space dimensions in <code>pset_before</code> and <code>pset_after</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decreasing_mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the decreasing affine functions for the loops that are precisely characterized by <code>pset</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounded_mu_space</em>&nbsp;</td><td>This is assigned a closed polyhedron of space dimension <img class="formulaInl" alt="$ n+1 $" src="form_750.png"/> representing the space of all the lower bounded affine functions for the loops that are precisely characterized by <code>pset</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>These ranking functions are of the form <img class="formulaInl" alt="$ \mu_0 + \sum_{i=1}^n \mu_i x_i $" src="form_751.png"/> where <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> identify any point of the <code>decreasing_mu_space</code> and <code>bounded_mu_space</code> polyhedrons. The variables <img class="formulaInl" alt="$ \mu_0, \mu_1, \ldots, \mu_n $" src="form_752.png"/> correspond to the space dimensions <img class="formulaInl" alt="$ n, 0, \ldots, n-1 $" src="form_753.png"/>, respectively. When <code>decreasing_mu_space</code> (resp., <code>bounded_mu_space</code>) is empty, it means that the test is inconclusive. However, if <code>pset_before</code> and <code>pset_after</code> <em>precisely</em> characterize the effect of the loop body onto the loop-relevant program variables, then <code>decreasing_mu_space</code> (resp., <code>bounded_mu_space</code>) will be empty <em>if and only if</em> there is no decreasing (resp., lower bounded) affine function, so that the loop does not terminate. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Feb 27 10:10:57 2011 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
