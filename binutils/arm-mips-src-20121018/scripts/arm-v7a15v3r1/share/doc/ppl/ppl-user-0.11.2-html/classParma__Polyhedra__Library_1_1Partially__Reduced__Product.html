<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Partially_Reduced_Product" -->
<p>The partially reduced product of two abstractions.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a6713cca018bed4091ffafb98ca4833d0">Partially_Reduced_Product</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an object having the specified properties.  <a href="#a6713cca018bed4091ffafb98ca4833d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a28f6854a94a3a7d58034cb1d51ae9c7c">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, copying a system of congruences.  <a href="#a28f6854a94a3a7d58034cb1d51ae9c7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4857c775f03d5b4ff084723eed2b5e31">Partially_Reduced_Product</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, recycling a system of congruences.  <a href="#a4857c775f03d5b4ff084723eed2b5e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1daec40615d5a93ce0de360865d93497">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, copying a system of constraints.  <a href="#a1daec40615d5a93ce0de360865d93497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#abc31d844172a202d43d08e299e26322f">Partially_Reduced_Product</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a pair, recycling a system of constraints.  <a href="#abc31d844172a202d43d08e299e26322f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ad3eb603756ab7be783cd92410ac7aed7">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from a C polyhedron.  <a href="#ad3eb603756ab7be783cd92410ac7aed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adca9874a75b5ba09114b8495a23c4edd">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from an NNC polyhedron.  <a href="#adca9874a75b5ba09114b8495a23c4edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aef3ebc0ed74af80cd3653321153360bd">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;gr, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product, from a grid.  <a href="#aef3ebc0ed74af80cd3653321153360bd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2b4e2b95a505c70e40370e121cd179a4">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of a box.  <a href="#a2b4e2b95a505c70e40370e121cd179a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ab95eae83384d8c6b41b9ed8f9fd16704">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of a BD shape.  <a href="#ab95eae83384d8c6b41b9ed8f9fd16704"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2b3eb71543b3284872781f0b4481fe39">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a product out of an octagonal shape.  <a href="#a2b3eb71543b3284872781f0b4481fe39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b5db50d397654bd1a8d4067d90f7419"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a3b5db50d397654bd1a8d4067d90f7419" args="(const Partially_Reduced_Product &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3b5db50d397654bd1a8d4067d90f7419">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy constructor. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 , typename S &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a8cdc72dfa85aed4e613f780b02e69e92">Partially_Reduced_Product</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; E1, E2, S &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#a8cdc72dfa85aed4e613f780b02e69e92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a187bdab1051f58af280af66645ce1fed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator=" ref="a187bdab1051f58af280af66645ce1fed" args="(const Partially_Reduced_Product &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a187bdab1051f58af280af66645ce1fed">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3ad0a7ad694f4a7724504544aff49fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::reduce" ref="ab3ad0a7ad694f4a7724504544aff49fa" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ab3ad0a7ad694f4a7724504544aff49fa">reduce</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Partially_Reduced_Product</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp54cab36b0b215926ab92a068831294c0"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a5f3efb1fe599046d2ed48223bfa41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::space_dimension" ref="a38a5f3efb1fe599046d2ed48223bfa41" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a38a5f3efb1fe599046d2ed48223bfa41">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f912e8b181561f68062e183005c8bc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_dimension" ref="a46f912e8b181561f68062e183005c8bc" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a46f912e8b181561f68062e183005c8bc">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimum <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> (see also <a class="el" href="main.html#Grid_Affine_Dimension">grid affine dimension</a>) of the components of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2583843b139ce11b842155b35d60332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::domain1" ref="ac2583843b139ce11b842155b35d60332" args="() const " -->
const D1 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ac2583843b139ce11b842155b35d60332">domain1</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the first of the pair. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a294875fd6b469d8949f08c24b5893b6e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::domain2" ref="a294875fd6b469d8949f08c24b5893b6e" args="() const " -->
const D2 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a294875fd6b469d8949f08c24b5893b6e">domain2</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the second of the pair. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc5b9db43a16365ba0773a96fe1b799"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::constraints" ref="a1dc5b9db43a16365ba0773a96fe1b799" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1dc5b9db43a16365ba0773a96fe1b799">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of constraints which approximates <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe458f016db5eeeb95bee46f1800533"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimized_constraints" ref="a2fe458f016db5eeeb95bee46f1800533" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2fe458f016db5eeeb95bee46f1800533">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of constraints which approximates <code>*this</code>, in reduced form. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd361a7c7e187c0ff63c62894e741f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::congruences" ref="a6bd361a7c7e187c0ff63c62894e741f8" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a6bd361a7c7e187c0ff63c62894e741f8">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of congruences which approximates <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425f248891aec4ed7800bd92334fd7c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimized_congruences" ref="a425f248891aec4ed7800bd92334fd7c1" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a425f248891aec4ed7800bd92334fd7c1">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of congruences which approximates <code>*this</code>, in reduced form. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8d0378d1cb13b5ddc04dd12cf18ebe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="acc8d0378d1cb13b5ddc04dd12cf18ebe" args="(const Constraint &amp;c) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#acc8d0378d1cb13b5ddc04dd12cf18ebe">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>c</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3be7b3a04406453631aef24b817565a5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="a3be7b3a04406453631aef24b817565a5" args="(const Congruence &amp;cg) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3be7b3a04406453631aef24b817565a5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>cg</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3e2a76d26bef272d0a13fa3bae9a5c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::relation_with" ref="ad3e2a76d26bef272d0a13fa3bae9a5c2" args="(const Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ad3e2a76d26bef272d0a13fa3bae9a5c2">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad10819182a33870e4b0a7e3b2bca564"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_empty" ref="aad10819182a33870e4b0a7e3b2bca564" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aad10819182a33870e4b0a7e3b2bca564">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if either of the components of <code>*this</code> are empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1190fcf4794305386f8475f9ac51ce00"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_universe" ref="a1190fcf4794305386f8475f9ac51ce00" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1190fcf4794305386f8475f9ac51ce00">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if both of the components of <code>*this</code> are the universe. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c9a9dc63e253ac5ed21cbdad4e2640"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_topologically_closed" ref="a41c9a9dc63e253ac5ed21cbdad4e2640" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a41c9a9dc63e253ac5ed21cbdad4e2640">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if both of the components of <code>*this</code> are topologically closed subsets of the vector space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adb466cb206f1d16d24257a838d130cf2">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are componentwise disjoint.  <a href="#adb466cb206f1d16d24257a838d130cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7bd95cb0014251d60d1fd82c1d3932"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_discrete" ref="adf7bd95cb0014251d60d1fd82c1d3932" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adf7bd95cb0014251d60d1fd82c1d3932">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if a component of <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb7b94b681c4d195080fa81ed1480cc2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_bounded" ref="afb7b94b681c4d195080fa81ed1480cc2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#afb7b94b681c4d195080fa81ed1480cc2">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if a component of <code>*this</code> is bounded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ae386245235cada70fc797b0747b0d326">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#ae386245235cada70fc797b0747b0d326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a99dc4fb442b60dc9c694d7abc853a3dc">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#a99dc4fb442b60dc9c694d7abc853a3dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aa8128b9910f31bc963842e48c44a863e">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#aa8128b9910f31bc963842e48c44a863e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3a03cd3ea1b11c1c8dbdf462959d79df">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#a3a03cd3ea1b11c1c8dbdf462959d79df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a6d33d9f1d987efe6e333c7ad1993dd5a">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#a6d33d9f1d987efe6e333c7ad1993dd5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ab73df10027395d3b2c9fbd3f3e77944e">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below i <code>*this</code>, in which case the infimum value is computed.  <a href="#ab73df10027395d3b2c9fbd3f3e77944e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a5358c9f367ad37e650d411ab5e558e50">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a5358c9f367ad37e650d411ab5e558e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a888509fe116790d0b9a267e614be10ec">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if each component of <code>*this</code> contains the corresponding component of <code>y</code>.  <a href="#a888509fe116790d0b9a267e614be10ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a78e60691cfc6b6b52a34cc7952380a84">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if each component of <code>*this</code> strictly contains the corresponding component of <code>y</code>.  <a href="#a78e60691cfc6b6b52a34cc7952380a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d30675a3c28980af0f087b06a1f4c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::OK" ref="a41d30675a3c28980af0f087b06a1f4c1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a41d30675a3c28980af0f087b06a1f4c1">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Partially_Reduced_Product</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb2f6c377935037d0d3b9aba03b2c9624"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#affd7d0678df82882b006ea7b02771f98">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds constraint <code>c</code> to <code>*this</code>.  <a href="#affd7d0678df82882b006ea7b02771f98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ac6434b8a020aeda5828830fd4b639277">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the constraint <code>c</code> to refine <code>*this</code>.  <a href="#ac6434b8a020aeda5828830fd4b639277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ad3a8f10409a9fd73afb6691686d6862c">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>.  <a href="#ad3a8f10409a9fd73afb6691686d6862c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a201ee4c814267695f31b30be833917bf">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#a201ee4c814267695f31b30be833917bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1d52cb88936eb0f5bde559b39f8ec42c">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>.  <a href="#a1d52cb88936eb0f5bde559b39f8ec42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#afaf0bc4f0e0a036dbc3852b3e4490243">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#afaf0bc4f0e0a036dbc3852b3e4490243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aea7119974f9313e4c93908a2955c4186">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to *this.  <a href="#aea7119974f9313e4c93908a2955c4186"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a0c2c96efcf10102068f754c608a12427">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the constraint system in <code>cs</code> to <code>*this</code>.  <a href="#a0c2c96efcf10102068f754c608a12427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3a031a8e65176b8bd80d2857bd9a68b6">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#a3a031a8e65176b8bd80d2857bd9a68b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aafc9294d3fb5f2c0fd8d4e4d22c283b6">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraint system in <code>cs</code> to <code>*this</code>.  <a href="#aafc9294d3fb5f2c0fd8d4e4d22c283b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a7ea45b608af772cd69e2c23d7d62a3cf">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#a7ea45b608af772cd69e2c23d7d62a3cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ac238f59379434b7fbfd7dccd74be1cd6">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#ac238f59379434b7fbfd7dccd74be1cd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a676b331ee61606b74be4cd1f90756839">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the componentwise intersection of <code>*this</code> and <code>y</code>.  <a href="#a676b331ee61606b74be4cd1f90756839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a0ea21bf85aa2e90c449435cfedcef181">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components.  <a href="#a0ea21bf85aa2e90c449435cfedcef181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adb0fa15c5f30fc4be6a94ce2606208ef">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. If it is exact on each of the components of <code>*this</code>, <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#adb0fa15c5f30fc4be6a94ce2606208ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a15b21e990e26976e615a7d3244ed843e">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> an approximation of the set-theoretic difference of <code>*this</code> and <code>y</code>.  <a href="#a15b21e990e26976e615a7d3244ed843e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a8b2ee24610cb804238f33581093948c1">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a8b2ee24610cb804238f33581093948c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a7999968db9fb568980215d2c84393358">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a7999968db9fb568980215d2c84393358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#abb5709426ac80aa0bcf907b4f1d4a577">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code> (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#abb5709426ac80aa0bcf907b4f1d4a577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ac7b41dba5d22086cb9715c3f51248f98">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#ac7b41dba5d22086cb9715c3f51248f98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a97cc0d02a88d52e79cbb6615a3bbab42">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#a97cc0d02a88d52e79cbb6615a3bbab42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2c47f2f619b1d0f322b742891920735f">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.).  <a href="#a2c47f2f619b1d0f322b742891920735f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ae274e65fc3f012ab21bcffa3177228c5">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#ae274e65fc3f012ab21bcffa3177228c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a732e7355673aa63a2fc22a470a36f707">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a732e7355673aa63a2fc22a470a36f707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a77a2a8e38120a21ac0d5f19eb6e1668b">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. (See also <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a>.).  <a href="#a77a2a8e38120a21ac0d5f19eb6e1668b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a940db627ef73d29e63fed31acc7553f7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::topological_closure_assign" ref="a940db627ef73d29e63fed31acc7553f7" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a940db627ef73d29e63fed31acc7553f7">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a99247c74022e8d51cd0a2d93a87bcfe5">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the "widening" between <code>*this</code> and <code>y</code>.  <a href="#a99247c74022e8d51cd0a2d93a87bcfe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ae8be1647844c9837446b9c735f11672b">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#ae8be1647844c9837446b9c735f11672b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a640fe823a102e14522990200193c6701">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#a640fe823a102e14522990200193c6701"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdcf1aae9cb4981dcc30009fc252e5e2a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2f90e70dbef264e99b7015c0ce7e16fd">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and embeds the components of <code>*this</code> in the new vector space.  <a href="#a2f90e70dbef264e99b7015c0ce7e16fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a19a2fb28254bc142e01f3ee00c27ea89">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and does not embed the components in the new vector space.  <a href="#a19a2fb28254bc142e01f3ee00c27ea89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ac5ec610fb42e16beaac59b537a71f187">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to the first (resp., second) component of <code>*this</code> the "concatenation" of the first (resp., second) components of <code>*this</code> and <code>y</code>, taken in this order. See also <a class="el" href="main.html#Concatenating_Polyhedra">Concatenating Polyhedra</a>.  <a href="#ac5ec610fb42e16beaac59b537a71f187"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#af633b1416a118a2ac3146ec4a4fd4298">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#af633b1416a118a2ac3146ec4a4fd4298"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adfe66b5a34b84fcf63d1a48777f68e4d">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#adfe66b5a34b84fcf63d1a48777f68e4d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1ae424886d05361c1a78c89dbdd5b7db">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#a1ae424886d05361c1a78c89dbdd5b7db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a7a1f9b31c3ed7dc3e7691b9110ddbedb">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a7a1f9b31c3ed7dc3e7691b9110ddbedb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3cad64f36f7df128cc7637c9e0910bf1">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#a3cad64f36f7df128cc7637c9e0910bf1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e8eeaccd742ab8c555ed9dc7dd0ea9d"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbcc65a843515d547f055b687d1e6d5f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::~Partially_Reduced_Product" ref="acbcc65a843515d547f055b687d1e6d5f" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#acbcc65a843515d547f055b687d1e6d5f">~Partially_Reduced_Product</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd884fea397d9d6cde6426e6f47cc4e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::swap" ref="a9bd884fea397d9d6cde6426e6f47cc4e" args="(Partially_Reduced_Product &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a9bd884fea397d9d6cde6426e6f47cc4e">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with product <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57fc3d9d838fd7e20e80806307452a91"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_dump" ref="a57fc3d9d838fd7e20e80806307452a91" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a57fc3d9d838fd7e20e80806307452a91">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a864135634ed49de1aeae3b38ed933a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_dump" ref="a9a864135634ed49de1aeae3b38ed933a" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a9a864135634ed49de1aeae3b38ed933a">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885e896b320d1f4285b5dc92a20f8884"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::print" ref="a885e896b320d1f4285b5dc92a20f8884" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a885e896b320d1f4285b5dc92a20f8884">print</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a804363984fe210abe47624522dfb7a92"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::ascii_load" ref="a804363984fe210abe47624522dfb7a92" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a804363984fe210abe47624522dfb7a92">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a9a864135634ed49de1aeae3b38ed933a" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adea57326388915780370a677453778b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::total_memory_in_bytes" ref="adea57326388915780370a677453778b3" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#adea57326388915780370a677453778b3">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb19423295d8af4d69f144fc227128f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::external_memory_in_bytes" ref="a8eb19423295d8af4d69f144fc227128f" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a8eb19423295d8af4d69f144fc227128f">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#af191b9781c37da15b49810d47a838823">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#af191b9781c37da15b49810d47a838823"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a53183970490595ac39c8c070601c6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::max_space_dimension" ref="a4a53183970490595ac39c8c070601c6f" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4a53183970490595ac39c8c070601c6f">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension this product can handle. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a343e039e48425126b187827066d12bf2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Domain1" ref="a343e039e48425126b187827066d12bf2" args="" -->
typedef D1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a343e039e48425126b187827066d12bf2">Domain1</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the first component. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac4e4131c756f0ffce85b9dec7d2b3a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Domain2" ref="a4ac4e4131c756f0ffce85b9dec7d2b3a" args="" -->
typedef D2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4ac4e4131c756f0ffce85b9dec7d2b3a">Domain2</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the second component. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b8f7e6fdd123f510ba85f4527bdee3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::clear_reduced_flag" ref="ab3b8f7e6fdd123f510ba85f4527bdee3" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ab3b8f7e6fdd123f510ba85f4527bdee3">clear_reduced_flag</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the reduced flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a269f357fca785afae3774b1e084d9b93"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::set_reduced_flag" ref="a269f357fca785afae3774b1e084d9b93" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a269f357fca785afae3774b1e084d9b93">set_reduced_flag</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the reduced flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a9e355a53ec45a5a60213fa8c24f2e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_reduced" ref="a21a9e355a53ec45a5a60213fa8c24f2e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a21a9e355a53ec45a5a60213fa8c24f2e">is_reduced</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if and only if the reduced flag is set. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43ab45399b7e22ffcd6403b7e59a473c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::d1" ref="a43ab45399b7e22ffcd6403b7e59a473c" args="" -->
D1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a43ab45399b7e22ffcd6403b7e59a473c">d1</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first component. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d12805af932544a4fc1575f8db62a3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::d2" ref="a2d12805af932544a4fc1575f8db62a3d" args="" -->
D2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a2d12805af932544a4fc1575f8db62a3d">d2</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The second component. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a8683afd33a1d57db43c9db16de1f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::reduced" ref="aa2a8683afd33a1d57db43c9db16de1f5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#aa2a8683afd33a1d57db43c9db16de1f5">reduced</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to record whether the components are reduced with respect to each other and the reduction class. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#ade7792cb469ddf1d5d8944bbe7f1f55a">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are pairwise equal.  <a href="#ade7792cb469ddf1d5d8944bbe7f1f55a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a3a18eff42a557fd87d59895399c7a13f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;dp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#a3a18eff42a557fd87d59895399c7a13f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a7a9afaf958c6f9dd09c89bd706dc09b0">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are not pairwise equal.  <a href="#a7a9afaf958c6f9dd09c89bd706dc09b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a0e39243c24d99f8d374f9c14e3da8d98">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a0e39243c24d99f8d374f9c14e3da8d98"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename D1, typename D2, typename R&gt;<br/>
 class Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt;</h3>

<p>The partially reduced product of two abstractions. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>At present, the supported instantiations for the two domain templates <code>D1</code> and <code>D2</code> are the simple pointset domains: <code><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a></code>, <code>Octagonal_Shape&lt;T&gt;</code>, <code>BD_Shape&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>.</dd></dl>
<p>An object of the class <code>Partially_Reduced_Product&lt;D1, D2, R&gt;</code> represents the (partially reduced) product of two pointset domains <code>D1</code> and <code>D2</code> where the form of any reduction is defined by the reduction class <code>R</code>.</p>
<p>Suppose <img class="formulaInl" alt="$D_1$" src="form_596.png"/> and <img class="formulaInl" alt="$D_2$" src="form_597.png"/> are two abstract domains with concretization functions: <img class="formulaInl" alt="$\fund{\gamma_1}{D_1}{\Rset^n}$" src="form_598.png"/> and <img class="formulaInl" alt="$\fund{\gamma_2}{D_2}{\Rset^n}$" src="form_599.png"/>, respectively.</p>
<p>The partially reduced product <img class="formulaInl" alt="$D = D_1 \times D_2$" src="form_600.png"/>, for any reduction class <code>R</code>, has a concretization <img class="formulaInl" alt="$\fund{\gamma}{D}{\Rset^n}$" src="form_601.png"/> where, if <img class="formulaInl" alt="$d = (d_1, d_2) \in D$" src="form_602.png"/> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma(d) = \gamma_1(d_1) \inters \gamma_2(d_2). \]" src="form_603.png"/>
</p>
<p>The operations are defined to be the result of applying the corresponding operations on each of the components provided the product is already reduced by the reduction method defined by <code>R</code>. In particular, if <code>R</code> is the <code>No_Reduction&lt;D1, D2&gt;</code> class, then the class <code>Partially_Reduced_Product&lt;D1, D2, R&gt;</code> domain is the direct product as defined in <a class="el" href="main.html#CC79">[CC79]</a>.</p>
<p>How the results on the components are interpreted and combined depend on the specific test. For example, the test for emptiness will first make sure the product is reduced (using the reduction method provided by <code>R</code> if it is not already known to be reduced) and then test if either component is empty; thus, if <code>R</code> defines no reduction between its components and <img class="formulaInl" alt="$d = (G, P) \in (\Gset \times \Pset)$" src="form_604.png"/> is a direct product in one dimension where <img class="formulaInl" alt="$G$" src="form_605.png"/> denotes the set of numbers that are integral multiples of 3 while <img class="formulaInl" alt="$P$" src="form_86.png"/> denotes the set of numbers between 1 and 2, then an operation that tests for emptiness should return false. However, the test for the universe returns true if and only if the test <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a1190fcf4794305386f8475f9ac51ce00" title="Returns true if and only if both of the components of *this are the universe.">is_universe()</a></code> on both components returns true.</p>
<dl class="user"><dt><b></b></dt><dd>In all the examples it is assumed that the template <code>R</code> is the <code>No_Reduction&lt;D1, D2&gt;</code> class and that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds a direct product of a <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> and NNC <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, corresponding to the positive even integer pairs in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>, given as a system of congruences: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert((x %= 0) / 2);
  cgs.insert((y %= 0) / 2);
  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt;
    dp(cgs);
  dp.add_constraint(x &gt;= 0);
  dp.add_constraint(y &gt;= 0);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code builds the same product in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>: <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(2);
  dp.add_constraint(x &gt;= 0);
  dp.add_constraint(y &gt;= 0);
  dp.add_congruence((x %= 0) / 2);
  dp.add_congruence((y %= 0) / 2);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 3</b></dt><dd>The following code will write "dp is empty": <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(1);
  dp.add_congruence((x %= 0) / 2);
  dp.add_congruence((x %= 1) / 2);
  <span class="keywordflow">if</span> (dp.is_empty())
    cout &lt;&lt; <span class="stringliteral">&quot;dp is empty.&quot;</span> &lt;&lt; endl;
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">&quot;dp is not empty.&quot;</span> &lt;&lt; endl;
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 4</b></dt><dd>The following code will write "dp is not empty": <div class="fragment"><pre class="fragment">  Partially_Reduced_Product&lt;Grid, NNC_Polyhedron, No_Reduction&lt;D1, D2&gt; &gt; dp(1);
  dp.add_congruence((x %= 0) / 2);
  dp.add_constraint(x &gt;= 1);
  dp.add_constraint(x &lt;= 1);
  <span class="keywordflow">if</span> (dp.is_empty())
    cout &lt;&lt; <span class="stringliteral">&quot;dp is empty.&quot;</span> &lt;&lt; endl;
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">&quot;dp is not empty.&quot;</span> &lt;&lt; endl;
</pre></div> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6713cca018bed4091ffafb98ca4833d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a6713cca018bed4091ffafb98ca4833d0" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an object having the specified properties. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the pair;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether a universe or an empty pair has to be built.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28f6854a94a3a7d58034cb1d51ae9c7c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a28f6854a94a3a7d58034cb1d51ae9c7c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pair, copying a system of congruences. </p>
<p>The pair inherits the space dimension of the congruence system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences to be approximated by the pair.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4857c775f03d5b4ff084723eed2b5e31"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a4857c775f03d5b4ff084723eed2b5e31" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pair, recycling a system of congruences. </p>
<p>The pair inherits the space dimension of the congruence system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences to be approximates by the pair. Its data-structures may be recycled to build the pair.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1daec40615d5a93ce0de360865d93497"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a1daec40615d5a93ce0de360865d93497" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pair, copying a system of constraints. </p>
<p>The pair inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints to be approximated by the pair.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc31d844172a202d43d08e299e26322f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="abc31d844172a202d43d08e299e26322f" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pair, recycling a system of constraints. </p>
<p>The pair inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints to be approximated by the pair.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>cs</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3eb603756ab7be783cd92410ac7aed7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="ad3eb603756ab7be783cd92410ac7aed7" args="(const C_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product, from a C polyhedron. </p>
<p>Builds a product containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built product is the smallest one containing <code>ph</code>. The product inherits the space dimension of the polyhedron.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity that will not be exceeded.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adca9874a75b5ba09114b8495a23c4edd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="adca9874a75b5ba09114b8495a23c4edd" args="(const NNC_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product, from an NNC polyhedron. </p>
<p>Builds a product containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built product is the smallest one containing <code>ph</code>. The product inherits the space dimension of the polyhedron.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity that will not be exceeded.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef3ebc0ed74af80cd3653321153360bd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="aef3ebc0ed74af80cd3653321153360bd" args="(const Grid &amp;gr, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product, from a grid. </p>
<p>Builds a product containing <code>gr</code>. The product inherits the space dimension of the grid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gr</em>&nbsp;</td><td>The grid to be approximated by the product.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>gr</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b4e2b95a505c70e40370e121cd179a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a2b4e2b95a505c70e40370e121cd179a4" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product out of a box. </p>
<p>Builds a product containing <code>box</code>. The product inherits the space dimension of the box.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the pair to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab95eae83384d8c6b41b9ed8f9fd16704"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="ab95eae83384d8c6b41b9ed8f9fd16704" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product out of a BD shape. </p>
<p>Builds a product containing <code>bd</code>. The product inherits the space dimension of the BD shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BD shape representing the product to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b3eb71543b3284872781f0b4481fe39"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a2b3eb71543b3284872781f0b4481fe39" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a product out of an octagonal shape. </p>
<p>Builds a product containing <code>os</code>. The product inherits the space dimension of the octagonal shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape representing the product to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cdc72dfa85aed4e613f780b02e69e92"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::Partially_Reduced_Product" ref="a8cdc72dfa85aed4e613f780b02e69e92" args="(const Partially_Reduced_Product&lt; E1, E2, S &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; E1, E2, S &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a conservative, upward approximation of <code>y</code>. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adb466cb206f1d16d24257a838d130cf2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::is_disjoint_from" ref="adb466cb206f1d16d24257a838d130cf2" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are componentwise disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae386245235cada70fc797b0747b0d326"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::constrains" ref="ae386245235cada70fc797b0747b0d326" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99dc4fb442b60dc9c694d7abc853a3dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounds_from_above" ref="a99dc4fb442b60dc9c694d7abc853a3dc" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. </p>
<p>This method is the same as bounds_from_below.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8128b9910f31bc963842e48c44a863e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounds_from_below" ref="aa8128b9910f31bc963842e48c44a863e" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. </p>
<p>This method is the same as bounds_from_above.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a03cd3ea1b11c1c8dbdf462959d79df"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::maximize" ref="a3a03cd3ea1b11c1c8dbdf462959d79df" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a6d33d9f1d987efe6e333c7ad1993dd5a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::maximize" ref="a6d33d9f1d987efe6e333c7ad1993dd5a" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When maximization succeeds, will be assigned a generator point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>point</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ab73df10027395d3b2c9fbd3f3e77944e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimize" ref="ab73df10027395d3b2c9fbd3f3e77944e" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below i <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the infimum value can be reached in <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a5358c9f367ad37e650d411ab5e558e50"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::minimize" ref="a5358c9f367ad37e650d411ab5e558e50" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the infimum value can be reached in <code>this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When minimization succeeds, will be assigned a generator point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>point</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a888509fe116790d0b9a267e614be10ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::contains" ref="a888509fe116790d0b9a267e614be10ec" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if each component of <code>*this</code> contains the corresponding component of <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78e60691cfc6b6b52a34cc7952380a84"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::strictly_contains" ref="a78e60691cfc6b6b52a34cc7952380a84" args="(const Partially_Reduced_Product &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if each component of <code>*this</code> strictly contains the corresponding component of <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affd7d0678df82882b006ea7b02771f98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_constraint" ref="affd7d0678df82882b006ea7b02771f98" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds constraint <code>c</code> to <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6434b8a020aeda5828830fd4b639277"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_constraint" ref="ac6434b8a020aeda5828830fd4b639277" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraint <code>c</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3a8f10409a9fd73afb6691686d6862c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_congruence" ref="ad3a8f10409a9fd73afb6691686d6862c" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of congruence <code>cg</code> to <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a201ee4c814267695f31b30be833917bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_congruence" ref="a201ee4c814267695f31b30be833917bf" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruence <code>cg</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d52cb88936eb0f5bde559b39f8ec42c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_congruences" ref="a1d52cb88936eb0f5bde559b39f8ec42c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf0bc4f0e0a036dbc3852b3e4490243"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_congruences" ref="afaf0bc4f0e0a036dbc3852b3e4490243" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruences in <code>cgs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea7119974f9313e4c93908a2955c4186"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_recycled_congruences" ref="aea7119974f9313e4c93908a2955c4186" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the congruences in <code>cgs</code> to *this. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added that may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c2c96efcf10102068f754c608a12427"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_constraints" ref="a0c2c96efcf10102068f754c608a12427" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the constraint system in <code>cs</code> to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a031a8e65176b8bd80d2857bd9a68b6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::refine_with_constraints" ref="a3a031a8e65176b8bd80d2857bd9a68b6" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraints in <code>cs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafc9294d3fb5f2c0fd8d4e4d22c283b6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_recycled_constraints" ref="aafc9294d3fb5f2c0fd8d4e4d22c283b6" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraint system in <code>cs</code> to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added that may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ea45b608af772cd69e2c23d7d62a3cf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::unconstrain" ref="a7ea45b608af772cd69e2c23d7d62a3cf" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac238f59379434b7fbfd7dccd74be1cd6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::unconstrain" ref="ac238f59379434b7fbfd7dccd74be1cd6" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a676b331ee61606b74be4cd1f90756839"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::intersection_assign" ref="a676b331ee61606b74be4cd1f90756839" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the componentwise intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ea21bf85aa2e90c449435cfedcef181"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::upper_bound_assign" ref="a0ea21bf85aa2e90c449435cfedcef181" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb0fa15c5f30fc4be6a94ce2606208ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::upper_bound_assign_if_exact" ref="adb0fa15c5f30fc4be6a94ce2606208ef" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code> computed on the corresponding components. If it is exact on each of the components of <code>*this</code>, <code>true</code> is returned, otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15b21e990e26976e615a7d3244ed843e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::difference_assign" ref="a15b21e990e26976e615a7d3244ed843e" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an approximation of the set-theoretic difference of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b2ee24610cb804238f33581093948c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_image" ref="a8b2ee24610cb804238f33581093948c1" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7999968db9fb568980215d2c84393358"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::affine_preimage" ref="a7999968db9fb568980215d2c84393358" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb5709426ac80aa0bcf907b4f1d4a577"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_image" ref="abb5709426ac80aa0bcf907b4f1d4a577" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code> (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7b41dba5d22086cb9715c3f51248f98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_preimage" ref="ac7b41dba5d22086cb9715c3f51248f98" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97cc0d02a88d52e79cbb6615a3bbab42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_image" ref="a97cc0d02a88d52e79cbb6615a3bbab42" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c47f2f619b1d0f322b742891920735f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::generalized_affine_preimage" ref="a2c47f2f619b1d0f322b742891920735f" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. (see also <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a>.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae274e65fc3f012ab21bcffa3177228c5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounded_affine_image" ref="ae274e65fc3f012ab21bcffa3177228c5" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a732e7355673aa63a2fc22a470a36f707"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::bounded_affine_preimage" ref="a732e7355673aa63a2fc22a470a36f707" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77a2a8e38120a21ac0d5f19eb6e1668b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::time_elapse_assign" ref="a77a2a8e38120a21ac0d5f19eb6e1668b" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. (See also <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a>.). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99247c74022e8d51cd0a2d93a87bcfe5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::widening_assign" ref="a99247c74022e8d51cd0a2d93a87bcfe5" args="(const Partially_Reduced_Product &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the "widening" between <code>*this</code> and <code>y</code>. </p>
<p>This widening uses either the congruence or generator systems depending on which of the systems describing x and y are up to date and minimized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A product that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8be1647844c9837446b9c735f11672b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::drop_some_non_integer_points" ref="ae8be1647844c9837446b9c735f11672b" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a640fe823a102e14522990200193c6701"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::drop_some_non_integer_points" ref="a640fe823a102e14522990200193c6701" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f90e70dbef264e99b7015c0ce7e16fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_space_dimensions_and_embed" ref="a2f90e70dbef264e99b7015c0ce7e16fd" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new space dimensions and embeds the components of <code>*this</code> in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19a2fb28254bc142e01f3ee00c27ea89"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::add_space_dimensions_and_project" ref="a19a2fb28254bc142e01f3ee00c27ea89" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new space dimensions and does not embed the components in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5ec610fb42e16beaac59b537a71f187"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::concatenate_assign" ref="ac5ec610fb42e16beaac59b537a71f187" args="(const Partially_Reduced_Product &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to the first (resp., second) component of <code>*this</code> the "concatenation" of the first (resp., second) components of <code>*this</code> and <code>y</code>, taken in this order. See also <a class="el" href="main.html#Concatenating_Polyhedra">Concatenating Polyhedra</a>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af633b1416a118a2ac3146ec4a4fd4298"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::remove_space_dimensions" ref="af633b1416a118a2ac3146ec4a4fd4298" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions from the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfe66b5a34b84fcf63d1a48777f68e4d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::remove_higher_space_dimensions" ref="adfe66b5a34b84fcf63d1a48777f68e4d" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ae424886d05361c1a78c89dbdd5b7db"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::map_space_dimensions" ref="a1ae424886d05361c1a78c89dbdd5b7db" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<p>If <code>pfunc</code> maps only some of the dimensions of <code>*this</code> then the rest will be projected away.</p>
<p>If the highest dimension mapped to by <code>pfunc</code> is higher than the highest dimension in <code>*this</code> then the number of dimensions in <code>this</code> will be increased to the highest dimension mapped to by <code>pfunc</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template class <code>Partial_Function</code> must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"/> times, where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the vector space enclosing <code>*this</code>.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="a7a1f9b31c3ed7dc3e7691b9110ddbedb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::expand_space_dimension" ref="a7a1f9b31c3ed7dc3e7691b9110ddbedb" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html#a4a53183970490595ac39c8c070601c6f" title="Returns the maximum space dimension this product can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#Expanding_One_Dimension_of_the_Vector_Space_to_Multiple_Dimensions">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="a3cad64f36f7df128cc7637c9e0910bf1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::fold_space_dimensions" ref="a3cad64f36f7df128cc7637c9e0910bf1" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#Folding_Multiple_Dimensions_of_the_Vector_Space_into_One_Dimension">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="af191b9781c37da15b49810d47a838823"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::hash_code" ref="af191b9781c37da15b49810d47a838823" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt;::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ade7792cb469ddf1d5d8944bbe7f1f55a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator==" ref="ade7792cb469ddf1d5d8944bbe7f1f55a" args="(const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are pairwise equal. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible: in those cases, the value <code>false</code> is returned.</p>

</div>
</div>
<a class="anchor" id="a3a18eff42a557fd87d59895399c7a13f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator&lt;&lt;" ref="a3a18eff42a557fd87d59895399c7a13f" args="(std::ostream &amp;s, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;dp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>
<p>Writes a textual representation of <code>dp</code> on <code>s</code>.</p>

</div>
</div>
<a class="anchor" id="a7a9afaf958c6f9dd09c89bd706dc09b0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::operator!=" ref="a7a9afaf958c6f9dd09c89bd706dc09b0" args="(const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if the components of <code>x</code> and <code>y</code> are not pairwise equal. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible: in those cases, the value <code>true</code> is returned.</p>

</div>
</div>
<a class="anchor" id="a0e39243c24d99f8d374f9c14e3da8d98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Partially_Reduced_Product::swap" ref="a0e39243c24d99f8d374f9c14e3da8d98" args="(Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;x, Parma_Polyhedra_Library::Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Parma_Polyhedra_Library::Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Feb 27 10:10:58 2011 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
