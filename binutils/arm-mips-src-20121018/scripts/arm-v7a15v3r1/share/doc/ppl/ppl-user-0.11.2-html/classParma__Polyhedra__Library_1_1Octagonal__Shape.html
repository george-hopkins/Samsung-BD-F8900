<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Octagonal_Shape" -->
<p>An octagonal shape.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1Octagonal__Shape-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96bae54a01fe00bad4306bec61bb4687"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::coefficient_type_base" ref="a96bae54a01fe00bad4306bec61bb4687" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a96bae54a01fe00bad4306bec61bb4687">coefficient_type_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric base type upon which OSs are built. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a891529f721ff485fe2ec90ac48952cc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::coefficient_type" ref="a891529f721ff485fe2ec90ac48952cc6" args="" -->
typedef <a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">N</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a891529f721ff485fe2ec90ac48952cc6">coefficient_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The (extended) numeric type of the inhomogeneous term of the inequalities defining an OS. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9f6fbac96e03a00d061a2cd2ca2baf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_dump" ref="a3b9f6fbac96e03a00d061a2cd2ca2baf" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a3b9f6fbac96e03a00d061a2cd2ca2baf">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dcb9b448c8c0171e18f29551077d133"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_dump" ref="a7dcb9b448c8c0171e18f29551077d133" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a7dcb9b448c8c0171e18f29551077d133">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04704288741dbaf6f50e8fc09c43f737"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::print" ref="a04704288741dbaf6f50e8fc09c43f737" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a04704288741dbaf6f50e8fc09c43f737">print</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafdd0083c1c10d49e06f4718a826ae1b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::ascii_load" ref="aafdd0083c1c10d49e06f4718a826ae1b" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aafdd0083c1c10d49e06f4718a826ae1b">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a7dcb9b448c8c0171e18f29551077d133" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1091bf4d0e8ce7672f907cf5e7921120"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::total_memory_in_bytes" ref="a1091bf4d0e8ce7672f907cf5e7921120" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1091bf4d0e8ce7672f907cf5e7921120">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9503f2a0fd1535ce7cb9465908006dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::external_memory_in_bytes" ref="af9503f2a0fd1535ce7cb9465908006dc" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af9503f2a0fd1535ce7cb9465908006dc">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a6f9c769f48ed91cd71bec247b7733430">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#a6f9c769f48ed91cd71bec247b7733430"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Assignment, Swap and Destructor</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp80919fef1a5c3fd5d7cda4dd5aa15efd"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ab38e5d3ce8cc120ce4b534bc43d90d34">Octagonal_Shape</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an universe or empty OS of the specified space dimension.  <a href="#ab38e5d3ce8cc120ce4b534bc43d90d34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0a8906c6b7e5b785bd457641007d1359">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;x, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#a0a8906c6b7e5b785bd457641007d1359"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ac5f6c7896e64b8750e2cd9729c19d66e">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#ac5f6c7896e64b8750e2cd9729c19d66e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ae37107ec8d1402bb69ac6462d7f4646d">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the system of constraints <code>cs</code>.  <a href="#ae37107ec8d1402bb69ac6462d7f4646d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a5e74729a5f7cabef57fb795cc728869c">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from a system of congruences.  <a href="#a5e74729a5f7cabef57fb795cc728869c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a8a329c1ea10527cde394abab15b67356">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the system of generators <code>gs</code>.  <a href="#a8a329c1ea10527cde394abab15b67356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a46797ad634dc267c1264aa046c69f9f8">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from the polyhedron <code>ph</code>.  <a href="#a46797ad634dc267c1264aa046c69f9f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ac720d2c0875eba7d87a4068876092025">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS out of a box.  <a href="#ac720d2c0875eba7d87a4068876092025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#afa8decb7c7093c9cde1255a6c1af62d4">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;grid, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS that approximates a grid.  <a href="#afa8decb7c7093c9cde1255a6c1af62d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#adc326b7c8687b685c42817f7fec425e0">Octagonal_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an OS from a BD shape.  <a href="#adc326b7c8687b685c42817f7fec425e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a7f222ac228554b369d460087815b87"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator=" ref="a0a7f222ac228554b369d460087815b87" args="(const Octagonal_Shape &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0a7f222ac228554b369d460087815b87">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e4f3b53b4dd4f7f57a13df638b162e4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::swap" ref="a5e4f3b53b4dd4f7f57a13df638b162e4" args="(Octagonal_Shape &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a5e4f3b53b4dd4f7f57a13df638b162e4">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with octagon <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1921cd40fb0920e1173cf67418c63fe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::~Octagonal_Shape" ref="af1921cd40fb0920e1173cf67418c63fe" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af1921cd40fb0920e1173cf67418c63fe">~Octagonal_Shape</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Octagonal_Shape</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa854b169fb0f62e51bedcdf1b7b077c0"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed38463ae788879580d6372653452603"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::space_dimension" ref="aed38463ae788879580d6372653452603" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aed38463ae788879580d6372653452603">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b99abb6e15eedbdb94e2466e8304c52"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_dimension" ref="a8b99abb6e15eedbdb94e2466e8304c52" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a8b99abb6e15eedbdb94e2466e8304c52">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_400.png"/>, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dfec17f683d1cbe01cfc71d601108c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::constraints" ref="ab5dfec17f683d1cbe01cfc71d601108c" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ab5dfec17f683d1cbe01cfc71d601108c">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af14ea5b6122685afd62a3df786512d77"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimized_constraints" ref="af14ea5b6122685afd62a3df786512d77" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af14ea5b6122685afd62a3df786512d77">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimized system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7fd07f1f8d91c830130c061da7b6c56"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::congruences" ref="af7fd07f1f8d91c830130c061da7b6c56" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af7fd07f1f8d91c830130c061da7b6c56">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c86f7ff6b09ff72e3ee3382b4c933b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimized_congruences" ref="ab7c86f7ff6b09ff72e3ee3382b4c933b" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ab7c86f7ff6b09ff72e3ee3382b4c933b">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimal system of (equality) congruences satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ae85fbe787fa3e172ecf6a63b2847d69a">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#ae85fbe787fa3e172ecf6a63b2847d69a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af2c70f89a472f7fa34ba64817693776a">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#af2c70f89a472f7fa34ba64817693776a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0d1677ef76c939ca2025722d2ee249e2">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#a0d1677ef76c939ca2025722d2ee249e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a81c8a26a02090eb4fb9255dd814514a8">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the constraint <code>c</code>.  <a href="#a81c8a26a02090eb4fb9255dd814514a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a2d266342acc104c59dc0046242ccdac8">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>.  <a href="#a2d266342acc104c59dc0046242ccdac8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a46a4105c8476e5f5260a775777398586">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the generator <code>g</code>.  <a href="#a46a4105c8476e5f5260a775777398586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a353fe86259fbb2dd09d451e9dd468676"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_empty" ref="a353fe86259fbb2dd09d451e9dd468676" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a353fe86259fbb2dd09d451e9dd468676">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty OS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae8e418bb3d7a1432117530eaea7ec4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_universe" ref="aaae8e418bb3d7a1432117530eaea7ec4" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aaae8e418bb3d7a1432117530eaea7ec4">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe OS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3be22e7dcdf54fdc0fb976fd755d0c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_discrete" ref="ae3be22e7dcdf54fdc0fb976fd755d0c7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ae3be22e7dcdf54fdc0fb976fd755d0c7">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74d2b64496aa448a85ec0b370cee0977"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_bounded" ref="a74d2b64496aa448a85ec0b370cee0977" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a74d2b64496aa448a85ec0b370cee0977">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded OS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3905c42e02befd8a894c57abd9f972f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_topologically_closed" ref="a3905c42e02befd8a894c57abd9f972f5" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a3905c42e02befd8a894c57abd9f972f5">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22b6ac7ec1477dc82d6db22900b59be2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::contains_integer_point" ref="a22b6ac7ec1477dc82d6db22900b59be2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a22b6ac7ec1477dc82d6db22900b59be2">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains (at least) an integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ad423a6ddce01a2f2efb34b826d0de921">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#ad423a6ddce01a2f2efb34b826d0de921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a7ae373e57180f03b09aa0e38d1f19811">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#a7ae373e57180f03b09aa0e38d1f19811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1ae372d4f3b58cfa4af6edd51d845209">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#a1ae372d4f3b58cfa4af6edd51d845209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0e90a75aac44c14997804b8911ff7bbb">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#a0e90a75aac44c14997804b8911ff7bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#acb19de0243a618e9bf3d62e2ee04ae01">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#acb19de0243a618e9bf3d62e2ee04ae01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#acfec639e917dfd6eb63c4006ac55b807">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#acfec639e917dfd6eb63c4006ac55b807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a217e4addfae235df12c449320e65f891">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a217e4addfae235df12c449320e65f891"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a508d952b878adf2e55d70d6ca1e64d04">frequency</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_d, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_d) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>.  <a href="#a508d952b878adf2e55d70d6ca1e64d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35518da8c480784110d40b680256bd61"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::OK" ref="a35518da8c480784110d40b680256bd61" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a35518da8c480784110d40b680256bd61">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space-Dimension Preserving Member Functions that May Modify the Octagonal_Shape</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0e8e65ae0238dcb025d6e2a3fa1810df"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aae058fd9619a17e121c3aab9b0612d81">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>.  <a href="#aae058fd9619a17e121c3aab9b0612d81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#adc269190695c1745ab086168fcf35835">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>.  <a href="#adc269190695c1745ab086168fcf35835"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0e09e7efc2f63aba534614086427bf49">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>.  <a href="#a0e09e7efc2f63aba534614086427bf49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0e9ecea59dea0ccb1cc3600bc11f1056">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>.  <a href="#a0e9ecea59dea0ccb1cc3600bc11f1056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aa493e3939364ce0db66b42f0ef6511d0">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#aa493e3939364ce0db66b42f0ef6511d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1cd37a76428add108f267548ae76664b">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a1cd37a76428add108f267548ae76664b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a594973c5284386e52b8c33b206a47907">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#a594973c5284386e52b8c33b206a47907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a580264341ec83f4bf3d6da1205939b0a">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine the system of octagonal constraints of <code>*this</code>.  <a href="#a580264341ec83f4bf3d6da1205939b0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ac6376a87e99d3cdabaa6ee7542474849">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#ac6376a87e99d3cdabaa6ee7542474849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aa317313059bdf973567d2fcf5e030212">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine the system of octagonal constraints defining <code>*this</code>.  <a href="#aa317313059bdf973567d2fcf5e030212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#afea57a711a6b7a5d501112b84b246759">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#afea57a711a6b7a5d501112b84b246759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a107c769c3c982506e2abf6979b9e92f6">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#a107c769c3c982506e2abf6979b9e92f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#abfde1aac87d8218fce0fa9b4ea8a5eb1">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#abfde1aac87d8218fce0fa9b4ea8a5eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aec298ee7df246c945e6a56442e04176d">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest OS that contains the convex union of <code>*this</code> and <code>y</code>.  <a href="#aec298ee7df246c945e6a56442e04176d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#abfb434e3d574f4bd53314ac8749c4731">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#abfb434e3d574f4bd53314ac8749c4731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a79864149b95e4560a85aa80eb9c1303a">integer_upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the <em>integer</em> upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned; otherwise <code>false</code> is returned.  <a href="#a79864149b95e4560a85aa80eb9c1303a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a72782e7d9a6612efd73b253b0f862c6b">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest octagon containing the set difference of <code>*this</code> and <code>y</code>.  <a href="#a72782e7d9a6612efd73b253b0f862c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0a0d8c78069019f44dc34ebab82ecfc6">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#a0a0d8c78069019f44dc34ebab82ecfc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#accc6c6488ea9d8555ea8e978cf188749">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#accc6c6488ea9d8555ea8e978cf188749"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aba9abb279871c30a4f0c6cbb188fecc1">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#aba9abb279871c30a4f0c6cbb188fecc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a934cc1f45a6d438f5d468276140cd5a8">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a934cc1f45a6d438f5d468276140cd5a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a196d1efc79437ca1d96b79b7cd60387f">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a196d1efc79437ca1d96b79b7cd60387f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ab499fba7b7be2932147748248180e057">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#ab499fba7b7be2932147748248180e057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a702b00ff42a88c23ab25eecf0e9acef0">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a702b00ff42a88c23ab25eecf0e9acef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a25f104e58f88e05dfcb905bcd66e493b">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a25f104e58f88e05dfcb905bcd66e493b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a0d4db6f54c7332e1a2e0bc85e16ba176">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a0d4db6f54c7332e1a2e0bc85e16ba176"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a44e10aa0180433db7d19fb8e473dc829">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#a44e10aa0180433db7d19fb8e473dc829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ae057b1ed68adc20261654109ef5be01c">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#ae057b1ed68adc20261654109ef5be01c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a52516b2247ed249d7989a7048a677614">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#a52516b2247ed249d7989a7048a677614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#adbbe0f9a58b8cfa5c92d54082f2955f2">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#adbbe0f9a58b8cfa5c92d54082f2955f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8d04d80653fb850dd92468af1995f97"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::topological_closure_assign" ref="ad8d04d80653fb850dd92468af1995f97" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ad8d04d80653fb850dd92468af1995f97">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1d780ef5b99cc9752eb322353b7b6b08">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#a1d780ef5b99cc9752eb322353b7b6b08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a047e2a717168ae129338109f1afc9a7a">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, Iterator first, Iterator last, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#a047e2a717168ae129338109f1afc9a7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a9b7061aa20aa4b513216bcdb1a905ce7">BHMZ05_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a9b7061aa20aa4b513216bcdb1a905ce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173628da404c1dc2c4d423cad7f9f960"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::widening_assign" ref="a173628da404c1dc2c4d423cad7f9f960" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a173628da404c1dc2c4d423cad7f9f960">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as BHMZ05_widening_assign(y, tp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#afa62abe41a99d6a01cca319ed860bb5b">limited_BHMZ05_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#afa62abe41a99d6a01cca319ed860bb5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a46d5dc7df45abdea275f0295fee58c23">CC76_narrowing_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restores from <code>y</code> the constraints of <code>*this</code>, lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications.  <a href="#a46d5dc7df45abdea275f0295fee58c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a87aadd3a9d47e978a32c9867b13220a4">limited_CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#a87aadd3a9d47e978a32c9867b13220a4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdcf1aae9cb4981dcc30009fc252e5e2a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a703f57855b17ef63b28f88fe13a51870">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions and embeds the old OS into the new space.  <a href="#a703f57855b17ef63b28f88fe13a51870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a204fb0538d07ee8ac3d5f2724419928b">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the OS and does not embed it in the new space.  <a href="#a204fb0538d07ee8ac3d5f2724419928b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af41476c22751c8d79e8599443aea93da">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#af41476c22751c8d79e8599443aea93da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#af3135ed5b5cb04d1e8a54fa9be77b90f">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions.  <a href="#af3135ed5b5cb04d1e8a54fa9be77b90f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aba8ba56b075b2be7b6309cfaed039070">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#aba8ba56b075b2be7b6309cfaed039070"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a34dbbfe20e987a3d55c7a3f2d08f1aed">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#a34dbbfe20e987a3d55c7a3f2d08f1aed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a100662089d61a01ea43a28a944da266c">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a100662089d61a01ea43a28a944da266c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a6156f452e023eb181658f23bde09ec15">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#a6156f452e023eb181658f23bde09ec15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval_Info &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#acd9e3b1c74e12ebb2cec81b9670cc566">refine_fp_interval_abstract_store</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a>&lt; T, Interval_Info &gt; &gt; &amp;store) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refines <code>store</code> with the constraints defining <code>*this</code>.  <a href="#acd9e3b1c74e12ebb2cec81b9670cc566"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38da38d0fab7eed9ee09fdb11f88fd15"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::max_space_dimension" ref="a38da38d0fab7eed9ee09fdb11f88fd15" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a38da38d0fab7eed9ee09fdb11f88fd15">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension that an OS can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51fb0220102e525b11cdb06dcbe322c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::can_recycle_constraint_systems" ref="a51fb0220102e525b11cdb06dcbe322c7" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a51fb0220102e525b11cdb06dcbe322c7">can_recycle_constraint_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false indicating that this domain cannot recycle constraints. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f13e4ffe7b47ec50721791877b41622"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::can_recycle_congruence_systems" ref="a2f13e4ffe7b47ec50721791877b41622" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a2f13e4ffe7b47ec50721791877b41622">can_recycle_congruence_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false indicating that this domain cannot recycle congruences. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1c59e94611b71ddd67acd033a05bbbc7">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same octagon.  <a href="#a1c59e94611b71ddd67acd033a05bbbc7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a137dcf52993d2ff3dd6e4678b45baf56">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;oct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#a137dcf52993d2ff3dd6e4678b45baf56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a1c2f0ae89d7bf247a76c40282f31758e">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different shapes.  <a href="#a1c2f0ae89d7bf247a76c40282f31758e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#ac2cd6705bce0af4bd9880b990baf1198">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#ac2cd6705bce0af4bd9880b990baf1198"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a025902247d9c8b46d92c514c1646ff69">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#a025902247d9c8b46d92c514c1646ff69"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#aaf0214aee8884dc52be4e061d6b4df94">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#aaf0214aee8884dc52be4e061d6b4df94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a2560fe5ce16277c4b4db17e951047028">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#a2560fe5ce16277c4b4db17e951047028"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a6f27f62cf5d65574cbb44025b1b3e585">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a6f27f62cf5d65574cbb44025b1b3e585"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a715054228bad30a232707ed0357cdd98">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a715054228bad30a232707ed0357cdd98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a62d44847fe22abb82cbac84a776a9c72">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a62d44847fe22abb82cbac84a776a9c72"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br/>
 class Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt;</h3>

<p>An octagonal shape. </p>
<p>The class template Octagonal_Shape&lt;T&gt; allows for the efficient representation of a restricted kind of <em>topologically closed</em> convex polyhedra called <em>octagonal shapes</em> (OSs, for short). The name comes from the fact that, in a vector space of dimension 2, bounded OSs are polygons with at most eight sides. The closed affine half-spaces that characterize the OS can be expressed by constraints of the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ ax_i + bx_j \leq k \]" src="form_589.png"/>
</p>
<p> where <img class="formulaInl" alt="$a, b \in \{-1, 0, 1\}$" src="form_590.png"/> and <img class="formulaInl" alt="$k$" src="form_296.png"/> is a rational number, which are called <em>octagonal constraints</em>.</p>
<p>Based on the class template type parameter <code>T</code>, a family of extended numbers is built and used to approximate the inhomogeneous term of octagonal constraints. These extended numbers provide a representation for the value <img class="formulaInl" alt="$+\infty$" src="form_574.png"/>, as well as <em>rounding-aware</em> implementations for several arithmetic functions. The value of the type parameter <code>T</code> may be one of the following:</p>
<ul>
<li>a bounded precision integer type (e.g., <code>int32_t</code> or <code>int64_t</code>);</li>
<li>a bounded precision floating point type (e.g., <code>float</code> or <code>double</code>);</li>
<li>an unbounded integer or rational type, as provided by GMP (i.e., <code>mpz_class</code> or <code>mpq_class</code>).</li>
</ul>
<p>The user interface for OSs is meant to be as similar as possible to the one developed for the polyhedron class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a>.</p>
<p>The OS domain <em>optimally supports</em>:</p>
<ul>
<li>tautological and inconsistent constraints and congruences;</li>
<li>octagonal constraints;</li>
<li>non-proper congruences (i.e., equalities) that are expressible as octagonal constraints.</li>
</ul>
<p>Depending on the method, using a constraint or congruence that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.</p>
<p>A constraint is octagonal if it has the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \pm a_i x_i \pm a_j x_j \relsym b \]" src="form_591.png"/>
</p>
<p> where <img class="formulaInl" alt="$\mathord{\relsym} \in \{ \leq, =, \geq \}$" src="form_576.png"/> and <img class="formulaInl" alt="$a_i$" src="form_234.png"/>, <img class="formulaInl" alt="$a_j$" src="form_577.png"/>, <img class="formulaInl" alt="$b$" src="form_235.png"/> are integer coefficients such that <img class="formulaInl" alt="$a_i = 0$" src="form_578.png"/>, or <img class="formulaInl" alt="$a_j = 0$" src="form_579.png"/>, or <img class="formulaInl" alt="$a_i = a_j$" src="form_580.png"/>. The user is warned that the above octagonal <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object will be mapped into a <em>correct</em> and <em>optimal</em> approximation that, depending on the expressive power of the chosen template argument <code>T</code>, may loose some precision. Also note that strict constraints are not octagonal.</p>
<p>For instance, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x + 3y \leq 1$" src="form_592.png"/> will be approximated by:</p>
<ul>
<li><img class="formulaInl" alt="$x + y \leq 1$" src="form_593.png"/>, if <code>T</code> is a (bounded or unbounded) integer type;</li>
<li><img class="formulaInl" alt="$x + y \leq \frac{1}{3}$" src="form_594.png"/>, if <code>T</code> is the unbounded rational type <code>mpq_class</code>;</li>
<li><img class="formulaInl" alt="$x + y \leq k$" src="form_595.png"/>, where <img class="formulaInl" alt="$k > \frac{1}{3}$" src="form_585.png"/>, if <code>T</code> is a floating point type (having no exact representation for <img class="formulaInl" alt="$\frac{1}{3}$" src="form_586.png"/>).</li>
</ul>
<p>On the other hand, depending from the context, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - y \leq 1$" src="form_587.png"/> will be either upward approximated (e.g., by safely ignoring it) or it will cause an exception.</p>
<p>In the following examples it is assumed that the type argument <code>T</code> is one of the possible instances listed above and that variables <code>x</code>, <code>y</code> and <code>z</code> are defined (where they are used) as follows: </p>
<div class="fragment"><pre class="fragment">    Variable x(0);
    Variable y(1);
    Variable z(2);
</pre></div><dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds an OS corresponding to a cube in <img class="formulaInl" alt="$\Rset^3$" src="form_588.png"/>, given as a system of constraints: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 3);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 3);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 3);
    Octagonal_Shape&lt;T&gt; oct(cs);
</pre></div> In contrast, the following code will raise an exception, since constraints 7, 8, and 9 are not octagonal: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 3);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 3);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 3);
    cs.insert(x - 3*y &lt;= 5);    <span class="comment">// (7)</span>
    cs.insert(x - y + z &lt;= 5);  <span class="comment">// (8)</span>
    cs.insert(x + y + z &lt;= 5);  <span class="comment">// (9)</span>
    Octagonal_Shape&lt;T&gt; oct(cs);
</pre></div> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab38e5d3ce8cc120ce4b534bc43d90d34"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="ab38e5d3ce8cc120ce4b534bc43d90d34" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an universe or empty OS of the specified space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the OS;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty OS has to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a8906c6b7e5b785bd457641007d1359"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="a0a8906c6b7e5b785bd457641007d1359" args="(const Octagonal_Shape &amp;x, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="ac5f6c7896e64b8750e2cd9729c19d66e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="ac5f6c7896e64b8750e2cd9729c19d66e" args="(const Octagonal_Shape&lt; U &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a conservative, upward approximation of <code>y</code>. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="ae37107ec8d1402bb69ac6462d7f4646d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="ae37107ec8d1402bb69ac6462d7f4646d" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS from the system of constraints <code>cs</code>. </p>
<p>The OS inherits the space dimension of <code>cs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>A system of octagonal constraints.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>cs</code> contains a constraint which is not optimally supported by the Octagonal shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e74729a5f7cabef57fb795cc728869c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="a5e74729a5f7cabef57fb795cc728869c" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS from a system of congruences. </p>
<p>The OS inherits the space dimension of <code>cgs</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>A system of congruences.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>cgs</code> contains a congruence which is not optimally supported by the Octagonal shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a329c1ea10527cde394abab15b67356"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="a8a329c1ea10527cde394abab15b67356" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS from the system of generators <code>gs</code>. </p>
<p>Builds the smallest OS containing the polyhedron defined by <code>gs</code>. The OS inherits the space dimension of <code>gs</code>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46797ad634dc267c1264aa046c69f9f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="a46797ad634dc267c1264aa046c69f9f8" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS from the polyhedron <code>ph</code>. </p>
<p>Builds an OS containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the OS built is the smallest one containing <code>ph</code>. </p>

</div>
</div>
<a class="anchor" id="ac720d2c0875eba7d87a4068876092025"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="ac720d2c0875eba7d87a4068876092025" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS out of a box. </p>
<p>The OS inherits the space dimension of the box. The built OS is the most precise OS that includes the box.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the OS to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa8decb7c7093c9cde1255a6c1af62d4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="afa8decb7c7093c9cde1255a6c1af62d4" args="(const Grid &amp;grid, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS that approximates a grid. </p>
<p>The OS inherits the space dimension of the grid. The built OS is the most precise OS that includes the grid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&nbsp;</td><td>The grid used to build the OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>grid</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc326b7c8687b685c42817f7fec425e0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::Octagonal_Shape" ref="adc326b7c8687b685c42817f7fec425e0" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds an OS from a BD shape. </p>
<p>The OS inherits the space dimension of the BD shape. The built OS is the most precise OS that includes the BD shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BD shape used to build the OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae85fbe787fa3e172ecf6a63b2847d69a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::contains" ref="ae85fbe787fa3e172ecf6a63b2847d69a" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2c70f89a472f7fa34ba64817693776a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::strictly_contains" ref="af2c70f89a472f7fa34ba64817693776a" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d1677ef76c939ca2025722d2ee249e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::is_disjoint_from" ref="a0d1677ef76c939ca2025722d2ee249e2" args="(const Octagonal_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81c8a26a02090eb4fb9255dd814514a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="a81c8a26a02090eb4fb9255dd814514a8" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d266342acc104c59dc0046242ccdac8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="a2d266342acc104c59dc0046242ccdac8" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46a4105c8476e5f5260a775777398586"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::relation_with" ref="a46a4105c8476e5f5260a775777398586" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the generator <code>g</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad423a6ddce01a2f2efb34b826d0de921"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::constrains" ref="ad423a6ddce01a2f2efb34b826d0de921" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ae373e57180f03b09aa0e38d1f19811"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounds_from_above" ref="a7ae373e57180f03b09aa0e38d1f19811" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ae372d4f3b58cfa4af6edd51d845209"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounds_from_below" ref="a1ae372d4f3b58cfa4af6edd51d845209" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e90a75aac44c14997804b8911ff7bbb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::maximize" ref="a0e90a75aac44c14997804b8911ff7bbb" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="acb19de0243a618e9bf3d62e2ee04ae01"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::maximize" ref="acb19de0243a618e9bf3d62e2ee04ae01" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="acfec639e917dfd6eb63c4006ac55b807"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimize" ref="acfec639e917dfd6eb63c4006ac55b807" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a217e4addfae235df12c449320e65f891"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::minimize" ref="a217e4addfae235df12c449320e65f891" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a508d952b878adf2e55d70d6ca1e64d04"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::frequency" ref="a508d952b878adf2e55d70d6ca1e64d04" args="(const Linear_Expression &amp;expr, Coefficient &amp;freq_n, Coefficient &amp;freq_d, Coefficient &amp;val_n, Coefficient &amp;val_d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression for which the frequency is needed;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_n</em>&nbsp;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$0$" src="form_400.png"/>; Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a>, where the <a class="el" href="main.html#Grid_Frequency">frequency</a> can have a non-zero value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_d</em>&nbsp;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$1$" src="form_488.png"/>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_n</em>&nbsp;</td><td>The numerator of <code>val</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_d</em>&nbsp;</td><td>The denominator of <code>val</code>;</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>false</code> is returned, then <code>freq_n</code>, <code>freq_d</code>, <code>val_n</code> and <code>val_d</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="aae058fd9619a17e121c3aab9b0612d81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_constraint" ref="aae058fd9619a17e121c3aab9b0612d81" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the OS domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc269190695c1745ab086168fcf35835"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_constraints" ref="adc269190695c1745ab086168fcf35835" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints that will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the OS domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e09e7efc2f63aba534614086427bf49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_recycled_constraints" ref="a0e09e7efc2f63aba534614086427bf49" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the OS domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e9ecea59dea0ccb1cc3600bc11f1056"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_congruence" ref="a0e9ecea59dea0ccb1cc3600bc11f1056" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the OS domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa493e3939364ce0db66b42f0ef6511d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_congruences" ref="aa493e3939364ce0db66b42f0ef6511d0" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the OS domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cd37a76428add108f267548ae76664b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_recycled_congruences" ref="a1cd37a76428add108f267548ae76664b" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the OS domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a594973c5284386e52b8c33b206a47907"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_constraint" ref="a594973c5284386e52b8c33b206a47907" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of constraint <code>c</code> to refine the system of octagonal constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint. If it is not a octagonal constraint, it will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a580264341ec83f4bf3d6da1205939b0a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_congruence" ref="a580264341ec83f4bf3d6da1205939b0a" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of congruence <code>cg</code> to refine the system of octagonal constraints of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence. If it is not a octagonal equality, it will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6376a87e99d3cdabaa6ee7542474849"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_constraints" ref="ac6376a87e99d3cdabaa6ee7542474849" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the constraints in <code>cs</code> to refine the system of octagonal constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be used. Constraints that are not octagonal are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa317313059bdf973567d2fcf5e030212"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_with_congruences" ref="aa317313059bdf973567d2fcf5e030212" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the congruences in <code>cgs</code> to refine the system of octagonal constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be used. Congruences that are not octagonal equalities are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afea57a711a6b7a5d501112b84b246759"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::unconstrain" ref="afea57a711a6b7a5d501112b84b246759" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a107c769c3c982506e2abf6979b9e92f6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::unconstrain" ref="a107c769c3c982506e2abf6979b9e92f6" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfde1aac87d8218fce0fa9b4ea8a5eb1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::intersection_assign" ref="abfde1aac87d8218fce0fa9b4ea8a5eb1" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec298ee7df246c945e6a56442e04176d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::upper_bound_assign" ref="aec298ee7df246c945e6a56442e04176d" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the smallest OS that contains the convex union of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfb434e3d574f4bd53314ac8749c4731"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::upper_bound_assign_if_exact" ref="abfb434e3d574f4bd53314ac8749c4731" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementation is based on Theorem 6.3 of <a class="el" href="main.html#BHZ09b">[BHZ09b]</a>. </p>

</div>
</div>
<a class="anchor" id="a79864149b95e4560a85aa80eb9c1303a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::integer_upper_bound_assign_if_exact" ref="a79864149b95e4560a85aa80eb9c1303a" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::integer_upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the <em>integer</em> upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned; otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is only available when the class template parameter <code>T</code> is bound to an integer datatype.</dd>
<dd>
The integer upper bound of two rational OS is the smallest rational OS containing all the integral points in the two arguments. In general, the result is <em>not</em> an upper bound for the two input arguments, as it may cut away non-integral portions of the two rational shapes.</dd></dl>
<p>Implementation is based on Theorem 6.8 of <a class="el" href="main.html#BHZ09b">[BHZ09b]</a>. </p>

</div>
</div>
<a class="anchor" id="a72782e7d9a6612efd73b253b0f862c6b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::difference_assign" ref="a72782e7d9a6612efd73b253b0f862c6b" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the smallest octagon containing the set difference of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a0d8c78069019f44dc34ebab82ecfc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::simplify_using_context_assign" ref="a0a0d8c78069019f44dc34ebab82ecfc6" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accc6c6488ea9d8555ea8e978cf188749"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_image" ref="accc6c6488ea9d8555ea8e978cf188749" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba9abb279871c30a4f0c6cbb188fecc1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::affine_preimage" ref="aba9abb279871c30a4f0c6cbb188fecc1" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#affine_relation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a934cc1f45a6d438f5d468276140cd5a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_image" ref="a934cc1f45a6d438f5d468276140cd5a8" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a196d1efc79437ca1d96b79b7cd60387f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_image" ref="a196d1efc79437ca1d96b79b7cd60387f" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine transfer function</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab499fba7b7be2932147748248180e057"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounded_affine_image" ref="ab499fba7b7be2932147748248180e057" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a702b00ff42a88c23ab25eecf0e9acef0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_preimage" ref="a702b00ff42a88c23ab25eecf0e9acef0" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f104e58f88e05dfcb905bcd66e493b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::generalized_affine_preimage" ref="a25f104e58f88e05dfcb905bcd66e493b" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d4db6f54c7332e1a2e0bc85e16ba176"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::bounded_affine_preimage" ref="a0d4db6f54c7332e1a2e0bc85e16ba176" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44e10aa0180433db7d19fb8e473dc829"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::time_elapse_assign" ref="a44e10aa0180433db7d19fb8e473dc829" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae057b1ed68adc20261654109ef5be01c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::wrap_assign" ref="ae057b1ed68adc20261654109ef5be01c" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&nbsp;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&nbsp;</td><td>Possibly null pointer to a constraint system whose variables are contained in <code>vars</code>. If <code>*pcs</code> depends on variables not in <code>vars</code>, the behavior is undefined. When non-null, the pointed-to constraint system is assumed to represent the conditional or looping construct guard with respect to which wrapping is performed. Since wrapping requires the computation of upper bounds and due to non-distributivity of constraint refinement over upper bounds, passing a constraint system in this way can be more precise than refining the result of the wrapping operation with the constraints in <code>*pcs</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&nbsp;</td><td>A precision parameter of the <a class="el" href="main.html#Wrapping_Operator">wrapping operator</a>: higher values result in possibly improved precision.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&nbsp;</td><td><code>true</code> if the dimensions should be wrapped individually (something that results in much greater efficiency to the detriment of precision).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*pcs</code> is dimension-incompatible with <code>vars</code>, or if <code>*this</code> is dimension-incompatible <code>vars</code> or with <code>*pcs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52516b2247ed249d7989a7048a677614"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::drop_some_non_integer_points" ref="a52516b2247ed249d7989a7048a677614" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adbbe0f9a58b8cfa5c92d54082f2955f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::drop_some_non_integer_points" ref="adbbe0f9a58b8cfa5c92d54082f2955f2" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d780ef5b99cc9752eb322353b7b6b08"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_extrapolation_assign" ref="a1d780ef5b99cc9752eb322353b7b6b08" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a047e2a717168ae129338109f1afc9a7a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_extrapolation_assign" ref="a047e2a717168ae129338109f1afc9a7a" args="(const Octagonal_Shape &amp;y, Iterator first, Iterator last, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An iterator that points to the first stop_point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An iterator that points to the last stop_point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b7061aa20aa4b513216bcdb1a905ce7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::BHMZ05_widening_assign" ref="a9b7061aa20aa4b513216bcdb1a905ce7" args="(const Octagonal_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::BHMZ05_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa62abe41a99d6a01cca319ed860bb5b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::limited_BHMZ05_extrapolation_assign" ref="afa62abe41a99d6a01cca319ed860bb5b" args="(const Octagonal_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::limited_BHMZ05_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if there is in <code>cs</code> a strict inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46d5dc7df45abdea275f0295fee58c23"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::CC76_narrowing_assign" ref="a46d5dc7df45abdea275f0295fee58c23" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::CC76_narrowing_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restores from <code>y</code> the constraints of <code>*this</code>, lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> contain <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87aadd3a9d47e978a32c9867b13220a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::limited_CC76_extrapolation_assign" ref="a87aadd3a9d47e978a32c9867b13220a4" args="(const Octagonal_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::limited_CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>An OS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened OS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a703f57855b17ef63b28f88fe13a51870"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_space_dimensions_and_embed" ref="a703f57855b17ef63b28f88fe13a51870" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions and embeds the old OS into the new space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new OS, which is characterized by a system of constraints in which the variables running through the new dimensions are not constrained. For instance, when starting from the OS <img class="formulaInl" alt="$\cO \sseq \Rset^2$" src="form_739.png"/> and adding a third dimension, the result will be the OS </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cO \,\bigr\}. \]" src="form_740.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a204fb0538d07ee8ac3d5f2724419928b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::add_space_dimensions_and_project" ref="a204fb0538d07ee8ac3d5f2724419928b" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions to the OS and does not embed it in the new space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new OS, which is characterized by a system of constraints in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the OS <img class="formulaInl" alt="$\cO \sseq \Rset^2$" src="form_739.png"/> and adding a third dimension, the result will be the OS </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cO \,\bigr\}. \]" src="form_741.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="af41476c22751c8d79e8599443aea93da"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::concatenate_assign" ref="af41476c22751c8d79e8599443aea93da" args="(const Octagonal_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a38da38d0fab7eed9ee09fdb11f88fd15" title="Returns the maximum space dimension that an OS can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3135ed5b5cb04d1e8a54fa9be77b90f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::remove_space_dimensions" ref="af3135ed5b5cb04d1e8a54fa9be77b90f" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba8ba56b075b2be7b6309cfaed039070"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::remove_higher_space_dimensions" ref="aba8ba56b075b2be7b6309cfaed039070" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimension</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34dbbfe20e987a3d55c7a3f2d08f1aed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::map_space_dimensions" ref="a34dbbfe20e987a3d55c7a3f2d08f1aed" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template type parameter Partial_Function must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the codomain of the partial function. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="a100662089d61a01ea43a28a944da266c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::expand_space_dimension" ref="a100662089d61a01ea43a28a944da266c" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html#a38da38d0fab7eed9ee09fdb11f88fd15" title="Returns the maximum space dimension that an OS can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="a6156f452e023eb181658f23bde09ec15"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::fold_space_dimensions" ref="a6156f452e023eb181658f23bde09ec15" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="acd9e3b1c74e12ebb2cec81b9670cc566"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::refine_fp_interval_abstract_store" ref="acd9e3b1c74e12ebb2cec81b9670cc566" args="(Box&lt; Interval&lt; T, Interval_Info &gt; &gt; &amp;store) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Interval_Info &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::refine_fp_interval_abstract_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a>&lt; T, Interval_Info &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refines <code>store</code> with the constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The interval floating point abstract store to refine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f9c769f48ed91cd71bec247b7733430"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::hash_code" ref="a6f9c769f48ed91cd71bec247b7733430" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt;::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a1c59e94611b71ddd67acd033a05bbbc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator==" ref="a1c59e94611b71ddd67acd033a05bbbc7" args="(const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same octagon. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>false</code> is returned.</p>

</div>
</div>
<a class="anchor" id="a137dcf52993d2ff3dd6e4678b45baf56"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator&lt;&lt;" ref="a137dcf52993d2ff3dd6e4678b45baf56" args="(std::ostream &amp;s, const Octagonal_Shape&lt; T &gt; &amp;oct)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>
<p>Writes a textual representation of <code>oct</code> on <code>s:</code> <code>false</code> is written if <code>oct</code> is an empty polyhedron; <code>true</code> is written if <code>oct</code> is a universe polyhedron; a system of constraints defining <code>oct</code> is written otherwise, all constraints separated by ", ".</p>

</div>
</div>
<a class="anchor" id="a1c2f0ae89d7bf247a76c40282f31758e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::operator!=" ref="a1c2f0ae89d7bf247a76c40282f31758e" args="(const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different shapes. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>true</code> is returned.</p>

</div>
</div>
<a class="anchor" id="ac2cd6705bce0af4bd9880b990baf1198"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::rectilinear_distance_assign" ref="ac2cd6705bce0af4bd9880b990baf1198" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a025902247d9c8b46d92c514c1646ff69"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::rectilinear_distance_assign" ref="a025902247d9c8b46d92c514c1646ff69" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="aaf0214aee8884dc52be4e061d6b4df94"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::euclidean_distance_assign" ref="aaf0214aee8884dc52be4e061d6b4df94" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a2560fe5ce16277c4b4db17e951047028"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::euclidean_distance_assign" ref="a2560fe5ce16277c4b4db17e951047028" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="a6f27f62cf5d65574cbb44025b1b3e585"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::l_infinity_distance_assign" ref="a6f27f62cf5d65574cbb44025b1b3e585" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a715054228bad30a232707ed0357cdd98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::l_infinity_distance_assign" ref="a715054228bad30a232707ed0357cdd98" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Octagonal_Shape&lt; T &gt; &amp;x, const Octagonal_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&nbsp;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="a62d44847fe22abb82cbac84a776a9c72"></a><!-- doxytag: member="Parma_Polyhedra_Library::Octagonal_Shape::swap" ref="a62d44847fe22abb82cbac84a776a9c72" args="(Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; &amp;x, Parma_Polyhedra_Library::Octagonal_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Parma_Polyhedra_Library::Octagonal_Shape</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Feb 27 10:10:58 2011 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
