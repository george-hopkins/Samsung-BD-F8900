<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Grid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Grid Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Grid" -->
<p>A grid.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1Grid-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092f5c04d267ab5709dda2d3e51aaeb9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::coefficient_type" ref="a092f5c04d267ab5709dda2d3e51aaeb9" args="" -->
typedef <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a092f5c04d267ab5709dda2d3e51aaeb9">coefficient_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric type of coefficients. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c">Grid</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid having the specified properties.  <a href="#a0262a2b32220536d8bc60d84ad8dac4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a727dc2405cfc5f2252e6f21aa0f18074">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of congruences.  <a href="#a727dc2405cfc5f2252e6f21aa0f18074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a31603d81a2b0571a82c4c79b8c6e4564">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of congruences.  <a href="#a31603d81a2b0571a82c4c79b8c6e4564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a0c02302b6281fa91ef9275bd37e43efc">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of constraints.  <a href="#a0c02302b6281fa91ef9275bd37e43efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a527ffa31e1581a8beb83a832244dada8">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of constraints.  <a href="#a527ffa31e1581a8beb83a832244dada8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a732d3b59f8a0ba21a72877d5fa4b98a5">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;const_gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, copying a system of grid generators.  <a href="#a732d3b59f8a0ba21a72877d5fa4b98a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1ba0bd59426889233904d052224cab76">Grid</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid, recycling a system of grid generators.  <a href="#a1ba0bd59426889233904d052224cab76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a19623ff8cea2239d66331f29c1d0268d">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of a box.  <a href="#a19623ff8cea2239d66331f29c1d0268d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a470e6a581b91bc6d5a4a6388d1ddde99">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;bd, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of a bounded-difference shape.  <a href="#a470e6a581b91bc6d5a4a6388d1ddde99"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#adf002bbcc4dcae5efdb56bae2971a64b">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid out of an octagonal shape.  <a href="#adf002bbcc4dcae5efdb56bae2971a64b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a36cc3783cdc92ab5fc69904c298ed12c">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a grid from a polyhedron using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the grid built is the smallest one containing <code>ph</code>.  <a href="#a36cc3783cdc92ab5fc69904c298ed12c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa28d735beef86789b73b41dbbde71abf">Grid</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#aa28d735beef86789b73b41dbbde71abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ba97c180500b43954b09532151f6c9d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator=" ref="a1ba97c180500b43954b09532151f6c9d" args="(const Grid &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1ba97c180500b43954b09532151f6c9d">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Grid</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp19e3edc59f8140daaad235afbd7e174a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc06f600e94b7bedb91d0371a51f4c38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::space_dimension" ref="afc06f600e94b7bedb91d0371a51f4c38" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afc06f600e94b7bedb91d0371a51f4c38">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90ca2b1613fda31a2ac7e79d9388680d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_dimension" ref="a90ca2b1613fda31a2ac7e79d9388680d" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a90ca2b1613fda31a2ac7e79d9388680d">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_400.png"/>, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Grid_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53b24395ac61f8b2b2accc5a3900bf69"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::constraints" ref="a53b24395ac61f8b2b2accc5a3900bf69" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a53b24395ac61f8b2b2accc5a3900bf69">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of equality constraints satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a880344de195aef75a6b3f2a4db4787b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_constraints" ref="a880344de195aef75a6b3f2a4db4787b4" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a880344de195aef75a6b3f2a4db4787b4">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a minimal system of equality constraints satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8688fd38682b19e97422816d72524790"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::congruences" ref="a8688fd38682b19e97422816d72524790" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8688fd38682b19e97422816d72524790">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of congruences. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453e51570268eb4d63fc529130a54440"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_congruences" ref="a453e51570268eb4d63fc529130a54440" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a453e51570268eb4d63fc529130a54440">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of congruences in minimal form. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8865893c48cc07adae5dca6b35081751"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::grid_generators" ref="a8865893c48cc07adae5dca6b35081751" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8865893c48cc07adae5dca6b35081751">grid_generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ae1850664122e9917f174d10fd3bf06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimized_grid_generators" ref="a6ae1850664122e9917f174d10fd3bf06" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a6ae1850664122e9917f174d10fd3bf06">minimized_grid_generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimized system of generators. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14942b33fb82bb3e6a13e5e92ada475"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="ad14942b33fb82bb3e6a13e5e92ada475" args="(const Congruence &amp;cg) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ad14942b33fb82bb3e6a13e5e92ada475">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>cg</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803035024ab9670971868f4b1092f7c5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="a803035024ab9670971868f4b1092f7c5" args="(const Grid_Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a803035024ab9670971868f4b1092f7c5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f703ba611b9e5ff613f4df35347ee95"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="a6f703ba611b9e5ff613f4df35347ee95" args="(const Generator &amp;g) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a6f703ba611b9e5ff613f4df35347ee95">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>g</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace98c3e57a1237e6dd5042b5a0919193"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::relation_with" ref="ace98c3e57a1237e6dd5042b5a0919193" args="(const Constraint &amp;c) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ace98c3e57a1237e6dd5042b5a0919193">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and <code>c</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f31170286d3abc2f4867d0b193ae8bc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_empty" ref="a2f31170286d3abc2f4867d0b193ae8bc" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a2f31170286d3abc2f4867d0b193ae8bc">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty grid. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59634a195948ff0617177d0a41e30602"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_universe" ref="a59634a195948ff0617177d0a41e30602" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a59634a195948ff0617177d0a41e30602">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe grid. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#adc7cdee1981f44b5db23f6c28c79d0a6">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space.  <a href="#adc7cdee1981f44b5db23f6c28c79d0a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a621d377682c2c67051c24b1cc8a03497">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#a621d377682c2c67051c24b1cc8a03497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a2528b5f433e743dda827b1028b6c74cd">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete.  <a href="#a2528b5f433e743dda827b1028b6c74cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a5606b64a035977b9d76b1932227246"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_bounded" ref="a1a5606b64a035977b9d76b1932227246" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1a5606b64a035977b9d76b1932227246">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is bounded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0047a6aa4f26d9133b9d741f68384f38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::contains_integer_point" ref="a0047a6aa4f26d9133b9d741f68384f38" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a0047a6aa4f26d9133b9d741f68384f38">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a3ac47497148e61f3d7a3da09d17a03bf">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#a3ac47497148e61f3d7a3da09d17a03bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa033cfca735240b3699b523d60ad692a">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#aa033cfca735240b3699b523d60ad692a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afde364ce088f82cf2b9a231e7d9f2abc">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>.  <a href="#afde364ce088f82cf2b9a231e7d9f2abc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a042613c3f4ad30b298d70143c935d7cd">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#a042613c3f4ad30b298d70143c935d7cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8fa02815bb561135934f91c9adcd0cb5">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#a8fa02815bb561135934f91c9adcd0cb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a0d8ed7a0e48fe76e7221842c780192b0">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#a0d8ed7a0e48fe76e7221842c780192b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a53f980fb1ac8fa21265bec985bd1382f">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a53f980fb1ac8fa21265bec985bd1382f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afae3a58c19c9a3b9916f29b7aca4d0e0">frequency</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_d, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_d) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <a class="el" href="main.html#Grid_Frequency">frequency</a> for <code>*this</code> with respect to <code>expr</code> is defined, in which case the frequency and the value for <code>expr</code> that is closest to zero are computed.  <a href="#afae3a58c19c9a3b9916f29b7aca4d0e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ad743f8b71eb68f6b41f7ea7b5d21dc22">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#ad743f8b71eb68f6b41f7ea7b5d21dc22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8d2cc5d18d050975101f2860f2919da8">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#a8d2cc5d18d050975101f2860f2919da8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8edc85ba3e8a09593959814eaad72499">OK</a> (bool check_not_empty=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied.  <a href="#a8edc85ba3e8a09593959814eaad72499"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Grid</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6227393aee1237244a599efa6fab6faf"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1287b254a91451368e7e2e456f448114">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>.  <a href="#a1287b254a91451368e7e2e456f448114"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ad09e4e3f9a9da562c6cdb73dd7b47fbe">add_grid_generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;g)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>.  <a href="#ad09e4e3f9a9da562c6cdb73dd7b47fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa26f672c32271db69ed68fc60eee8cff">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of each congruence in <code>cgs</code> to <code>*this</code>.  <a href="#aa26f672c32271db69ed68fc60eee8cff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a85b2560352485ac05d10aab0ee483252">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to *this.  <a href="#a85b2560352485ac05d10aab0ee483252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9e87405c740d202951ba788f9e52cbf7">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>.  <a href="#a9e87405c740d202951ba788f9e52cbf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a943c42b0d1b3580e54b3ab60aa55255f">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>.  <a href="#a943c42b0d1b3580e54b3ab60aa55255f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a145cc7c23d407576222e5af347f401c1">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>.  <a href="#a145cc7c23d407576222e5af347f401c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a953a608f6f9d413870fb3eee5cc6ad1e">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#a953a608f6f9d413870fb3eee5cc6ad1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#af1ab967a6606266f7e583fc9752667fe">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#af1ab967a6606266f7e583fc9752667fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a82b76e3f18679ea161b53bfa80349009">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraint <code>c</code> to refine <code>*this</code>.  <a href="#a82b76e3f18679ea161b53bfa80349009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8f97dbc7a7c307fa72f7e904b2cbf21b">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#a8f97dbc7a7c307fa72f7e904b2cbf21b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a19422844125a988daaf489cbaff3835b">add_grid_generators</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>.  <a href="#a19422844125a988daaf489cbaff3835b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a214e376adb9dc271c61b58f8b2c927f0">add_recycled_grid_generators</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>this</code>.  <a href="#a214e376adb9dc271c61b58f8b2c927f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ae5dc5003b3652660bc4ff4a15e4060af">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#ae5dc5003b3652660bc4ff4a15e4060af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ac418d88df400bcd2233fb6281debb08f">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#ac418d88df400bcd2233fb6281debb08f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ac9d9eaf8b76024bc20ce524e13bf86a6">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#ac9d9eaf8b76024bc20ce524e13bf86a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9831db06919c6ee05360b08e84cccbb7">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>.  <a href="#a9831db06919c6ee05360b08e84cccbb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a68665d093308c111817eca341b98d70a">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact it is assigned to <code>this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#a68665d093308c111817eca341b98d70a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ae5955a311fc4fde1edf2d5460f0a8356">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">grid-difference</a> of <code>*this</code> and <code>y</code>.  <a href="#ae5955a311fc4fde1edf2d5460f0a8356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a071aa57e439ba4f358c7fd43b03a6a49">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#a071aa57e439ba4f358c7fd43b03a6a49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#abb10ea556dd34e0c1e13f7e99b9efe70">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#abb10ea556dd34e0c1e13f7e99b9efe70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a90e87cbe8ae0717fa09ff51b70d64b47">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a90e87cbe8ae0717fa09ff51b70d64b47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ad42265530a9e3b2f3bda9ab40d4a835b">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_719.png"/>.  <a href="#ad42265530a9e3b2f3bda9ab40d4a835b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ab602d97b867b5d2ea800ea7ceef4c6b5">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_719.png"/>.  <a href="#ab602d97b867b5d2ea800ea7ceef4c6b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa9c12ecd84df4ed86b5676a09fa39208">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_720.png"/>.  <a href="#aa9c12ecd84df4ed86b5676a09fa39208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afb9d83c4e182f640833116dc2f725076">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_720.png"/>.  <a href="#afb9d83c4e182f640833116dc2f725076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a0441c9c3b0ab0d55165bb6b4fd107f64">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a0441c9c3b0ab0d55165bb6b4fd107f64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9e4e32230b187284ac0b9ca8efba8f82">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a9e4e32230b187284ac0b9ca8efba8f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ac009459805692e582a00d4b5954ab8e5">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#ac009459805692e582a00d4b5954ab8e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8c7fcb89eaea13582c4fecacc52d4ec3">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#a8c7fcb89eaea13582c4fecacc52d4ec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a2d4a31320735e93af31c8d2cc7e78329">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping all points with non-integer coordinates.  <a href="#a2d4a31320735e93af31c8d2cc7e78329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa76828d01f5c454221427eef68227f78">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping all points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#aa76828d01f5c454221427eef68227f78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2581586de73769088ece60dc01409a08"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::topological_closure_assign" ref="a2581586de73769088ece60dc01409a08" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a2581586de73769088ece60dc01409a08">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ab6bba83ceaafdb71df04b77e43bed022">congruence_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using congruence systems.  <a href="#ab6bba83ceaafdb71df04b77e43bed022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ae8d42fcd571a9c9d64f0e7ffe67e995e">generator_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using generator systems.  <a href="#ae8d42fcd571a9c9d64f0e7ffe67e995e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a596fc5b3ee0d04895aca9139cb6cbcb6">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a596fc5b3ee0d04895aca9139cb6cbcb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ae47fdbff76383891b3896ac5fc213d5d">limited_congruence_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the congruence variant of <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#ae47fdbff76383891b3896ac5fc213d5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a323efbe5d43695cc65f8cd5935da94dc">limited_generator_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the generator variant of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#a323efbe5d43695cc65f8cd5935da94dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9bdab8408169307fbd899ec3670cb2bf">limited_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, unsigned *tp=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#a9bdab8408169307fbd899ec3670cb2bf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdcf1aae9cb4981dcc30009fc252e5e2a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a10e3116398b920cb137cf576a073cc68">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main.html#Adding_New_Dimensions_to_the_Vector_Space">Adds</a> <code>m</code> new space dimensions and embeds the old grid in the new vector space.  <a href="#a10e3116398b920cb137cf576a073cc68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ac4e1b49845e553ff84dc73e710def76c">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main.html#Adding_New_Dimensions_to_the_Vector_Space">Adds</a> <code>m</code> new space dimensions to the grid and does not embed it in the new vector space.  <a href="#ac4e1b49845e553ff84dc73e710def76c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1b528a2e8d4d096f62535454e05b74ba">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#a1b528a2e8d4d096f62535454e05b74ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a5cdf44f392505e1371a85b1245775224">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#a5cdf44f392505e1371a85b1245775224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a7ff92e5d40e6faf667a0b1f6b8fad791">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have <a class="el" href="main.html#Removing_Dimensions_from_the_Vector_Space">dimension <code>new_dimension</code>.</a>.  <a href="#a7ff92e5d40e6faf667a0b1f6b8fad791"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a60138f2b5d41fd62c862fdcd7c4a1e61">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#a60138f2b5d41fd62c862fdcd7c4a1e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#af6df34e5e4ab9beab41cd76897d64c72">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#af6df34e5e4ab9beab41cd76897d64c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a688572fbdc35859515f5ea8ba583a45a">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#a688572fbdc35859515f5ea8ba583a45a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e8eeaccd742ab8c555ed9dc7dd0ea9d"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bdac3717a59f64634da7d9b1cfaefd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::~Grid" ref="a07bdac3717a59f64634da7d9b1cfaefd" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a07bdac3717a59f64634da7d9b1cfaefd">~Grid</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa598904833b374d50efc72c51914112c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::swap" ref="aa598904833b374d50efc72c51914112c" args="(Grid &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aa598904833b374d50efc72c51914112c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with grid <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a508103dc808fc747a90b573083a60461"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_dump" ref="a508103dc808fc747a90b573083a60461" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a508103dc808fc747a90b573083a60461">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d51ba9ca3c3e0bf0042502f40d2e11b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_dump" ref="a1d51ba9ca3c3e0bf0042502f40d2e11b" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1d51ba9ca3c3e0bf0042502f40d2e11b">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee33974909cfc1cba605734a57d44df0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::print" ref="aee33974909cfc1cba605734a57d44df0" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aee33974909cfc1cba605734a57d44df0">print</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a26d0018999e56d94a7e96db2b6e553"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::ascii_load" ref="a1a26d0018999e56d94a7e96db2b6e553" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1a26d0018999e56d94a7e96db2b6e553">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1d51ba9ca3c3e0bf0042502f40d2e11b" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39e1b0519a47aafb9dba4121dc41a9c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::total_memory_in_bytes" ref="af39e1b0519a47aafb9dba4121dc41a9c" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#af39e1b0519a47aafb9dba4121dc41a9c">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9b562373b4d288c03549bdba93fede"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::external_memory_in_bytes" ref="aeb9b562373b4d288c03549bdba93fede" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#aeb9b562373b4d288c03549bdba93fede">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a5f6fcc1dab2b08eff20b41d1412d1e2d">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#a5f6fcc1dab2b08eff20b41d1412d1e2d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe613a3da3edc3cb4506f70d409f061d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::max_space_dimension" ref="afe613a3da3edc3cb4506f70d409f061d" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afe613a3da3edc3cb4506f70d409f061d">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension all kinds of <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fc86a6331f34f34a506ab2b0609ac37"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::can_recycle_congruence_systems" ref="a7fc86a6331f34f34a506ab2b0609ac37" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a7fc86a6331f34f34a506ab2b0609ac37">can_recycle_congruence_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true indicating that this domain has methods that can recycle congruences. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3628b6d6e250d4c6b8301173c6ecc777"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::can_recycle_constraint_systems" ref="a3628b6d6e250d4c6b8301173c6ecc777" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a3628b6d6e250d4c6b8301173c6ecc777">can_recycle_constraint_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true indicating that this domain has methods that can recycle constraints. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a87d004db7f8febf6f9c96b4a2a1c85e5">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same grid.  <a href="#a87d004db7f8febf6f9c96b4a2a1c85e5"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a1cb88a546d32e7b5c07dc25055e33235">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;gr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#a1cb88a546d32e7b5c07dc25055e33235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a9e17201a9a12235a9a96cc31cfffd38f">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different grids.  <a href="#a9e17201a9a12235a9a96cc31cfffd38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#ad452407f89cb560e83fb81938c12a585">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#ad452407f89cb560e83fb81938c12a585"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A grid. </p>
<p>An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a> represents a rational grid.</p>
<p>The domain of grids <em>optimally supports</em>:</p>
<ul>
<li>all (proper and non-proper) congruences;</li>
<li>tautological and inconsistent constraints;</li>
<li>linear equality constraints (i.e., non-proper congruences).</li>
</ul>
<p>Depending on the method, using a constraint that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.</p>
<p>The domain of grids support a concept of double description similar to the one developed for polyhedra: hence, a grid can be specified as either a finite system of congruences or a finite system of generators (see Section <a class="el" href="main.html#sect_rational_grids">Rational Grids</a>) and it is always possible to obtain either representation. That is, if we know the system of congruences, we can obtain from this a system of generators that define the same grid and vice versa. These systems can contain redundant members, or they can be in the minimal form.</p>
<p>A key attribute of any grid is its space dimension (the dimension <img class="formulaInl" alt="$n \in \Nset$" src="form_130.png"/> of the enclosing vector space):</p>
<ul>
<li>all grids, the empty ones included, are endowed with a space dimension;</li>
<li>most operations working on a grid and another object (another grid, a congruence, a generator, a set of variables, etc.) will throw an exception if the grid and the object are not dimension-compatible (see Section <a class="el" href="main.html#Grid_Space_Dimensions">Space Dimensions and Dimension-compatibility for Grids</a>);</li>
<li>the only ways in which the space dimension of a grid can be changed are with <em>explicit</em> calls to operators provided for that purpose, and with standard copy, assignment and swap operators.</li>
</ul>
<p>Note that two different grids can be defined on the zero-dimension space: the empty grid and the universe grid <img class="formulaInl" alt="$R^0$" src="form_559.png"/>.</p>
<dl class="user"><dt><b></b></dt><dd>In all the examples it is assumed that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds a grid corresponding to the even integer pairs in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>, given as a system of congruences: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert((x %= 0) / 2);
  cgs.insert((y %= 0) / 2);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying three of the points: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(grid_point(0*x + 2*y));
  gs.insert(grid_point(2*x + 0*y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code builds a grid corresponding to a line in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/> by adding a single congruence to the universe grid: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert(x - y == 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying a point and a line: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(grid_line(x + y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 3</b></dt><dd>The following code builds a grid corresponding to the integral points on the line <img class="formulaInl" alt="$x = y$" src="form_387.png"/> in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/> constructed by adding an equality and congruence to the universe grid: <div class="fragment"><pre class="fragment">  Congruence_System cgs;
  cgs.insert(x - y == 0);
  cgs.insert(x %= 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(cgs);
</pre></div> The following code builds the same grid as above, but starting from a system of generators specifying a point and a parameter: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(0*x + 0*y));
  gs.insert(parameter(x + y));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 4</b></dt><dd>The following code builds the grid corresponding to a plane by creating the universe grid in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2);
</pre></div> The following code builds the same grid as above, but starting from the empty grid in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/> and inserting the appropriate generators (a point, and two lines). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_line(x));
  gr.add_grid_generator(grid_line(y));
</pre></div> Note that a generator system must contain a point when describing a grid. To ensure that this is always the case it is required that the first generator inserted in an empty grid is a point (otherwise, an exception is thrown).</dd></dl>
<dl class="user"><dt><b>Example 5</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_embed</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(1);
  gr.add_congruence(x == 2);
  gr.add_space_dimensions_and_embed(1);
</pre></div> We build the universe grid in the 1-dimension space <img class="formulaInl" alt="$\Rset$" src="form_26.png"/>. Then we add a single equality congruence, thus obtaining the grid corresponding to the singleton set <img class="formulaInl" alt="$\{ 2 \} \sseq \Rset$" src="form_560.png"/>. After the last line of code, the resulting grid is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (2, y)^\transpose \in \Rset^2 \bigm| y \in \Rset \,\bigr\}. \]" src="form_561.png"/>
</p>
</dd></dl>
<dl class="user"><dt><b>Example 6</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_project</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(1);
  gr.add_congruence(x == 2);
  gr.add_space_dimensions_and_project(1);
</pre></div> The first two lines of code are the same as in Example 4 for <code>add_space_dimensions_and_embed</code>. After the last line of code, the resulting grid is the singleton set <img class="formulaInl" alt="$\bigl\{ (2, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_562.png"/>.</dd></dl>
<dl class="user"><dt><b>Example 7</b></dt><dd>The following code shows the use of the function <code>affine_image</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_point(4*x + 0*y));
  gr.add_grid_generator(grid_point(0*x + 2*y));
  Linear_Expression expr = x + 3;
  gr.affine_image(x, expr);
</pre></div> In this example the starting grid is all the pairs of <img class="formulaInl" alt="$x$" src="form_21.png"/> and <img class="formulaInl" alt="$y$" src="form_388.png"/> in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/> where <img class="formulaInl" alt="$x$" src="form_21.png"/> is an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_388.png"/> is an integer multiple of 2. The considered variable is <img class="formulaInl" alt="$x$" src="form_21.png"/> and the affine expression is <img class="formulaInl" alt="$x+3$" src="form_568.png"/>. The resulting grid is the given grid translated 3 integers to the right (all the pairs <img class="formulaInl" alt="$(x, y)$" src="form_569.png"/> where <img class="formulaInl" alt="$x$" src="form_21.png"/> is -1 plus an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_388.png"/> is an integer multiple of 2). Moreover, if the affine transformation for the same variable <code>x</code> is instead <img class="formulaInl" alt="$x+y$" src="form_564.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting grid is every second integral point along the <img class="formulaInl" alt="$x=y$" src="form_570.png"/> line, with this line of points repeated at every fourth integral value along the <img class="formulaInl" alt="$x$" src="form_21.png"/> axis. Instead, if we do not use an invertible transformation for the same variable; for example, the affine expression <img class="formulaInl" alt="$y$" src="form_388.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting grid is every second point along the <img class="formulaInl" alt="$x=y$" src="form_570.png"/> line.</dd></dl>
<dl class="user"><dt><b>Example 8</b></dt><dd>The following code shows the use of the function <code>affine_preimage</code>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(2, <a class="code" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  gr.add_grid_generator(grid_point(0*x + 0*y));
  gr.add_grid_generator(grid_point(4*x + 0*y));
  gr.add_grid_generator(grid_point(0*x + 2*y));
  Linear_Expression expr = x + 3;
  gr.affine_preimage(x, expr);
</pre></div> In this example the starting grid, <code>var</code> and the affine expression and the denominator are the same as in Example 6, while the resulting grid is similar but translated 3 integers to the left (all the pairs <img class="formulaInl" alt="$(x, y)$" src="form_569.png"/> where <img class="formulaInl" alt="$x$" src="form_21.png"/> is -3 plus an integer multiple of 4 and <img class="formulaInl" alt="$y$" src="form_388.png"/> is an integer multiple of 2).. Moreover, if the affine transformation for <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_564.png"/> <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting grid is a similar grid to the result in Example 6, only the grid is slanted along <img class="formulaInl" alt="$x=-y$" src="form_571.png"/>. Instead, if we do not use an invertible transformation for the same variable <code>x</code>, for example, the affine expression <img class="formulaInl" alt="$y$" src="form_388.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting grid is every fourth line parallel to the <img class="formulaInl" alt="$x$" src="form_21.png"/> axis.</dd></dl>
<dl class="user"><dt><b>Example 9</b></dt><dd>For this example we also use the variables: <div class="fragment"><pre class="fragment">  Variable z(2);
  Variable w(3);
</pre></div> The following code shows the use of the function <code>remove_space_dimensions</code>: <div class="fragment"><pre class="fragment">  Grid_Generator_System gs;
  gs.insert(grid_point(3*x + y +0*z + 2*w));
  <a class="code" href="classParma__Polyhedra__Library_1_1Grid.html#a0262a2b32220536d8bc60d84ad8dac4c" title="Builds a grid having the specified properties.">Grid</a> gr(gs);
  Variables_Set vars;
  vars.insert(y);
  vars.insert(z);
  gr.remove_space_dimensions(vars);
</pre></div> The starting grid is the singleton set <img class="formulaInl" alt="$\bigl\{ (3, 1, 0, 2)^\transpose \bigr\} \sseq \Rset^4$" src="form_165.png"/>, while the resulting grid is <img class="formulaInl" alt="$\bigl\{ (3, 2)^\transpose \bigr\} \sseq \Rset^2$" src="form_566.png"/>. Be careful when removing space dimensions <em>incrementally</em>: since dimensions are automatically renamed after each application of the <code>remove_space_dimensions</code> operator, unexpected results can be obtained. For instance, by using the following code we would obtain a different result: <div class="fragment"><pre class="fragment">  set&lt;Variable&gt; vars1;
  vars1.insert(y);
  gr.remove_space_dimensions(vars1);
  set&lt;Variable&gt; vars2;
  vars2.insert(z);
  gr.remove_space_dimensions(vars2);
</pre></div> In this case, the result is the grid <img class="formulaInl" alt="$\bigl\{(3, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_567.png"/>: when removing the set of dimensions <code>vars2</code> we are actually removing variable <img class="formulaInl" alt="$w$" src="form_418.png"/> of the original grid. For the same reason, the operator <code>remove_space_dimensions</code> is not idempotent: removing twice the same non-empty set of dimensions is never the same as removing them just once. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0262a2b32220536d8bc60d84ad8dac4c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a0262a2b32220536d8bc60d84ad8dac4c" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid having the specified properties. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty grid has to be built.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a727dc2405cfc5f2252e6f21aa0f18074"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a727dc2405cfc5f2252e6f21aa0f18074" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, copying a system of congruences. </p>
<p>The grid inherits the space dimension of the congruence system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the grid.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31603d81a2b0571a82c4c79b8c6e4564"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a31603d81a2b0571a82c4c79b8c6e4564" args="(Congruence_System &amp;cgs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, recycling a system of congruences. </p>
<p>The grid inherits the space dimension of the congruence system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c02302b6281fa91ef9275bd37e43efc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a0c02302b6281fa91ef9275bd37e43efc" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, copying a system of constraints. </p>
<p>The grid inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the grid.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the constraint system <code>cs</code> contains inequality constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527ffa31e1581a8beb83a832244dada8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a527ffa31e1581a8beb83a832244dada8" args="(Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, recycling a system of constraints. </p>
<p>The grid inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the constraint system <code>cs</code> contains inequality constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a732d3b59f8a0ba21a72877d5fa4b98a5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a732d3b59f8a0ba21a72877d5fa4b98a5" args="(const Grid_Generator_System &amp;const_gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>const_gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, copying a system of grid generators. </p>
<p>The grid inherits the space dimension of the generator system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>const_gs</em>&nbsp;</td><td>The system of generators defining the grid.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ba0bd59426889233904d052224cab76"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a1ba0bd59426889233904d052224cab76" args="(Grid_Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid, recycling a system of grid generators. </p>
<p>The grid inherits the space dimension of the generator system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the grid. Its data-structures may be recycled to build the grid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the system of generators is not empty but has no points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19623ff8cea2239d66331f29c1d0268d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a19623ff8cea2239d66331f29c1d0268d" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid out of a box. </p>
<p>The grid inherits the space dimension of the box. The built grid is the most precise grid that includes the box.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a470e6a581b91bc6d5a4a6388d1ddde99"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a470e6a581b91bc6d5a4a6388d1ddde99" args="(const BD_Shape&lt; U &gt; &amp;bd, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid out of a bounded-difference shape. </p>
<p>The grid inherits the space dimension of the BDS. The built grid is the most precise grid that includes the BDS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bd</em>&nbsp;</td><td>The BDS representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>bd</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf002bbcc4dcae5efdb56bae2971a64b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="adf002bbcc4dcae5efdb56bae2971a64b" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid out of an octagonal shape. </p>
<p>The grid inherits the space dimension of the octagonal shape. The built grid is the most precise grid that includes the octagonal shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The octagonal shape representing the grid to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36cc3783cdc92ab5fc69904c298ed12c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="a36cc3783cdc92ab5fc69904c298ed12c" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a grid from a polyhedron using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the grid built is the smallest one containing <code>ph</code>. </p>
<p>The grid inherits the space dimension of polyhedron.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&nbsp;</td><td>The polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The complexity class.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if <code>num_dimensions</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa28d735beef86789b73b41dbbde71abf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::Grid" ref="aa28d735beef86789b73b41dbbde71abf" args="(const Grid &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adc7cdee1981f44b5db23f6c28c79d0a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_topologically_closed" ref="adc7cdee1981f44b5db23f6c28c79d0a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_topologically_closed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. </p>
<p>A grid is always topologically closed. </p>

</div>
</div>
<a class="anchor" id="a621d377682c2c67051c24b1cc8a03497"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_disjoint_from" ref="a621d377682c2c67051c24b1cc8a03497" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2528b5f433e743dda827b1028b6c74cd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::is_discrete" ref="a2528b5f433e743dda827b1028b6c74cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::is_discrete </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is discrete. </p>
<p>A grid is discrete if it can be defined by a generator system which contains only points and parameters. This includes the empty grid and any grid in dimension zero. </p>

</div>
</div>
<a class="anchor" id="a3ac47497148e61f3d7a3da09d17a03bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::constrains" ref="a3ac47497148e61f3d7a3da09d17a03bf" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa033cfca735240b3699b523d60ad692a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounds_from_above" ref="aa033cfca735240b3699b523d60ad692a" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. </p>
<p>This method is the same as bounds_from_below.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afde364ce088f82cf2b9a231e7d9f2abc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounds_from_below" ref="afde364ce088f82cf2b9a231e7d9f2abc" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded in <code>*this</code>. </p>
<p>This method is the same as bounds_from_above.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a042613c3f4ad30b298d70143c935d7cd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::maximize" ref="a042613c3f4ad30b298d70143c935d7cd" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a8fa02815bb561135934f91c9adcd0cb5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::maximize" ref="a8fa02815bb561135934f91c9adcd0cb5" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if the supremum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When maximization succeeds, will be assigned a point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded by <code>*this</code>, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>point</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a0d8ed7a0e48fe76e7221842c780192b0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimize" ref="a0d8ed7a0e48fe76e7221842c780192b0" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the is the infimum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a53f980fb1ac8fa21265bec985bd1382f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::minimize" ref="a53f980fb1ac8fa21265bec985bd1382f" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if the is the infimum value can be reached in <code>this</code>. Always <code>true</code> when <code>this</code> bounds <code>expr</code>. Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a>, where closure points can result in a value of false;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>point</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="afae3a58c19c9a3b9916f29b7aca4d0e0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::frequency" ref="afae3a58c19c9a3b9916f29b7aca4d0e0" args="(const Linear_Expression &amp;expr, Coefficient &amp;freq_n, Coefficient &amp;freq_d, Coefficient &amp;val_n, Coefficient &amp;val_d) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <a class="el" href="main.html#Grid_Frequency">frequency</a> for <code>*this</code> with respect to <code>expr</code> is defined, in which case the frequency and the value for <code>expr</code> that is closest to zero are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression for which the frequency is needed;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_n</em>&nbsp;</td><td>The numerator of the maximum frequency of <code>expr</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_d</em>&nbsp;</td><td>The denominator of the maximum frequency of <code>expr</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_n</em>&nbsp;</td><td>The numerator of them value of <code>expr</code> at a point in the grid that is closest to zero;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_d</em>&nbsp;</td><td>The denominator of a value of <code>expr</code> at a point in the grid that is closest to zero;</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or frequency is undefined with respect to <code>expr</code>, then <code>false</code> is returned and <code>freq_n</code>, <code>freq_d</code>, <code>val_n</code> and <code>val_d</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ad743f8b71eb68f6b41f7ea7b5d21dc22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::contains" ref="ad743f8b71eb68f6b41f7ea7b5d21dc22" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d2cc5d18d050975101f2860f2919da8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::strictly_contains" ref="a8d2cc5d18d050975101f2860f2919da8" args="(const Grid &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8edc85ba3e8a09593959814eaad72499"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::OK" ref="a8edc85ba3e8a09593959814eaad72499" args="(bool check_not_empty=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::OK </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check_not_empty</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if all the invariants are satisfied. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if and only if <code>*this</code> satisfies all the invariants and either <code>check_not_empty</code> is <code>false</code> or <code>*this</code> is not empty.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check_not_empty</em>&nbsp;</td><td><code>true</code> if and only if, in addition to checking the invariants, <code>*this</code> must be checked to be not empty.</td></tr>
  </table>
  </dd>
</dl>
<p>The check is performed so as to intrude as little as possible. If the library has been compiled with run-time assertions enabled, error messages are written on <code>std::cerr</code> in case invariants are violated. This is useful for the purpose of debugging the library. </p>

</div>
</div>
<a class="anchor" id="a1287b254a91451368e7e2e456f448114"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruence" ref="a1287b254a91451368e7e2e456f448114" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of congruence <code>cg</code> to <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad09e4e3f9a9da562c6cdb73dd7b47fbe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generator" ref="ad09e4e3f9a9da562c6cdb73dd7b47fbe" args="(const Grid_Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_grid_generator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Grid_Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of grid generator <code>g</code> to the system of generators of <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible, or if <code>*this</code> is an empty grid and <code>g</code> is not a point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa26f672c32271db69ed68fc60eee8cff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_congruences" ref="aa26f672c32271db69ed68fc60eee8cff" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of each congruence in <code>cgs</code> to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences that will be added to the system of congruences of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85b2560352485ac05d10aab0ee483252"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_congruences" ref="a85b2560352485ac05d10aab0ee483252" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the congruences in <code>cgs</code> to *this. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e87405c740d202951ba788f9e52cbf7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraint" ref="a9e87405c740d202951ba788f9e52cbf7" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> a congruence equivalent to constraint <code>c</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible or if constraint <code>c</code> is not optimally supported by the grid domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a943c42b0d1b3580e54b3ab60aa55255f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_constraints" ref="a943c42b0d1b3580e54b3ab60aa55255f" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a145cc7c23d407576222e5af347f401c1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_constraints" ref="a145cc7c23d407576222e5af347f401c1" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> congruences equivalent to the constraints in <code>cs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints to be added. They may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a constraint whcih is not optimally supported by the grid domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a953a608f6f9d413870fb3eee5cc6ad1e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_congruence" ref="a953a608f6f9d413870fb3eee5cc6ad1e" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the congruence <code>cg</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&nbsp;</td><td>The congruence used.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1ab967a6606266f7e583fc9752667fe"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_congruences" ref="af1ab967a6606266f7e583fc9752667fe" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences used.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82b76e3f18679ea161b53bfa80349009"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_constraint" ref="a82b76e3f18679ea161b53bfa80349009" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the constraint <code>c</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint used. If it is not an equality, it will be ignored</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f97dbc7a7c307fa72f7e904b2cbf21b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::refine_with_constraints" ref="a8f97dbc7a7c307fa72f7e904b2cbf21b" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraints used. Constraints that are not equalities are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19422844125a988daaf489cbaff3835b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_grid_generators" ref="a19422844125a988daaf489cbaff3835b" args="(const Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_grid_generators </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a214e376adb9dc271c61b58f8b2c927f0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_recycled_grid_generators" ref="a214e376adb9dc271c61b58f8b2c927f0" args="(Grid_Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_recycled_grid_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the generators in <code>gs</code> to the system of generators of <code>this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made about <code>gs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5dc5003b3652660bc4ff4a15e4060af"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::unconstrain" ref="ae5dc5003b3652660bc4ff4a15e4060af" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac418d88df400bcd2233fb6281debb08f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::unconstrain" ref="ac418d88df400bcd2233fb6281debb08f" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9d9eaf8b76024bc20ce524e13bf86a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::intersection_assign" ref="ac9d9eaf8b76024bc20ce524e13bf86a6" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9831db06919c6ee05360b08e84cccbb7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::upper_bound_assign" ref="a9831db06919c6ee05360b08e84cccbb7" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68665d093308c111817eca341b98d70a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::upper_bound_assign_if_exact" ref="a68665d093308c111817eca341b98d70a" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the upper bound of <code>*this</code> and <code>y</code> is exact it is assigned to <code>this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5955a311fc4fde1edf2d5460f0a8356"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::difference_assign" ref="ae5955a311fc4fde1edf2d5460f0a8356" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">grid-difference</a> of <code>*this</code> and <code>y</code>. </p>
<p>The grid difference between grids x and y is the smallest grid containing all the points from x and y that are only in x.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a071aa57e439ba4f358c7fd43b03a6a49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::simplify_using_context_assign" ref="a071aa57e439ba4f358c7fd43b03a6a49" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Grid::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb10ea556dd34e0c1e13f7e99b9efe70"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_image" ref="abb10ea556dd34e0c1e13f7e99b9efe70" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine image</a> of <code>this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90e87cbe8ae0717fa09ff51b70d64b47"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::affine_preimage" ref="a90e87cbe8ae0717fa09ff51b70d64b47" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Grid_Affine_Transformation">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad42265530a9e3b2f3bda9ab40d4a835b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_image" ref="ad42265530a9e3b2f3bda9ab40d4a835b" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_719.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression. Optional argument with an automatic value of one;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab602d97b867b5d2ea800ea7ceef4c6b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_preimage" ref="ab602d97b867b5d2ea800ea7ceef4c6b5" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one(), Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' = \frac{\mathrm{expr}}{\mathrm{denominator}} \pmod{\mathrm{modulus}}$" src="form_719.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression. Optional argument with an automatic value of one;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9c12ecd84df4ed86b5676a09fa39208"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_image" ref="aa9c12ecd84df4ed86b5676a09fa39208" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_720.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb9d83c4e182f640833116dc2f725076"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generalized_affine_preimage" ref="afb9d83c4e182f640833116dc2f725076" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs, Coefficient_traits::const_reference modulus=Coefficient_zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>modulus</em> = <code>Coefficient_zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Grid_Generalized_Image">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' = \mathrm{rhs} \pmod{\mathrm{modulus}}$" src="form_720.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol where EQUAL is the symbol for a congruence relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus of the congruence lhs = rhs. A modulus of zero indicates lhs == rhs. Optional argument with an automatic value of zero.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0441c9c3b0ab0d55165bb6b4fd107f64"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounded_affine_image" ref="a0441c9c3b0ab0d55165bb6b4fd107f64" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e4e32230b187284ac0b9ca8efba8f82"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::bounded_affine_preimage" ref="a9e4e32230b187284ac0b9ca8efba8f82" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac009459805692e582a00d4b5954ab8e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::time_elapse_assign" ref="ac009459805692e582a00d4b5954ab8e5" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Time_Elapse">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c7fcb89eaea13582c4fecacc52d4ec3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::wrap_assign" ref="a8c7fcb89eaea13582c4fecacc52d4ec3" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&nbsp;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&nbsp;</td><td>Possibly null pointer to a constraint system. This argument is for compatibility with <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8c7fcb89eaea13582c4fecacc52d4ec3" title="Wraps the specified dimensions of the vector space.">wrap_assign()</a> for the other domains and only checked for dimension-compatibility.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&nbsp;</td><td>A precision parameter of the <a class="el" href="main.html#Wrapping_Operator">wrapping operator</a>. This argument is for compatibility with <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#a8c7fcb89eaea13582c4fecacc52d4ec3" title="Wraps the specified dimensions of the vector space.">wrap_assign()</a> for the other domains and is ignored.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&nbsp;</td><td><code>true</code> if the dimensions should be wrapped individually. As wrapping dimensions collectively does not improve the precision, this argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code> or with <code>*pcs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is assumed that variables in <code>Vars</code> represent integers. Thus, where the extra cost is negligible, the integrality of these variables is enforced; possibly causing a non-integral grid to become empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d4a31320735e93af31c8d2cc7e78329"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::drop_some_non_integer_points" ref="a2d4a31320735e93af31c8d2cc7e78329" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping all points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa76828d01f5c454221427eef68227f78"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::drop_some_non_integer_points" ref="aa76828d01f5c454221427eef68227f78" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping all points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored as the algorithm used has polynomial complexity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6bba83ceaafdb71df04b77e43bed022"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::congruence_widening_assign" ref="ab6bba83ceaafdb71df04b77e43bed022" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::congruence_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using congruence systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8d42fcd571a9c9d64f0e7ffe67e995e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::generator_widening_assign" ref="ae8d42fcd571a9c9d64f0e7ffe67e995e" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::generator_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code> using generator systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a596fc5b3ee0d04895aca9139cb6cbcb6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::widening_assign" ref="a596fc5b3ee0d04895aca9139cb6cbcb6" args="(const Grid &amp;y, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Grid_Widening">Grid widening</a> between <code>*this</code> and <code>y</code>. </p>
<p>This widening uses either the congruence or generator systems depending on which of the systems describing x and y are up to date and minimized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae47fdbff76383891b3896ac5fc213d5d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_congruence_extrapolation_assign" ref="ae47fdbff76383891b3896ac5fc213d5d" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_congruence_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the congruence variant of <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a323efbe5d43695cc65f8cd5935da94dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_generator_extrapolation_assign" ref="a323efbe5d43695cc65f8cd5935da94dc" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_generator_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the generator variant of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bdab8408169307fbd899ec3670cb2bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::limited_extrapolation_assign" ref="a9bdab8408169307fbd899ec3670cb2bf" args="(const Grid &amp;y, const Congruence_System &amp;cgs, unsigned *tp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::limited_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#Grid_Widening">Grid widening</a> computation by also enforcing those congruences in <code>cgs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A grid that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The system of congruences used to improve the widened grid;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Grid_Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10e3116398b920cb137cf576a073cc68"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_space_dimensions_and_embed" ref="a10e3116398b920cb137cf576a073cc68" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Adding_New_Dimensions_to_the_Vector_Space">Adds</a> <code>m</code> new space dimensions and embeds the old grid in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The new space dimensions will be those having the highest indexes in the new grid, which is characterized by a system of congruences in which the variables which are the new dimensions can have any value. For instance, when starting from the grid <img class="formulaInl" alt="$\cL \sseq \Rset^2$" src="form_721.png"/> and adding a third space dimension, the result will be the grid </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cL \,\bigr\}. \]" src="form_722.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="ac4e1b49845e553ff84dc73e710def76c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::add_space_dimensions_and_project" ref="ac4e1b49845e553ff84dc73e710def76c" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Adding_New_Dimensions_to_the_Vector_Space">Adds</a> <code>m</code> new space dimensions to the grid and does not embed it in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The new space dimensions will be those having the highest indexes in the new grid, which is characterized by a system of congruences in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the grid <img class="formulaInl" alt="$\cL \sseq \Rset^2$" src="form_721.png"/> and adding a third space dimension, the result will be the grid </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cL \,\bigr\}. \]" src="form_723.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a1b528a2e8d4d096f62535454e05b74ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::concatenate_assign" ref="a1b528a2e8d4d096f62535454e05b74ba" args="(const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cdf44f392505e1371a85b1245775224"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::remove_space_dimensions" ref="a5cdf44f392505e1371a85b1245775224" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions from the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ff92e5d40e6faf667a0b1f6b8fad791"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::remove_higher_space_dimensions" ref="a7ff92e5d40e6faf667a0b1f6b8fad791" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions of the vector space so that the resulting space will have <a class="el" href="main.html#Removing_Dimensions_from_the_Vector_Space">dimension <code>new_dimension</code>.</a>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60138f2b5d41fd62c862fdcd7c4a1e61"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::map_space_dimensions" ref="a60138f2b5d41fd62c862fdcd7c4a1e61" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<p>If <code>pfunc</code> maps only some of the dimensions of <code>*this</code> then the rest will be projected away.</p>
<p>If the highest dimension mapped to by <code>pfunc</code> is higher than the highest dimension in <code>*this</code> then the number of dimensions in <code>this</code> will be increased to the highest dimension mapped to by <code>pfunc</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template type parameter Partial_Function must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"/> times, where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the vector space enclosing the grid.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="af6df34e5e4ab9beab41cd76897d64c72"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::expand_space_dimension" ref="af6df34e5e4ab9beab41cd76897d64c72" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html#afe613a3da3edc3cb4506f70d409f061d" title="Returns the maximum space dimension all kinds of Grid can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#Expanding_One_Dimension_of_the_Vector_Space_to_Multiple_Dimensions">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="a688572fbdc35859515f5ea8ba583a45a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::fold_space_dimensions" ref="a688572fbdc35859515f5ea8ba583a45a" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Grid::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#Folding_Multiple_Dimensions_of_the_Vector_Space_into_One_Dimension">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="a5f6fcc1dab2b08eff20b41d1412d1e2d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::hash_code" ref="a5f6fcc1dab2b08eff20b41d1412d1e2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Parma_Polyhedra_Library::Grid::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a87d004db7f8febf6f9c96b4a2a1c85e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator==" ref="a87d004db7f8febf6f9c96b4a2a1c85e5" args="(const Grid &amp;x, const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same grid. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible grids: in those cases, the value <code>false</code> is returned. </p>

</div>
</div>
<a class="anchor" id="a1cb88a546d32e7b5c07dc25055e33235"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator&lt;&lt;" ref="a1cb88a546d32e7b5c07dc25055e33235" args="(std::ostream &amp;s, const Grid &amp;gr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>
<p>Writes a textual representation of <code>gr</code> on <code>s:</code> <code>false</code> is written if <code>gr</code> is an empty grid; <code>true</code> is written if <code>gr</code> is a universe grid; a minimized system of congruences defining <code>gr</code> is written otherwise, all congruences in one row separated by ", "s. </p>

</div>
</div>
<a class="anchor" id="a9e17201a9a12235a9a96cc31cfffd38f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::operator!=" ref="a9e17201a9a12235a9a96cc31cfffd38f" args="(const Grid &amp;x, const Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different grids. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible grids: in those cases, the value <code>true</code> is returned.</p>

</div>
</div>
<a class="anchor" id="ad452407f89cb560e83fb81938c12a585"></a><!-- doxytag: member="Parma_Polyhedra_Library::Grid::swap" ref="ad452407f89cb560e83fb81938c12a585" args="(Parma_Polyhedra_Library::Grid &amp;x, Parma_Polyhedra_Library::Grid &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Parma_Polyhedra_Library::Grid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Feb 27 10:10:57 2011 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
