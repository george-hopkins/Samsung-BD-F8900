<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Polyhedron Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>::<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a>
  </div>
</div>
<div class="contents">
<h1>Parma_Polyhedra_Library::Polyhedron Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1><!-- doxytag: class="Parma_Polyhedra_Library::Polyhedron" -->
<p>The base class for convex polyhedra.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherited by <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">Parma_Polyhedra_Library::C_Polyhedron</a>, and <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">Parma_Polyhedra_Library::NNC_Polyhedron</a>.</p>

<p><a href="classParma__Polyhedra__Library_1_1Polyhedron-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dfef947c46e234a1ffd4707312332ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::coefficient_type" ref="a5dfef947c46e234a1ffd4707312332ec" args="" -->
typedef <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a5dfef947c46e234a1ffd4707312332ec">coefficient_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numeric type of coefficients. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Polyhedron</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7accfe3c1fdd6a187d11dd092e22a5bf"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43cd840b1ec99350c222b3f217739cea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::space_dimension" ref="a43cd840b1ec99350c222b3f217739cea" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a43cd840b1ec99350c222b3f217739cea">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ddb3b93ac699eebaca7e79f691b0ad"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_dimension" ref="a97ddb3b93ac699eebaca7e79f691b0ad" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a97ddb3b93ac699eebaca7e79f691b0ad">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_400.png"/>, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b8d597a3c23af1fce9d8d3e1d36e11d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::constraints" ref="a7b8d597a3c23af1fce9d8d3e1d36e11d" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a7b8d597a3c23af1fce9d8d3e1d36e11d">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a35f8df974c9e932df6291754859fb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_constraints" ref="ab7a35f8df974c9e932df6291754859fb" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ab7a35f8df974c9e932df6291754859fb">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of constraints, with no redundant constraint. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bf7987a6ee3547c1e125e83e432ee2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generators" ref="a2bf7987a6ee3547c1e125e83e432ee2a" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a2bf7987a6ee3547c1e125e83e432ee2a">generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c5216e2ba5c80d77e128daea25b46e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_generators" ref="ae1c5216e2ba5c80d77e128daea25b46e" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae1c5216e2ba5c80d77e128daea25b46e">minimized_generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system of generators, with no redundant generator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb94f0e966e97bfb9dcf43dddcf12ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::congruences" ref="a6fb94f0e966e97bfb9dcf43dddcf12ba" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6fb94f0e966e97bfb9dcf43dddcf12ba">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ea1802e6a6cfb32e5af6d6d26eb424"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_congruences" ref="ac6ea1802e6a6cfb32e5af6d6d26eb424" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac6ea1802e6a6cfb32e5af6d6d26eb424">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>, with no redundant congruences and having the same affine dimension as <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb75fd68aa10bd15e590e8e8954c5002"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::grid_generators" ref="acb75fd68aa10bd15e590e8e8954c5002" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#acb75fd68aa10bd15e590e8e8954c5002">grid_generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a universe system of grid generators. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d69bc8c9bd9843262551c7e3e33f5a2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimized_grid_generators" ref="a0d69bc8c9bd9843262551c7e3e33f5a2" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator__System.html">Grid_Generator_System</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0d69bc8c9bd9843262551c7e3e33f5a2">minimized_grid_generators</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a universe system of grid generators. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a9f3c5474494eb306717bc3da7c109307">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the constraint <code>c</code>.  <a href="#a9f3c5474494eb306717bc3da7c109307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0514c2e57ac8154666e9fe6bb56c0e18">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the generator <code>g</code>.  <a href="#a0514c2e57ac8154666e9fe6bb56c0e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6187dbe974649c7bd4de8e66f70d3e46">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the relations holding between the polyhedron <code>*this</code> and the congruence <code>c</code>.  <a href="#a6187dbe974649c7bd4de8e66f70d3e46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad909d5b60cab5d1a6816577c97b60fcf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_empty" ref="ad909d5b60cab5d1a6816577c97b60fcf" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ad909d5b60cab5d1a6816577c97b60fcf">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty polyhedron. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c33b9ea975535b5aa0882241cf78986"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_universe" ref="a8c33b9ea975535b5aa0882241cf78986" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a8c33b9ea975535b5aa0882241cf78986">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe polyhedron. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed700f662722cbebdc9328344ba2839"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_topologically_closed" ref="a8ed700f662722cbebdc9328344ba2839" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a8ed700f662722cbebdc9328344ba2839">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac251eb38d1b24b8b570d874ee11df424">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#ac251eb38d1b24b8b570d874ee11df424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d9abbf681b7b0724963d97596286ae5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_discrete" ref="a0d9abbf681b7b0724963d97596286ae5" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0d9abbf681b7b0724963d97596286ae5">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ac997a15935821583174de968e5bff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_bounded" ref="aa0ac997a15935821583174de968e5bff" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa0ac997a15935821583174de968e5bff">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded polyhedron. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb7562de97ccf13bd97b57bb5e3ac94"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::contains_integer_point" ref="abbb7562de97ccf13bd97b57bb5e3ac94" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#abbb7562de97ccf13bd97b57bb5e3ac94">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae3be29eddce8f41019e7dcb731c8ba7b">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#ae3be29eddce8f41019e7dcb731c8ba7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af740303d5461c838735ec53c5c1f8855">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#af740303d5461c838735ec53c5c1f8855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a31d70a625e092dfdaed4f3232701f35d">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#a31d70a625e092dfdaed4f3232701f35d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac5c7acc50141a9104ef5b9b7598c1438">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#ac5c7acc50141a9104ef5b9b7598c1438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae680437fdc213b7174c581caa2e0c0d3">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#ae680437fdc213b7174c581caa2e0c0d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ad914801461cad05325559e95b9c4d9c6">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#ad914801461cad05325559e95b9c4d9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6e73a7d462d6a9a3891fff6c4a923495">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a6e73a7d462d6a9a3891fff6c4a923495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a7af48c81caa850300e6042bea1008a38">frequency</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_d, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_d) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>.  <a href="#a7af48c81caa850300e6042bea1008a38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a5df26655af3ae7844569d7086edf8332">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#a5df26655af3ae7844569d7086edf8332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac2182f38e9f8acede601c3dcfa71c3b3">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#ac2182f38e9f8acede601c3dcfa71c3b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a13f15417d90174f6c2d3648e83d9fcf5">OK</a> (bool check_not_empty=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if all the invariants are satisfied.  <a href="#a13f15417d90174f6c2d3648e83d9fcf5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Polyhedron</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7c57d7df6b075176fc53bca3220567ee"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0a5c586d872f15baf7fd70941fc16c41">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#a0a5c586d872f15baf7fd70941fc16c41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a5d53d09dcc839672fedd4ab5d4142d57">add_generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#a5d53d09dcc839672fedd4ab5d4142d57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a7df62db3bf13024d4ee9f8aaf0d27dc6">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron.  <a href="#a7df62db3bf13024d4ee9f8aaf0d27dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af60c3f345fb8ec8c708e49e8fa33f737">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#af60c3f345fb8ec8c708e49e8fa33f737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a4f9a47ba1b29f1e07a32542584d50686">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result).  <a href="#a4f9a47ba1b29f1e07a32542584d50686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a9a45b4b8f148a20359a2f3e2b1c2cb2d">add_generators</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#a9a45b4b8f148a20359a2f3e2b1c2cb2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ab1b315e7f04c051a36f48d344dd34052">add_recycled_generators</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result).  <a href="#ab1b315e7f04c051a36f48d344dd34052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a96e902093a55f87f0aebc2bb13a8d740">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron.  <a href="#a96e902093a55f87f0aebc2bb13a8d740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a3569a428ad758dc9ac8273e0f1f77772">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron.  <a href="#a3569a428ad758dc9ac8273e0f1f77772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ad6a8cc7029bad7ad7ad116c90ff59aec">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine <code>*this</code>.  <a href="#ad6a8cc7029bad7ad7ad116c90ff59aec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a236a18fe8cc922d00ee92a6c6e42f923">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine <code>*this</code>.  <a href="#a236a18fe8cc922d00ee92a6c6e42f923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#abfd98397c137d81dcc27111fba3ccd54">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#abfd98397c137d81dcc27111fba3ccd54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa26e1a5815b7a0c3b610395c854594bf">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#aa26e1a5815b7a0c3b610395c854594bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a3c1e5a2419a5f4a5cf89133606ed1680">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#a3c1e5a2419a5f4a5cf89133606ed1680"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a05fba1023938607f7c5e345c0be716e3">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#a05fba1023938607f7c5e345c0be716e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a8132d1a9b329271fb4f7faeb59c89c39">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#a8132d1a9b329271fb4f7faeb59c89c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a4b428098e57a9101473a54cd71a0753f">poly_hull_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>.  <a href="#a4b428098e57a9101473a54cd71a0753f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e68bea365fe939d08c91ec4edc61a2b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::upper_bound_assign" ref="a7e68bea365fe939d08c91ec4edc61a2b" args="(const Polyhedron &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a7e68bea365fe939d08c91ec4edc61a2b">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as poly_hull_assign(y). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a672b0568e7a27c37b3afde649f7c0171">poly_difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">poly-difference</a> of <code>*this</code> and <code>y</code>.  <a href="#a672b0568e7a27c37b3afde649f7c0171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb14f5522982b3874f2cd19586813421"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::difference_assign" ref="aeb14f5522982b3874f2cd19586813421" args="(const Polyhedron &amp;y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aeb14f5522982b3874f2cd19586813421">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as poly_difference_assign(y). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa809bff4b85d09cd801e5e5cde1b8c06">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#aa809bff4b85d09cd801e5e5cde1b8c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac93800b9ec7aae75937598e1f2209b1f">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#ac93800b9ec7aae75937598e1f2209b1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af47944944e16e786df5c0671e7baa995">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#af47944944e16e786df5c0671e7baa995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a4f514edad990412bd66cc666347103ab">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a4f514edad990412bd66cc666347103ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a08e91d11b3deb5b694356b5573d2547a">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a08e91d11b3deb5b694356b5573d2547a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a50e1047c49fffb06bc5089a06a051a3d">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a50e1047c49fffb06bc5089a06a051a3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#acbc86683af6afc0818cc9e980a84fcb8">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#acbc86683af6afc0818cc9e980a84fcb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae89cd985111a1a27c60a6fcc28ae9788">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#ae89cd985111a1a27c60a6fcc28ae9788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a371deb67f73bf27ac9a7ff6f2216db9c">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a371deb67f73bf27ac9a7ff6f2216db9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a98c785602c5af8f7e0c1be92bb5e8b71">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#a98c785602c5af8f7e0c1be92bb5e8b71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a3de85538032f58e387a151ab6a9960ba">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#a3de85538032f58e387a151ab6a9960ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a90016052cbe535d7e8b1e20a2c599053">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#a90016052cbe535d7e8b1e20a2c599053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ac26060b9b14465d4f1d948ab9c838c9c">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#ac26060b9b14465d4f1d948ab9c838c9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10fbc38125e63858549f5ec8a25e046"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::topological_closure_assign" ref="ae10fbc38125e63858549f5ec8a25e046" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae10fbc38125e63858549f5ec8a25e046">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a7366f9b91109b63f078e963bccd9f5b4">BHRZ03_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a7366f9b91109b63f078e963bccd9f5b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a281b8db6a8e0014ab2c41dd15f8c0708">limited_BHRZ03_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator.  <a href="#a281b8db6a8e0014ab2c41dd15f8c0708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a1a3647877302fc6e0e583b8b881a7a4f">bounded_BHRZ03_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator.  <a href="#a1a3647877302fc6e0e583b8b881a7a4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af074d4d4d406dd065812b32cc8714222">H79_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79_widening</a> between <code>*this</code> and <code>y</code>.  <a href="#af074d4d4d406dd065812b32cc8714222"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e9d9dd7740b414d407c16687c99a88e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::widening_assign" ref="a6e9d9dd7740b414d407c16687c99a88e" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6e9d9dd7740b414d407c16687c99a88e">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as H79_widening_assign(y, tp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#acf531d280805472a54c22fed0f689932">limited_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator.  <a href="#acf531d280805472a54c22fed0f689932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a9764ef2f159cfdcca3f151e899bd43ef">bounded_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator.  <a href="#a9764ef2f159cfdcca3f151e899bd43ef"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdcf1aae9cb4981dcc30009fc252e5e2a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a527e7c81841bbcf1963c6e260dadfe01">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions and embeds the old polyhedron in the new vector space.  <a href="#a527e7c81841bbcf1963c6e260dadfe01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa6b6fed08414c86d33fc4a44c59e9e22">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>m</code> new space dimensions to the polyhedron and does not embed it in the new vector space.  <a href="#aa6b6fed08414c86d33fc4a44c59e9e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a87ebe6f7cd176227f61c6d0fe47a4f68">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#a87ebe6f7cd176227f61c6d0fe47a4f68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a3065d01256aa333117e0ee24d99b4431">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the specified dimensions from the vector space.  <a href="#a3065d01256aa333117e0ee24d99b4431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#adee3b5c0c3800ce2214e68a156cbcf77">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#adee3b5c0c3800ce2214e68a156cbcf77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a787615432c9f1d6aac5a6394aea8cfa9">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#a787615432c9f1d6aac5a6394aea8cfa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6b737abc8f33b2a2362e3f9c9ab08d58">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a6b737abc8f33b2a2362e3f9c9ab08d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a418f9959fe50f163773ad9de147821ed">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#a418f9959fe50f163773ad9de147821ed"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Member Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e8eeaccd742ab8c555ed9dc7dd0ea9d"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c58bbc8bf8db5f570da3db42a0ae2f7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::~Polyhedron" ref="a0c58bbc8bf8db5f570da3db42a0ae2f7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a0c58bbc8bf8db5f570da3db42a0ae2f7">~Polyhedron</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aca90e7afe251a0d4174dcf538b34006b">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps <code>*this</code> with polyhedron <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.).  <a href="#aca90e7afe251a0d4174dcf538b34006b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547a8d96908afe5a7f9e4ba2e10d7ac8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_dump" ref="a547a8d96908afe5a7f9e4ba2e10d7ac8" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a547a8d96908afe5a7f9e4ba2e10d7ac8">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefab726809c553c136e5d8fda50c276e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_dump" ref="aefab726809c553c136e5d8fda50c276e" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aefab726809c553c136e5d8fda50c276e">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d7db8ee4d8972c1818a36d6517ebbff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::print" ref="a1d7db8ee4d8972c1818a36d6517ebbff" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a1d7db8ee4d8972c1818a36d6517ebbff">print</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38fbbd15d5dc2e98d5b24c92b06c290"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::ascii_load" ref="aa38fbbd15d5dc2e98d5b24c92b06c290" args="(std::istream &amp;s)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa38fbbd15d5dc2e98d5b24c92b06c290">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aefab726809c553c136e5d8fda50c276e" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7c72e56241da463eaeccdff79b6d49"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::total_memory_in_bytes" ref="a6c7c72e56241da463eaeccdff79b6d49" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a6c7c72e56241da463eaeccdff79b6d49">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78179b1d8478dce6cf572af8e0b9cb4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::external_memory_in_bytes" ref="aa78179b1d8478dce6cf572af8e0b9cb4" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa78179b1d8478dce6cf572af8e0b9cb4">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a86d2bbceaa288f2f605ac88516d313cb">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#a86d2bbceaa288f2f605ac88516d313cb"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73cb0d61cccb259e06b68d4f83deb6d7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::max_space_dimension" ref="a73cb0d61cccb259e06b68d4f83deb6d7" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a73cb0d61cccb259e06b68d4f83deb6d7">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum space dimension all kinds of <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b49993a1cd4fc6891da88a6259b9f93"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::can_recycle_constraint_systems" ref="a3b49993a1cd4fc6891da88a6259b9f93" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a3b49993a1cd4fc6891da88a6259b9f93">can_recycle_constraint_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> indicating that this domain has methods that can recycle constraints. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa39bdf85d6db02629fa73bbcaddab6d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::initialize" ref="aa39bdf85d6db02629fa73bbcaddab6d5" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa39bdf85d6db02629fa73bbcaddab6d5">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae58a861a42c5216a2267e3f94ecaec8c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::finalize" ref="ae58a861a42c5216a2267e3f94ecaec8c" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ae58a861a42c5216a2267e3f94ecaec8c">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af496ec55802726ee3b39e52458ab0647"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::can_recycle_congruence_systems" ref="af496ec55802726ee3b39e52458ab0647" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af496ec55802726ee3b39e52458ab0647">can_recycle_congruence_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle congruences. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ab6ab1820f2fdf444d1431ff3af424451">Polyhedron</a> (Topology topol, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron having the specified properties.  <a href="#ab6ab1820f2fdf444d1431ff3af424451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ab4959b3da46291de301d9150f5afc3aa">Polyhedron</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#ab4959b3da46291de301d9150f5afc3aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a858e0030826ee6c29545a934166874ef">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a system of constraints.  <a href="#a858e0030826ee6c29545a934166874ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a1cecffe684d1faa9b0f6b8d4f227e9ae">Polyhedron</a> (Topology topol, <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron recycling a system of constraints.  <a href="#a1cecffe684d1faa9b0f6b8d4f227e9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ad6d1e866b7ba9bf4233f3a5254cda0f9">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a system of generators.  <a href="#ad6d1e866b7ba9bf4233f3a5254cda0f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#afc2a04d2049183cddbcf70316fdf40e7">Polyhedron</a> (Topology topol, <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron recycling a system of generators.  <a href="#afc2a04d2049183cddbcf70316fdf40e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#adad834921ba7c139b0cb10c507b4070a">Polyhedron</a> (Topology topol, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a polyhedron from a box.  <a href="#adad834921ba7c139b0cb10c507b4070a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15f956dac6d4b19ecd8fee0f9718f29"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator=" ref="af15f956dac6d4b19ecd8fee0f9718f29" args="(const Polyhedron &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#af15f956dac6d4b19ecd8fee0f9718f29">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#aa4fa3b0975b2971f5a2cbc5bc9621a81">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> *pvars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>*pvars</code>.  <a href="#aa4fa3b0975b2971f5a2cbc5bc9621a81"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#ad84befb6d0ded481871cbef1b7306824">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator.  <a href="#ad84befb6d0ded481871cbef1b7306824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a8af124edba7c75bc76ec394405aa893e">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different polyhedra.  <a href="#a8af124edba7c75bc76ec394405aa893e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a67a7d08f3cda46f7a743d46f3a6f33b5">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a67a7d08f3cda46f7a743d46f3a6f33b5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The base class for convex polyhedra. </p>
<p>An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html" title="The base class for convex polyhedra.">Polyhedron</a> represents a convex polyhedron in the vector space <img class="formulaInl" alt="$\Rset^n$" src="form_24.png"/>.</p>
<p>A polyhedron can be specified as either a finite system of constraints or a finite system of generators (see Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>) and it is always possible to obtain either representation. That is, if we know the system of constraints, we can obtain from this the system of generators that define the same polyhedron and vice versa. These systems can contain redundant members: in this case we say that they are not in the minimal form.</p>
<p>Two key attributes of any polyhedron are its topological kind (recording whether it is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> or an <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a> object) and its space dimension (the dimension <img class="formulaInl" alt="$n \in \Nset$" src="form_130.png"/> of the enclosing vector space):</p>
<ul>
<li>all polyhedra, the empty ones included, are endowed with a specific topology and space dimension;</li>
<li>most operations working on a polyhedron and another object (i.e., another polyhedron, a constraint or generator, a set of variables, etc.) will throw an exception if the polyhedron and the object are not both topology-compatible and dimension-compatible (see Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>);</li>
<li>the topology of a polyhedron cannot be changed; rather, there are constructors for each of the two derived classes that will build a new polyhedron with the topology of that class from another polyhedron from either class and any topology;</li>
<li>the only ways in which the space dimension of a polyhedron can be changed are:<ul>
<li><em>explicit</em> calls to operators provided for that purpose;</li>
<li>standard copy, assignment and swap operators.</li>
</ul>
</li>
</ul>
<p>Note that four different polyhedra can be defined on the zero-dimension space: the empty polyhedron, either closed or NNC, and the universe polyhedron <img class="formulaInl" alt="$R^0$" src="form_559.png"/>, again either closed or NNC.</p>
<dl class="user"><dt><b></b></dt><dd>In all the examples it is assumed that variables <code>x</code> and <code>y</code> are defined (where they are used) as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds a polyhedron corresponding to a square in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>, given as a system of constraints: <div class="fragment"><pre class="fragment">  Constraint_System cs;
  cs.insert(x &gt;= 0);
  cs.insert(x &lt;= 3);
  cs.insert(y &gt;= 0);
  cs.insert(y &lt;= 3);
  C_Polyhedron ph(cs);
</pre></div> The following code builds the same polyhedron as above, but starting from a system of generators specifying the four vertices of the square: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(0*x + 0*y));
  gs.insert(point(0*x + 3*y));
  gs.insert(point(3*x + 0*y));
  gs.insert(point(3*x + 3*y));
  C_Polyhedron ph(gs);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code builds an unbounded polyhedron corresponding to a half-strip in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>, given as a system of constraints: <div class="fragment"><pre class="fragment">  Constraint_System cs;
  cs.insert(x &gt;= 0);
  cs.insert(x - y &lt;= 0);
  cs.insert(x - y + 1 &gt;= 0);
  C_Polyhedron ph(cs);
</pre></div> The following code builds the same polyhedron as above, but starting from the system of generators specifying the two vertices of the polyhedron and one ray: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(0*x + 0*y));
  gs.insert(point(0*x + y));
  gs.insert(ray(x - y));
  C_Polyhedron ph(gs);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 3</b></dt><dd>The following code builds the polyhedron corresponding to a half-plane by adding a single constraint to the universe polyhedron in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2);
  ph.add_constraint(y &gt;= 0);
</pre></div> The following code builds the same polyhedron as above, but starting from the empty polyhedron in the space <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/> and inserting the appropriate generators (a point, a ray and a line). <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2, <a class="code" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  ph.add_generator(point(0*x + 0*y));
  ph.add_generator(ray(y));
  ph.add_generator(line(x));
</pre></div> Note that, although the above polyhedron has no vertices, we must add one point, because otherwise the result of the Minkowski's sum would be an empty polyhedron. To avoid subtle errors related to the minimization process, it is required that the first generator inserted in an empty polyhedron is a point (otherwise, an exception is thrown).</dd></dl>
<dl class="user"><dt><b>Example 4</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_embed</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(1);
  ph.add_constraint(x == 2);
  ph.add_space_dimensions_and_embed(1);
</pre></div> We build the universe polyhedron in the 1-dimension space <img class="formulaInl" alt="$\Rset$" src="form_26.png"/>. Then we add a single equality constraint, thus obtaining the polyhedron corresponding to the singleton set <img class="formulaInl" alt="$\{ 2 \} \sseq \Rset$" src="form_560.png"/>. After the last line of code, the resulting polyhedron is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (2, y)^\transpose \in \Rset^2 \bigm| y \in \Rset \,\bigr\}. \]" src="form_561.png"/>
</p>
</dd></dl>
<dl class="user"><dt><b>Example 5</b></dt><dd>The following code shows the use of the function <code>add_space_dimensions_and_project</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(1);
  ph.add_constraint(x == 2);
  ph.add_space_dimensions_and_project(1);
</pre></div> The first two lines of code are the same as in Example 4 for <code>add_space_dimensions_and_embed</code>. After the last line of code, the resulting polyhedron is the singleton set <img class="formulaInl" alt="$\bigl\{ (2, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_562.png"/>.</dd></dl>
<dl class="user"><dt><b>Example 6</b></dt><dd>The following code shows the use of the function <code>affine_image</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2, <a class="code" href="group__PPL__CXX__interface.html#gga616fcdc7600a3a11a8a9152e75730899ac7753e1dd51e1b7b3fdfafa9f8332370" title="The empty element, i.e., the empty set.">EMPTY</a>);
  ph.add_generator(point(0*x + 0*y));
  ph.add_generator(point(0*x + 3*y));
  ph.add_generator(point(3*x + 0*y));
  ph.add_generator(point(3*x + 3*y));
  Linear_Expression expr = x + 4;
  ph.affine_image(x, expr);
</pre></div> In this example the starting polyhedron is a square in <img class="formulaInl" alt="$\Rset^2$" src="form_115.png"/>, the considered variable is <img class="formulaInl" alt="$x$" src="form_21.png"/> and the affine expression is <img class="formulaInl" alt="$x+4$" src="form_563.png"/>. The resulting polyhedron is the same square translated to the right. Moreover, if the affine transformation for the same variable <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_564.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting polyhedron is a parallelogram with the height equal to the side of the square and the oblique sides parallel to the line <img class="formulaInl" alt="$x-y$" src="form_565.png"/>. Instead, if we do not use an invertible transformation for the same variable; for example, the affine expression <img class="formulaInl" alt="$y$" src="form_388.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting polyhedron is a diagonal of the square.</dd></dl>
<dl class="user"><dt><b>Example 7</b></dt><dd>The following code shows the use of the function <code>affine_preimage</code>: <div class="fragment"><pre class="fragment">  C_Polyhedron ph(2);
  ph.add_constraint(x &gt;= 0);
  ph.add_constraint(x &lt;= 3);
  ph.add_constraint(y &gt;= 0);
  ph.add_constraint(y &lt;= 3);
  Linear_Expression expr = x + 4;
  ph.affine_preimage(x, expr);
</pre></div> In this example the starting polyhedron, <code>var</code> and the affine expression and the denominator are the same as in Example 6, while the resulting polyhedron is again the same square, but translated to the left. Moreover, if the affine transformation for <code>x</code> is <img class="formulaInl" alt="$x+y$" src="form_564.png"/> <div class="fragment"><pre class="fragment">  Linear_Expression expr = x + y;
</pre></div> the resulting polyhedron is a parallelogram with the height equal to the side of the square and the oblique sides parallel to the line <img class="formulaInl" alt="$x+y$" src="form_564.png"/>. Instead, if we do not use an invertible transformation for the same variable <code>x</code>, for example, the affine expression <img class="formulaInl" alt="$y$" src="form_388.png"/>: <div class="fragment"><pre class="fragment">  Linear_Expression expr = y;
</pre></div> the resulting polyhedron is a line that corresponds to the <img class="formulaInl" alt="$y$" src="form_388.png"/> axis.</dd></dl>
<dl class="user"><dt><b>Example 8</b></dt><dd>For this example we use also the variables: <div class="fragment"><pre class="fragment">  Variable z(2);
  Variable w(3);
</pre></div> The following code shows the use of the function <code>remove_space_dimensions</code>: <div class="fragment"><pre class="fragment">  Generator_System gs;
  gs.insert(point(3*x + y +0*z + 2*w));
  C_Polyhedron ph(gs);
  Variables_Set vars;
  vars.insert(y);
  vars.insert(z);
  ph.remove_space_dimensions(vars);
</pre></div> The starting polyhedron is the singleton set <img class="formulaInl" alt="$\bigl\{ (3, 1, 0, 2)^\transpose \bigr\} \sseq \Rset^4$" src="form_165.png"/>, while the resulting polyhedron is <img class="formulaInl" alt="$\bigl\{ (3, 2)^\transpose \bigr\} \sseq \Rset^2$" src="form_566.png"/>. Be careful when removing space dimensions <em>incrementally</em>: since dimensions are automatically renamed after each application of the <code>remove_space_dimensions</code> operator, unexpected results can be obtained. For instance, by using the following code we would obtain a different result: <div class="fragment"><pre class="fragment">  set&lt;Variable&gt; vars1;
  vars1.insert(y);
  ph.remove_space_dimensions(vars1);
  set&lt;Variable&gt; vars2;
  vars2.insert(z);
  ph.remove_space_dimensions(vars2);
</pre></div> In this case, the result is the polyhedron <img class="formulaInl" alt="$\bigl\{(3, 0)^\transpose \bigr\} \sseq \Rset^2$" src="form_567.png"/>: when removing the set of dimensions <code>vars2</code> we are actually removing variable <img class="formulaInl" alt="$w$" src="form_418.png"/> of the original polyhedron. For the same reason, the operator <code>remove_space_dimensions</code> is not idempotent: removing twice the same non-empty set of dimensions is never the same as removing them just once. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab6ab1820f2fdf444d1431ff3af424451"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="ab6ab1820f2fdf444d1431ff3af424451" args="(Topology topol, dimension_type num_dimensions, Degenerate_Element kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron having the specified properties. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&nbsp;</td><td>The number of dimensions of the vector space enclosing the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Specifies whether the universe or the empty polyhedron has to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4959b3da46291de301d9150f5afc3aa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="ab4959b3da46291de301d9150f5afc3aa" args="(const Polyhedron &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="a858e0030826ee6c29545a934166874ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="a858e0030826ee6c29545a934166874ef" args="(Topology topol, const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron from a system of constraints. </p>
<p>The polyhedron inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>cs</code> is incompatible with <code>topol</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cecffe684d1faa9b0f6b8d4f227e9ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="a1cecffe684d1faa9b0f6b8d4f227e9ae" args="(Topology topol, Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron recycling a system of constraints. </p>
<p>The polyhedron inherits the space dimension of the constraint system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>cs</code> is incompatible with <code>topol</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6d1e866b7ba9bf4233f3a5254cda0f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="ad6d1e866b7ba9bf4233f3a5254cda0f9" args="(Topology topol, const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron from a system of generators. </p>
<p>The polyhedron inherits the space dimension of the generator system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>gs</code> is incompatible with <code>topol</code>, or if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc2a04d2049183cddbcf70316fdf40e7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="afc2a04d2049183cddbcf70316fdf40e7" args="(Topology topol, Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron recycling a system of generators. </p>
<p>The polyhedron inherits the space dimension of the generator system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The system of generators defining the polyhedron. It is not declared <code>const</code> because its data-structures may be recycled to build the polyhedron.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if the topology of <code>gs</code> is incompatible with <code>topol</code>, or if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adad834921ba7c139b0cb10c507b4070a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::Polyhedron" ref="adad834921ba7c139b0cb10c507b4070a" args="(Topology topol, const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">Topology&nbsp;</td>
          <td class="paramname"> <em>topol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a polyhedron from a box. </p>
<p>This will use an algorithm whose complexity is polynomial and build the smallest polyhedron with topology <code>topol</code> containing <code>box</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topol</em>&nbsp;</td><td>The topology of the polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The box representing the polyhedron to be built;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>This argument is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9f3c5474494eb306717bc3da7c109307"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="a9f3c5474494eb306717bc3da7c109307" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the polyhedron <code>*this</code> and the constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0514c2e57ac8154666e9fe6bb56c0e18"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="a0514c2e57ac8154666e9fe6bb56c0e18" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the polyhedron <code>*this</code> and the generator <code>g</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6187dbe974649c7bd4de8e66f70d3e46"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::relation_with" ref="a6187dbe974649c7bd4de8e66f70d3e46" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> Parma_Polyhedra_Library::Polyhedron::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the polyhedron <code>*this</code> and the congruence <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac251eb38d1b24b8b570d874ee11df424"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::is_disjoint_from" ref="ac251eb38d1b24b8b570d874ee11df424" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3be29eddce8f41019e7dcb731c8ba7b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::constrains" ref="ae3be29eddce8f41019e7dcb731c8ba7b" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af740303d5461c838735ec53c5c1f8855"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounds_from_above" ref="af740303d5461c838735ec53c5c1f8855" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31d70a625e092dfdaed4f3232701f35d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounds_from_below" ref="a31d70a625e092dfdaed4f3232701f35d" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c7acc50141a9104ef5b9b7598c1438"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::maximize" ref="ac5c7acc50141a9104ef5b9b7598c1438" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ae680437fdc213b7174c581caa2e0c0d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::maximize" ref="ae680437fdc213b7174c581caa2e0c0d3" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&nbsp;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&nbsp;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&nbsp;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ad914801461cad05325559e95b9c4d9c6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimize" ref="ad914801461cad05325559e95b9c4d9c6" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a6e73a7d462d6a9a3891fff6c4a923495"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::minimize" ref="a6e73a7d462d6a9a3891fff6c4a923495" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&nbsp;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&nbsp;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&nbsp;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a7af48c81caa850300e6042bea1008a38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::frequency" ref="a7af48c81caa850300e6042bea1008a38" args="(const Linear_Expression &amp;expr, Coefficient &amp;freq_n, Coefficient &amp;freq_d, Coefficient &amp;val_n, Coefficient &amp;val_d) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>freq_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val_d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The linear expression for which the frequency is needed;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_n</em>&nbsp;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$0$" src="form_400.png"/>; Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a>, where the <a class="el" href="main.html#Grid_Frequency">frequency</a> can have a non-zero value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_d</em>&nbsp;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$1$" src="form_488.png"/>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_n</em>&nbsp;</td><td>The numerator of <code>val</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_d</em>&nbsp;</td><td>The denominator of <code>val</code>;</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>false</code> is returned, then <code>freq_n</code>, <code>freq_d</code>, <code>val_n</code> and <code>val_d</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a5df26655af3ae7844569d7086edf8332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::contains" ref="a5df26655af3ae7844569d7086edf8332" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2182f38e9f8acede601c3dcfa71c3b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::strictly_contains" ref="ac2182f38e9f8acede601c3dcfa71c3b3" args="(const Polyhedron &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13f15417d90174f6c2d3648e83d9fcf5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::OK" ref="a13f15417d90174f6c2d3648e83d9fcf5" args="(bool check_not_empty=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::OK </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check_not_empty</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if all the invariants are satisfied. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if and only if <code>*this</code> satisfies all the invariants and either <code>check_not_empty</code> is <code>false</code> or <code>*this</code> is not empty.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check_not_empty</em>&nbsp;</td><td><code>true</code> if and only if, in addition to checking the invariants, <code>*this</code> must be checked to be not empty.</td></tr>
  </table>
  </dd>
</dl>
<p>The check is performed so as to intrude as little as possible. If the library has been compiled with run-time assertions enabled, error messages are written on <code>std::cerr</code> in case invariants are violated. This is useful for the purpose of debugging the library. </p>

</div>
</div>
<a class="anchor" id="a0a5c586d872f15baf7fd70941fc16c41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraint" ref="a0a5c586d872f15baf7fd70941fc16c41" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of constraint <code>c</code> to the system of constraints of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The constraint that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d53d09dcc839672fedd4ab5d4142d57"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generator" ref="a5d53d09dcc839672fedd4ab5d4142d57" args="(const Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_generator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of generator <code>g</code> to the system of generators of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is an empty polyhedron and <code>g</code> is not a point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7df62db3bf13024d4ee9f8aaf0d27dc6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruence" ref="a7df62db3bf13024d4ee9f8aaf0d27dc6" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of congruence <code>cg</code> to <code>*this</code>, if <code>cg</code> can be exactly represented by a polyhedron. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, of if <code>cg</code> is a proper congruence which is neither a tautology, nor a contradiction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af60c3f345fb8ec8c708e49e8fa33f737"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_constraints" ref="af60c3f345fb8ec8c708e49e8fa33f737" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Contains the constraints that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f9a47ba1b29f1e07a32542584d50686"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints" ref="a4f9a47ba1b29f1e07a32542584d50686" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a45b4b8f148a20359a2f3e2b1c2cb2d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_generators" ref="a9a45b4b8f148a20359a2f3e2b1c2cb2d" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_generators </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>Contains the generators that will be added to the system of generators of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1b315e7f04c051a36f48d344dd34052"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_generators" ref="ab1b315e7f04c051a36f48d344dd34052" args="(Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the generators in <code>gs</code> to the system of generators of <code>*this</code> (without minimizing the result). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&nbsp;</td><td>The generator system to be added to <code>*this</code>. The generators in <code>gs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>gs</code> are topology-incompatible or dimension-incompatible, or if <code>*this</code> is empty and the system of generators <code>gs</code> is not empty, but has no points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>gs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a96e902093a55f87f0aebc2bb13a8d740"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_congruences" ref="a96e902093a55f87f0aebc2bb13a8d740" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3569a428ad758dc9ac8273e0f1f77772"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences" ref="a3569a428ad758dc9ac8273e0f1f77772" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the congruences in <code>cgs</code> to <code>*this</code>, if all the congruences can be exactly represented by a polyhedron. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>The congruences to be added. Its elements may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, of if there exists in <code>cgs</code> a proper congruence which is neither a tautology, nor a contradiction</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a8cc7029bad7ad7ad116c90ff59aec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_constraint" ref="ad6a8cc7029bad7ad7ad116c90ff59aec" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of constraint <code>c</code> to refine <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a236a18fe8cc922d00ee92a6c6e42f923"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_congruence" ref="a236a18fe8cc922d00ee92a6c6e42f923" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of congruence <code>cg</code> to refine <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfd98397c137d81dcc27111fba3ccd54"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_constraints" ref="abfd98397c137d81dcc27111fba3ccd54" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the constraints in <code>cs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Contains the constraints used to refine the system of constraints of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa26e1a5815b7a0c3b610395c854594bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::refine_with_congruences" ref="aa26e1a5815b7a0c3b610395c854594bf" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the congruences in <code>cgs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&nbsp;</td><td>Contains the congruences used to refine the system of constraints of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c1e5a2419a5f4a5cf89133606ed1680"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::unconstrain" ref="a3c1e5a2419a5f4a5cf89133606ed1680" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05fba1023938607f7c5e345c0be716e3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::unconstrain" ref="a05fba1023938607f7c5e345c0be716e3" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8132d1a9b329271fb4f7faeb59c89c39"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::intersection_assign" ref="a8132d1a9b329271fb4f7faeb59c89c39" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b428098e57a9101473a54cd71a0753f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::poly_hull_assign" ref="a4b428098e57a9101473a54cd71a0753f" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::poly_hull_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the poly-hull of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a672b0568e7a27c37b3afde649f7c0171"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::poly_difference_assign" ref="a672b0568e7a27c37b3afde649f7c0171" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::poly_difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Convex_Polyhedral_Difference">poly-difference</a> of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa809bff4b85d09cd801e5e5cde1b8c06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::simplify_using_context_assign" ref="aa809bff4b85d09cd801e5e5cde1b8c06" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Polyhedron::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac93800b9ec7aae75937598e1f2209b1f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_image" ref="ac93800b9ec7aae75937598e1f2209b1f" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af47944944e16e786df5c0671e7baa995"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::affine_preimage" ref="af47944944e16e786df5c0671e7baa995" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f514edad990412bd66cc666347103ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_image" ref="a4f514edad990412bd66cc666347103ab" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08e91d11b3deb5b694356b5573d2547a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage" ref="a08e91d11b3deb5b694356b5573d2547a" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50e1047c49fffb06bc5089a06a051a3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_image" ref="a50e1047c49fffb06bc5089a06a051a3d" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbc86683af6afc0818cc9e980a84fcb8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage" ref="acbc86683af6afc0818cc9e980a84fcb8" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&nbsp;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&nbsp;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae89cd985111a1a27c60a6fcc28ae9788"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_affine_image" ref="ae89cd985111a1a27c60a6fcc28ae9788" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a371deb67f73bf27ac9a7ff6f2216db9c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_affine_preimage" ref="a371deb67f73bf27ac9a7ff6f2216db9c" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&nbsp;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&nbsp;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&nbsp;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&nbsp;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98c785602c5af8f7e0c1be92bb5e8b71"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::time_elapse_assign" ref="a98c785602c5af8f7e0c1be92bb5e8b71" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3de85538032f58e387a151ab6a9960ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::wrap_assign" ref="a3de85538032f58e387a151ab6a9960ba" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&nbsp;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&nbsp;</td><td>Possibly null pointer to a constraint system whose variables are contained in <code>vars</code>. If <code>*pcs</code> depends on variables not in <code>vars</code>, the behavior is undefined. When non-null, the pointed-to constraint system is assumed to represent the conditional or looping construct guard with respect to which wrapping is performed. Since wrapping requires the computation of upper bounds and due to non-distributivity of constraint refinement over upper bounds, passing a constraint system in this way can be more precise than refining the result of the wrapping operation with the constraints in <code>*pcs</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&nbsp;</td><td>A precision parameter of the <a class="el" href="main.html#Wrapping_Operator">wrapping operator</a>: higher values result in possibly improved precision.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&nbsp;</td><td><code>true</code> if the dimensions should be wrapped individually (something that results in much greater efficiency to the detriment of precision).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*pcs</code> is dimension-incompatible with <code>vars</code>, or if <code>*this</code> is dimension-incompatible <code>vars</code> or with <code>*pcs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90016052cbe535d7e8b1e20a2c599053"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points" ref="a90016052cbe535d7e8b1e20a2c599053" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac26060b9b14465d4f1d948ab9c838c9c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points" ref="ac26060b9b14465d4f1d948ab9c838c9c" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7366f9b91109b63f078e963bccd9f5b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::BHRZ03_widening_assign" ref="a7366f9b91109b63f078e963bccd9f5b4" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::BHRZ03_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a281b8db6a8e0014ab2c41dd15f8c0708"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::limited_BHRZ03_extrapolation_assign" ref="a281b8db6a8e0014ab2c41dd15f8c0708" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::limited_BHRZ03_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a3647877302fc6e0e583b8b881a7a4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_BHRZ03_extrapolation_assign" ref="a1a3647877302fc6e0e583b8b881a7a4f" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_BHRZ03_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#BHRZ03_widening">BHRZ03-widening</a> operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af074d4d4d406dd065812b32cc8714222"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::H79_widening_assign" ref="af074d4d4d406dd065812b32cc8714222" args="(const Polyhedron &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::H79_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79_widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf531d280805472a54c22fed0f689932"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::limited_H79_extrapolation_assign" ref="acf531d280805472a54c22fed0f689932" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::limited_H79_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#limited_extrapolation">limited extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9764ef2f159cfdcca3f151e899bd43ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::bounded_H79_extrapolation_assign" ref="a9764ef2f159cfdcca3f151e899bd43ef" args="(const Polyhedron &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::bounded_H79_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#bounded_extrapolation">bounded extrapolation</a> between <code>*this</code> and <code>y</code> using the <a class="el" href="main.html#H79_widening">H79-widening</a> operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>A polyhedron that <em>must</em> be contained in <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>The system of constraints used to improve the widened polyhedron;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527e7c81841bbcf1963c6e260dadfe01"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_embed" ref="a527e7c81841bbcf1963c6e260dadfe01" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new space dimensions and embeds the old polyhedron in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The new space dimensions will be those having the highest indexes in the new polyhedron, which is characterized by a system of constraints in which the variables running through the new dimensions are not constrained. For instance, when starting from the polyhedron <img class="formulaInl" alt="$\cP \sseq \Rset^2$" src="form_161.png"/> and adding a third space dimension, the result will be the polyhedron </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cP \,\bigr\}. \]" src="form_706.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="aa6b6fed08414c86d33fc4a44c59e9e22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_project" ref="aa6b6fed08414c86d33fc4a44c59e9e22" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new space dimensions to the polyhedron and does not embed it in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of space dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The new space dimensions will be those having the highest indexes in the new polyhedron, which is characterized by a system of constraints in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the polyhedron <img class="formulaInl" alt="$\cP \sseq \Rset^2$" src="form_161.png"/> and adding a third space dimension, the result will be the polyhedron </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cP \,\bigr\}. \]" src="form_707.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a87ebe6f7cd176227f61c6d0fe47a4f68"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::concatenate_assign" ref="a87ebe6f7cd176227f61c6d0fe47a4f68" args="(const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3065d01256aa333117e0ee24d99b4431"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::remove_space_dimensions" ref="a3065d01256aa333117e0ee24d99b4431" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions from the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adee3b5c0c3800ce2214e68a156cbcf77"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::remove_higher_space_dimensions" ref="adee3b5c0c3800ce2214e68a156cbcf77" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions of the vector space so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a787615432c9f1d6aac5a6394aea8cfa9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::map_space_dimensions" ref="a787615432c9f1d6aac5a6394aea8cfa9" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&nbsp;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&nbsp;</td><td>The partial function specifying the destiny of each space dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template type parameter Partial_Function must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty codomain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the codomain of the partial function. The <code>max_in_codomain()</code> method is called at most once. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned. This method is called at most <img class="formulaInl" alt="$n$" src="form_0.png"/> times, where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the vector space enclosing the polyhedron.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="a6b737abc8f33b2a2362e3f9c9ab08d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::expand_space_dimension" ref="a6b737abc8f33b2a2362e3f9c9ab08d58" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&nbsp;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a73cb0d61cccb259e06b68d4f83deb6d7" title="Returns the maximum space dimension all kinds of Polyhedron can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="a418f9959fe50f163773ad9de147821ed"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::fold_space_dimensions" ref="a418f9959fe50f163773ad9de147821ed" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&nbsp;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="aca90e7afe251a0d4174dcf538b34006b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::swap" ref="aca90e7afe251a0d4174dcf538b34006b" args="(Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps <code>*this</code> with polyhedron <code>y</code>. (<code>*this</code> and <code>y</code> can be dimension-incompatible.). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86d2bbceaa288f2f605ac88516d313cb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::hash_code" ref="a86d2bbceaa288f2f605ac88516d313cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Parma_Polyhedra_Library::Polyhedron::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<a class="anchor" id="aa4fa3b0975b2971f5a2cbc5bc9621a81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points" ref="aa4fa3b0975b2971f5a2cbc5bc9621a81" args="(const Variables_Set *pvars, Complexity_Class complexity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Polyhedron::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> *&nbsp;</td>
          <td class="paramname"> <em>pvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&nbsp;</td>
          <td class="paramname"> <em>complexity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>*pvars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pvars</em>&nbsp;</td><td>When nonzero, points with non-integer coordinates for the variables/space-dimensions contained in <code>*pvars</code> can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&nbsp;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ad84befb6d0ded481871cbef1b7306824"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator&lt;&lt;" ref="ad84befb6d0ded481871cbef1b7306824" args="(std::ostream &amp;s, const Polyhedron &amp;ph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>
<p>Writes a textual representation of <code>ph</code> on <code>s:</code> <code>false</code> is written if <code>ph</code> is an empty polyhedron; <code>true</code> is written if <code>ph</code> is a universe polyhedron; a minimized system of constraints defining <code>ph</code> is written otherwise, all constraints in one row separated by ", ". </p>

</div>
</div>
<a class="anchor" id="a8af124edba7c75bc76ec394405aa893e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::operator!=" ref="a8af124edba7c75bc76ec394405aa893e" args="(const Polyhedron &amp;x, const Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different polyhedra. </p>
<p>Note that <code>x</code> and <code>y</code> may be topology- and/or dimension-incompatible polyhedra: in those cases, the value <code>true</code> is returned.</p>

</div>
</div>
<a class="anchor" id="a67a7d08f3cda46f7a743d46f3a6f33b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Polyhedron::swap" ref="a67a7d08f3cda46f7a743d46f3a6f33b5" args="(Parma_Polyhedra_Library::Polyhedron &amp;x, Parma_Polyhedra_Library::Polyhedron &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Parma_Polyhedra_Library::Polyhedron</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Feb 27 10:10:57 2011 for PPL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
